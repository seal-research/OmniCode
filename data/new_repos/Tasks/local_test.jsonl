{
    "repo": "Textualize/rich",
    "pull_number": 3296,
    "instance_id": "Textualize__rich-3296",
    "issue_numbers": [
        "3295"
    ],
    "base_commit": "fde5d6eee3b0437eaecdcbf6f8b11aeab3a5d503",
    "patch": "diff --git a/CHANGELOG.md b/CHANGELOG.md\nindex e153073c2..9eff3e39f 100644\n--- a/CHANGELOG.md\n+++ b/CHANGELOG.md\n@@ -5,7 +5,6 @@ All notable changes to this project will be documented in this file.\n The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),\n and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).\n \n-\n ## Unreleased\n \n ### Fixed\n@@ -16,6 +15,7 @@ and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0\n - Thread used in progress.track will exit if an exception occurs in a generator https://github.com/Textualize/rich/pull/3402\n - Progress track thread is now a daemon thread https://github.com/Textualize/rich/pull/3402\n - Fixed cached hash preservation upon clearing meta and links https://github.com/Textualize/rich/issues/2942\n+- Fixed overriding the `background_color` of `Syntax` not including padding https://github.com/Textualize/rich/issues/3295\n \n ### Changed\n \n@@ -31,6 +31,7 @@ and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0\n \n ## [13.7.1] - 2024-02-28\n \n+\n ### Fixed\n \n - Updated the widths of some characters https://github.com/Textualize/rich/pull/3289\ndiff --git a/CONTRIBUTORS.md b/CONTRIBUTORS.md\nindex b107adc83..0ce5307ab 100644\n--- a/CONTRIBUTORS.md\n+++ b/CONTRIBUTORS.md\n@@ -20,6 +20,7 @@ The following people have contributed to the development of Rich:\n - [Aryaz Eghbali](https://github.com/AryazE)\n - [Oleksis Fraga](https://github.com/oleksis)\n - [Andy Gimblett](https://github.com/gimbo)\n+- [Tom Gooding](https://github.com/TomJGooding)\n - [Micha\u0142 G\u00f3rny](https://github.com/mgorny)\n - [Nok Lam Chan](https://github.com/noklam)\n - [Leron Gray](https://github.com/daddycocoaman)\ndiff --git a/rich/syntax.py b/rich/syntax.py\nindex f3ceff758..4da6c3b7a 100644\n--- a/rich/syntax.py\n+++ b/rich/syntax.py\n@@ -619,9 +619,7 @@ def __rich_console__(\n     ) -> RenderResult:\n         segments = Segments(self._get_syntax(console, options))\n         if self.padding:\n-            yield Padding(\n-                segments, style=self._theme.get_background_style(), pad=self.padding\n-            )\n+            yield Padding(segments, style=self._get_base_style(), pad=self.padding)\n         else:\n             yield segments\n \n",
    "test_patch": "diff --git a/tests/test_syntax.py b/tests/test_syntax.py\nindex 37cc293eb..bbd4c7a5c 100644\n--- a/tests/test_syntax.py\n+++ b/tests/test_syntax.py\n@@ -406,6 +406,23 @@ def test_syntax_measure():\n     assert code.__rich_measure__(console, console.options) == Measurement(3, 24)\n \n \n+def test_background_color_override_includes_padding():\n+    \"\"\"Regression test for https://github.com/Textualize/rich/issues/3295\"\"\"\n+\n+    syntax = Syntax(\n+        \"x = 1\",\n+        lexer=\"python\",\n+        padding=(1, 3),\n+        background_color=\"red\",\n+    )\n+    result = render(syntax)\n+    print(repr(result))\n+    assert (\n+        result\n+        == \"\\x1b[41m                                                                                                    \\x1b[0m\\n\\x1b[41m   \\x1b[0m\\x1b[38;2;248;248;242;41mx\\x1b[0m\\x1b[38;2;248;248;242;41m \\x1b[0m\\x1b[38;2;255;70;137;41m=\\x1b[0m\\x1b[38;2;248;248;242;41m \\x1b[0m\\x1b[38;2;174;129;255;41m1\\x1b[0m\\x1b[41m                                                                                         \\x1b[0m\\x1b[41m   \\x1b[0m\\n\\x1b[41m                                                                                                    \\x1b[0m\\n\"\n+    )\n+\n+\n if __name__ == \"__main__\":\n     syntax = Panel.fit(\n         Syntax(\n",
    "problem_statement": "[BUG] Overriding `background_color` of `Syntax` doesn't include padding\n- [x] I've checked [docs](https://rich.readthedocs.io/en/latest/introduction.html) and [closed issues](https://github.com/Textualize/rich/issues?q=is%3Aissue+is%3Aclosed) for possible solutions.\r\n- [x] I can't find my issue in the [FAQ](https://github.com/Textualize/rich/blob/master/FAQ.md).\r\n\r\n**Describe the bug**\r\n\r\nSee https://github.com/Textualize/textual/discussions/4227#discussioncomment-8634837 for context.\r\n\r\nAccording to the [Syntax documentation](https://rich.readthedocs.io/en/stable/syntax.html#background-color):\r\n\r\n> You can override the background color from the theme by supplying a background_color argument to the constructor.\r\n\r\nHowever this doesn't seem to work as expected if the `Syntax` has padding:\r\n\r\n![image](https://github.com/Textualize/rich/assets/101601846/65b375da-a8ca-4f6d-b208-4f2435f713f8)\r\n\r\n```python\r\nfrom rich.console import Console\r\nfrom rich.syntax import Syntax\r\n\r\ncode = \"\"\"\\\r\ndef do_something():\r\n    pass\\\r\n\"\"\"\r\n\r\nconsole = Console()\r\n\r\nsyntax = Syntax(\r\n    code,\r\n    lexer=\"python\",\r\n    word_wrap=False,\r\n    indent_guides=True,\r\n    padding=(1, 2),\r\n    theme=\"material\",\r\n    background_color=\"red\",\r\n)\r\n\r\nconsole.print(syntax)\r\n```\r\n\r\nIf you set the `background_color` to the special value \"default\", this produces a different unexpected result:\r\n\r\n![image](https://github.com/Textualize/rich/assets/101601846/9a21cdf2-3617-4cb8-9e60-1891a8b7a67a)\r\n\r\n**Platform**\r\n\r\nPlatform is Linux and tested in various terminal emulators.\r\n\r\n```console\r\n$ pip freeze | grep rich\r\nrich==13.6.0\r\n```\n",
    "hints_text": "Thank you for your issue. Give us a little time to review it.\n\nPS. You might want to check the [FAQ](https://github.com/textualize/rich/blob/master/FAQ.md) if you haven't done so already.\n\nThis is an automated reply, generated by [FAQtory](https://github.com/willmcgugan/faqtory)",
    "created_at": "2024-02-29T20:41:42Z"
},
{
    "repo": "Textualize/rich",
    "pull_number": 3180,
    "instance_id": "Textualize__rich-3180",
    "issue_numbers": [
        "3176"
    ],
    "base_commit": "e76f3c3ea78481342e21a7b3328075462ab69c2b",
    "patch": "diff --git a/.gitignore b/.gitignore\nindex b291d4c2a..4d0a1d3a8 100644\n--- a/.gitignore\n+++ b/.gitignore\n@@ -117,3 +117,5 @@ venv.bak/\n # airspeed velocity\n benchmarks/env/\n benchmarks/html/\n+\n+sandbox/\ndiff --git a/CHANGELOG.md b/CHANGELOG.md\nindex 3562f6df6..64bcc5606 100644\n--- a/CHANGELOG.md\n+++ b/CHANGELOG.md\n@@ -13,6 +13,7 @@ and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0\n \n ### Fixed\n \n+- Some text goes missing during wrapping when it contains double width characters https://github.com/Textualize/rich/issues/3176\n - Ensure font is correctly inherited in exported HTML https://github.com/Textualize/rich/issues/3104\n \n ## [13.6.0] - 2023-09-30\ndiff --git a/rich/_wrap.py b/rich/_wrap.py\nindex c45f193f7..2e94ff6f4 100644\n--- a/rich/_wrap.py\n+++ b/rich/_wrap.py\n@@ -1,5 +1,7 @@\n+from __future__ import annotations\n+\n import re\n-from typing import Iterable, List, Tuple\n+from typing import Iterable\n \n from ._loop import loop_last\n from .cells import cell_len, chop_cells\n@@ -7,7 +9,11 @@\n re_word = re.compile(r\"\\s*\\S+\\s*\")\n \n \n-def words(text: str) -> Iterable[Tuple[int, int, str]]:\n+def words(text: str) -> Iterable[tuple[int, int, str]]:\n+    \"\"\"Yields each word from the text as a tuple\n+    containing (start_index, end_index, word). A \"word\" in this context may\n+    include the actual word and any whitespace to the right.\n+    \"\"\"\n     position = 0\n     word_match = re_word.match(text, position)\n     while word_match is not None:\n@@ -17,35 +23,59 @@ def words(text: str) -> Iterable[Tuple[int, int, str]]:\n         word_match = re_word.match(text, end)\n \n \n-def divide_line(text: str, width: int, fold: bool = True) -> List[int]:\n-    divides: List[int] = []\n-    append = divides.append\n-    line_position = 0\n+def divide_line(text: str, width: int, fold: bool = True) -> list[int]:\n+    \"\"\"Given a string of text, and a width (measured in cells), return a list\n+    of cell offsets which the string should be split at in order for it to fit\n+    within the given width.\n+\n+    Args:\n+        text: The text to examine.\n+        width: The available cell width.\n+        fold: If True, words longer than `width` will be folded onto a new line.\n+\n+    Returns:\n+        A list of indices to break the line at.\n+    \"\"\"\n+    break_positions: list[int] = []  # offsets to insert the breaks at\n+    append = break_positions.append\n+    cell_offset = 0\n     _cell_len = cell_len\n+\n     for start, _end, word in words(text):\n         word_length = _cell_len(word.rstrip())\n-        if line_position + word_length > width:\n+        remaining_space = width - cell_offset\n+        word_fits_remaining_space = remaining_space >= word_length\n+\n+        if word_fits_remaining_space:\n+            # Simplest case - the word fits within the remaining width for this line.\n+            cell_offset += _cell_len(word)\n+        else:\n+            # Not enough space remaining for this word on the current line.\n             if word_length > width:\n+                # The word doesn't fit on any line, so we can't simply\n+                # place it on the next line...\n                 if fold:\n-                    chopped_words = chop_cells(word, max_size=width, position=0)\n-                    for last, line in loop_last(chopped_words):\n+                    # Fold the word across multiple lines.\n+                    folded_word = chop_cells(word, width=width)\n+                    for last, line in loop_last(folded_word):\n                         if start:\n                             append(start)\n-\n                         if last:\n-                            line_position = _cell_len(line)\n+                            cell_offset = _cell_len(line)\n                         else:\n                             start += len(line)\n                 else:\n+                    # Folding isn't allowed, so crop the word.\n                     if start:\n                         append(start)\n-                    line_position = _cell_len(word)\n-            elif line_position and start:\n+                    cell_offset = _cell_len(word)\n+            elif cell_offset and start:\n+                # The word doesn't fit within the remaining space on the current\n+                # line, but it *can* fit on to the next (empty) line.\n                 append(start)\n-                line_position = _cell_len(word)\n-        else:\n-            line_position += _cell_len(word)\n-    return divides\n+                cell_offset = _cell_len(word)\n+\n+    return break_positions\n \n \n if __name__ == \"__main__\":  # pragma: no cover\n@@ -53,4 +83,11 @@ def divide_line(text: str, width: int, fold: bool = True) -> List[int]:\n \n     console = Console(width=10)\n     console.print(\"12345 abcdefghijklmnopqrstuvwyxzABCDEFGHIJKLMNOPQRSTUVWXYZ 12345\")\n-    print(chop_cells(\"abcdefghijklmnopqrstuvwxyz\", 10, position=2))\n+    print(chop_cells(\"abcdefghijklmnopqrstuvwxyz\", 10))\n+\n+    console = Console(width=20)\n+    console.rule()\n+    console.print(\"Textual\u306fPython\u306e\u9ad8\u901f\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u958b\u767a\u30d5\u30ec\u30fc\u30e0\u30ef\u30fc\u30af\u3067\u3059\")\n+\n+    console.rule()\n+    console.print(\"\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u306f1670\u4e07\u8272\u3092\u4f7f\u7528\u3067\u304d\")\ndiff --git a/rich/cells.py b/rich/cells.py\nindex 9354f9e31..c0ddef6e7 100644\n--- a/rich/cells.py\n+++ b/rich/cells.py\n@@ -1,6 +1,8 @@\n+from __future__ import annotations\n+\n import re\n from functools import lru_cache\n-from typing import Callable, List\n+from typing import Callable\n \n from ._cell_widths import CELL_WIDTHS\n \n@@ -119,27 +121,39 @@ def set_cell_size(text: str, total: int) -> str:\n             start = pos\n \n \n-# TODO: This is inefficient\n-# TODO: This might not work with CWJ type characters\n-def chop_cells(text: str, max_size: int, position: int = 0) -> List[str]:\n-    \"\"\"Break text in to equal (cell) length strings, returning the characters in reverse\n-    order\"\"\"\n+def chop_cells(\n+    text: str,\n+    width: int,\n+) -> list[str]:\n+    \"\"\"Split text into lines such that each line fits within the available (cell) width.\n+\n+    Args:\n+        text: The text to fold such that it fits in the given width.\n+        width: The width available (number of cells).\n+\n+    Returns:\n+        A list of strings such that each string in the list has cell width\n+        less than or equal to the available width.\n+    \"\"\"\n     _get_character_cell_size = get_character_cell_size\n-    characters = [\n-        (character, _get_character_cell_size(character)) for character in text\n-    ]\n-    total_size = position\n-    lines: List[List[str]] = [[]]\n-    append = lines[-1].append\n-\n-    for character, size in reversed(characters):\n-        if total_size + size > max_size:\n-            lines.append([character])\n-            append = lines[-1].append\n-            total_size = size\n+    lines: list[list[str]] = [[]]\n+\n+    append_new_line = lines.append\n+    append_to_last_line = lines[-1].append\n+\n+    total_width = 0\n+\n+    for character in text:\n+        cell_width = _get_character_cell_size(character)\n+        char_doesnt_fit = total_width + cell_width > width\n+\n+        if char_doesnt_fit:\n+            append_new_line([character])\n+            append_to_last_line = lines[-1].append\n+            total_width = cell_width\n         else:\n-            total_size += size\n-            append(character)\n+            append_to_last_line(character)\n+            total_width += cell_width\n \n     return [\"\".join(line) for line in lines]\n \n",
    "test_patch": "diff --git a/tests/test_cells.py b/tests/test_cells.py\nindex 50fa52192..fe451fa57 100644\n--- a/tests/test_cells.py\n+++ b/tests/test_cells.py\n@@ -1,4 +1,5 @@\n from rich import cells\n+from rich.cells import chop_cells\n \n \n def test_cell_len_long_string():\n@@ -40,3 +41,21 @@ def test_set_cell_size_infinite():\n             )\n             == size\n         )\n+\n+\n+def test_chop_cells():\n+    \"\"\"Simple example of splitting cells into lines of width 3.\"\"\"\n+    text = \"abcdefghijk\"\n+    assert chop_cells(text, 3) == [\"abc\", \"def\", \"ghi\", \"jk\"]\n+\n+\n+def test_chop_cells_double_width_boundary():\n+    \"\"\"The available width lies within a double-width character.\"\"\"\n+    text = \"\u3042\u308a\u304c\u3068\u3046\"\n+    assert chop_cells(text, 3) == [\"\u3042\", \"\u308a\", \"\u304c\", \"\u3068\", \"\u3046\"]\n+\n+\n+def test_chop_cells_mixed_width():\n+    \"\"\"Mixed single and double-width characters.\"\"\"\n+    text = \"\u30421\u308a234\u304c5\u30686\u304678\"\n+    assert chop_cells(text, 3) == [\"\u30421\", \"\u308a2\", \"34\", \"\u304c5\", \"\u30686\", \"\u30467\", \"8\"]\ndiff --git a/tests/test_text.py b/tests/test_text.py\nindex 22c34e442..18c91cffa 100644\n--- a/tests/test_text.py\n+++ b/tests/test_text.py\n@@ -449,6 +449,20 @@ def test_wrap_cjk_width_mid_character():\n     ]\n \n \n+def test_wrap_cjk_mixed():\n+    \"\"\"Regression test covering https://github.com/Textualize/rich/issues/3176 and\n+    https://github.com/Textualize/textual/issues/3567 - double width characters could\n+    result in text going missing when wrapping.\"\"\"\n+    text = Text(\"123\u3042\u308a\u304c\u3068\u3046\u3054\u3056\u3044\u307e\u3057\u305f\")\n+    console = Console(width=20)  # let's ensure the width passed to wrap() wins.\n+\n+    wrapped_lines = text.wrap(console, width=8)\n+    with console.capture() as capture:\n+        console.print(wrapped_lines)\n+\n+    assert capture.get() == \"123\u3042\u308a\\n\u304c\u3068\u3046\u3054\\n\u3056\u3044\u307e\u3057\\n\u305f\\n\"\n+\n+\n def test_wrap_long():\n     text = Text(\"abracadabra\", justify=\"left\")\n     lines = text.wrap(Console(), 4)\n@@ -497,6 +511,47 @@ def test_wrap_long_words_2():\n     ]\n \n \n+def test_wrap_long_words_followed_by_other_words():\n+    \"\"\"After folding a word across multiple lines, we should continue from\n+    the next word immediately after the folded word (don't take a newline\n+    following completion of the folded word).\"\"\"\n+    text = Text(\"123 12345678 123 123\")\n+    lines = text.wrap(Console(), 6)\n+    assert lines._lines == [\n+        Text(\"123 \"),\n+        Text(\"123456\"),\n+        Text(\"78 123\"),\n+        Text(\"123\"),\n+    ]\n+\n+\n+def test_wrap_long_word_preceeded_by_word_of_full_line_length():\n+    \"\"\"The width of the first word is the same as the available width.\n+    Ensures that folding works correctly when there's no space available\n+    on the current line.\"\"\"\n+    text = Text(\"123456 12345678 123 123\")\n+    lines = text.wrap(Console(), 6)\n+    assert lines._lines == [\n+        Text(\"123456\"),\n+        Text(\"123456\"),\n+        Text(\"78 123\"),\n+        Text(\"123\"),\n+    ]\n+\n+\n+def test_wrap_multiple_consecutive_spaces():\n+    \"\"\"Adding multiple consecutive spaces at the end of a line does not impact\n+    the location at which a break will be added during the process of wrapping.\"\"\"\n+    text = Text(\"123456    12345678 123 123\")\n+    lines = text.wrap(Console(), 6)\n+    assert lines._lines == [\n+        Text(\"123456\"),\n+        Text(\"123456\"),\n+        Text(\"78 123\"),\n+        Text(\"123\"),\n+    ]\n+\n+\n def test_wrap_long_words_justify_left():\n     text = Text(\"X 123456789\", justify=\"left\")\n     lines = text.wrap(Console(), 4)\n@@ -508,6 +563,17 @@ def test_wrap_long_words_justify_left():\n     assert lines[3] == Text(\"9   \")\n \n \n+def test_wrap_leading_and_trailing_whitespace():\n+    text = Text(\"   123  456 789   \")\n+    lines = text.wrap(Console(), 4)\n+    assert lines._lines == [\n+        Text(\"   1\"),\n+        Text(\"23  \"),\n+        Text(\"456 \"),\n+        Text(\"789 \"),\n+    ]\n+\n+\n def test_no_wrap_no_crop():\n     text = Text(\"Hello World!\" * 3)\n \n",
    "problem_statement": "[BUG] Chunks of text go missing when writing Asian text (wrapping issue)\n### Description\r\n\r\n(Originally reported in Textual: https://github.com/Textualize/textual/issues/3567)\r\n\r\nWhen you print Asian text (specifically Chinese and Japanese, which do not use spaces), portions of the text go missing, making it unreadable.\r\n\r\nThis seems to be related to wrapping, as the characters which go missing are at the end of a line.\r\nInstead of being wrapped on to a new line, they disappear.\r\n\r\nThere are [rules for wrapping](https://en.m.wikipedia.org/wiki/Line_breaking_rules_in_East_Asian_languages) in these languages which would take more effort to adhere to, but at the very least, text should not go missing when printed.\r\n\r\n### Examples\r\n\r\nFor example, running the snippet below, the `7` in `1670` disappears:\r\n\r\n```python\r\nfrom rich.console import Console\r\nconsole = Console(width=20)\r\nconsole.print(\"\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u306f1670\u4e07\u8272\u3092\u4f7f\u7528\u3067\u304d\")\r\n```\r\n\r\nOutput:\r\n\r\n```\r\n\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u306f16\r\n0\u4e07\u8272\u3092\u4f7f\u7528\u3067\u304d\r\n```\r\n\r\nAnd in many cases, like those reported in this issue, multiple characters disappear:\r\n\r\n```python\r\nfrom rich.console import Console\r\nconsole = Console(width=20)\r\nconsole.print(\"Textual\u306fPython\u306e\u9ad8\u901f\u30a2\u30d7\u30ea\u30b1\u30fc\u30b7\u30e7\u30f3\u958b\u767a\u30d5\u30ec\u30fc\u30e0\u30ef\u30fc\u30af\u3067\u3059\")\r\n```\r\n\r\nOutput:\r\n\r\n```\r\nTextual\u306fPy\r\nthon\u306e\u9ad8\u901f\u30a2\u30d7\u30ea\r\n\u30b1\u30fc\u30b7\u30e7\u30f3\u958b\u767a\u30d5\u30ec\u30fc\r\n```\r\n\r\nNotice that many of the characters at the end of the text are completely missing (`\u30e0\u30ef\u30fc\u30af\u3067\u3059`).\r\n\n",
    "hints_text": "",
    "created_at": "2023-11-01T16:49:15Z"
}