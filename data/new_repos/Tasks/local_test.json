{"repo": "freqtrade/freqtrade", "pull_number": 11412, "instance_id": "freqtrade__freqtrade-11412", "issue_numbers": ["11177"], "base_commit": "fc4e09f398408f80142d4d34e5e30f1c8e3bda8a", "patch": "diff --git a/docs/bot-basics.md b/docs/bot-basics.md\nindex 1c88559c0eb..ff73aecdeed 100644\n--- a/docs/bot-basics.md\n+++ b/docs/bot-basics.md\n@@ -54,11 +54,13 @@ By default, the bot loop runs every few seconds (`internals.process_throttle_sec\n   * Check timeouts for open orders.\n     * Calls `check_entry_timeout()` strategy callback for open entry orders.\n     * Calls `check_exit_timeout()` strategy callback for open exit orders.\n-    * Calls `adjust_entry_price()` strategy callback for open entry orders.\n+    * Calls `adjust_order_price()` strategy callback for open orders.\n+      * Calls `adjust_entry_price()` strategy callback for open entry orders. *only called when `adjust_order_price()` is not implemented*\n+      * Calls `adjust_exit_price()` strategy callback for open exit orders. *only called when `adjust_order_price()` is not implemented*\n * Verifies existing positions and eventually places exit orders.\n   * Considers stoploss, ROI and exit-signal, `custom_exit()` and `custom_stoploss()`.\n   * Determine exit-price based on `exit_pricing` configuration setting or by using the `custom_exit_price()` callback.\n-  * Before a exit order is placed, `confirm_trade_exit()` strategy callback is called.\n+  * Before an exit order is placed, `confirm_trade_exit()` strategy callback is called.\n * Check position adjustments for open trades if enabled by calling `adjust_trade_position()` and place additional order if required.\n * Check if trade-slots are still available (if `max_open_trades` is reached).\n * Verifies entry signal trying to enter new positions.\n@@ -80,7 +82,9 @@ This loop will be repeated again and again until the bot is stopped.\n * Loops per candle simulating entry and exit points.\n   * Calls `bot_loop_start()` strategy callback.\n   * Check for Order timeouts, either via the `unfilledtimeout` configuration, or via `check_entry_timeout()` / `check_exit_timeout()` strategy callbacks.\n-  * Calls `adjust_entry_price()` strategy callback for open entry orders.\n+  * Calls `adjust_order_price()` strategy callback for open orders.\n+    * Calls `adjust_entry_price()` strategy callback for open entry orders. *only called when `adjust_order_price()` is not implemented!*\n+    * Calls `adjust_exit_price()` strategy callback for open exit orders. *only called when `adjust_order_price()` is not implemented!*\n   * Check for trade entry signals (`enter_long` / `enter_short` columns).\n   * Confirm trade entry / exits (calls `confirm_trade_entry()` and `confirm_trade_exit()` if implemented in the strategy).\n   * Call `custom_entry_price()` (if implemented in the strategy) to determine entry price (Prices are moved to be within the opening candle).\ndiff --git a/docs/strategy-callbacks.md b/docs/strategy-callbacks.md\nindex 64f7987f606..8c9dd1a2e60 100644\n--- a/docs/strategy-callbacks.md\n+++ b/docs/strategy-callbacks.md\n@@ -934,28 +934,25 @@ class DigDeeperStrategy(IStrategy):\n \n     The total profit for this trade was 950$ on a 3350$ investment (`100@8$ + 100@9$ + 150@11$`). As such - the final relative profit is 28.35% (`950 / 3350`).\n \n-## Adjust Entry Price\n+## Adjust order Price\n \n-The `adjust_entry_price()` callback may be used by strategy developer to refresh/replace limit orders upon arrival of new candles.  \n+The `adjust_order_price()` callback may be used by strategy developer to refresh/replace limit orders upon arrival of new candles.  \n This callback is called once every iteration unless the order has been (re)placed within the current candle - limiting the maximum (re)placement of each order to once per candle.\n This also means that the first call will be at the start of the next candle after the initial order was placed.\n \n-Be aware that `custom_entry_price()` is still the one dictating initial entry limit order price target at the time of entry trigger.\n+Be aware that `custom_entry_price()`/`custom_exit_price()` is still the one dictating initial limit order price target at the time of the signal.\n \n Orders can be cancelled out of this callback by returning `None`.\n \n Returning `current_order_rate` will keep the order on the exchange \"as is\".\n Returning any other price will cancel the existing order, and replace it with a new order.\n \n-The trade open-date (`trade.open_date_utc`) will remain at the time of the very first order placed.\n-Please make sure to be aware of this - and eventually adjust your logic in other callbacks to account for this, and use the date of the first filled order instead.\n-\n If the cancellation of the original order fails, then the order will not be replaced - though the order will most likely have been canceled on exchange. Having this happen on initial entries will result in the deletion of the order, while on position adjustment orders, it'll result in the trade size remaining as is.  \n-If the order has been partially filled, the order will not be replaced. You can however use [`adjust_trade_position()`](#adjust-trade-position) to adjust the trade size to the full, expected position size, should this be necessary / desired.\n+If the order has been partially filled, the order will not be replaced. You can however use [`adjust_trade_position()`](#adjust-trade-position) to adjust the trade size to the expected position size, should this be necessary / desired.\n \n !!! Warning \"Regular timeout\"\n-    Entry `unfilledtimeout` mechanism (as well as `check_entry_timeout()`) takes precedence over this.\n-    Entry Orders that are cancelled via the above methods will not have this callback called. Be sure to update timeout values to match your expectations.\n+    Entry `unfilledtimeout` mechanism (as well as `check_entry_timeout()`/`check_exit_timeout()`) takes precedence over this callback.\n+    Orders that are cancelled via the above methods will not have this callback called. Be sure to update timeout values to match your expectations.\n \n ```python\n # Default imports\n@@ -964,14 +961,26 @@ class AwesomeStrategy(IStrategy):\n \n     # ... populate_* methods\n \n-    def adjust_entry_price(self, trade: Trade, order: Order | None, pair: str,\n-                           current_time: datetime, proposed_rate: float, current_order_rate: float,\n-                           entry_tag: str | None, side: str, **kwargs) -> float:\n+    def adjust_order_price(\n+        self,\n+        trade: Trade,\n+        order: Order | None,\n+        pair: str,\n+        current_time: datetime,\n+        proposed_rate: float,\n+        current_order_rate: float,\n+        entry_tag: str | None,\n+        side: str,\n+        is_entry: bool,\n+        **kwargs,\n+    ) -> float:\n         \"\"\"\n-        Entry price re-adjustment logic, returning the user desired limit price.\n+        Exit and entry order price re-adjustment logic, returning the user desired limit price.\n         This only executes when a order was already placed, still open (unfilled fully or partially)\n         and not timed out on subsequent candles after entry trigger.\n \n+        For full documentation please go to https://www.freqtrade.io/en/latest/strategy-callbacks/\n+\n         When not implemented by a strategy, returns current_order_rate as default.\n         If current_order_rate is returned then the existing order is maintained.\n         If None is returned then order gets canceled but not replaced by a new one.\n@@ -983,14 +992,16 @@ class AwesomeStrategy(IStrategy):\n         :param proposed_rate: Rate, calculated based on pricing settings in entry_pricing.\n         :param current_order_rate: Rate of the existing order in place.\n         :param entry_tag: Optional entry_tag (buy_tag) if provided with the buy signal.\n-        :param side: \"long\" or \"short\" - indicating the direction of the proposed trade\n+        :param side: 'long' or 'short' - indicating the direction of the proposed trade\n+        :param is_entry: True if the order is an entry order, False if it's an exit order.\n         :param **kwargs: Ensure to keep this here so updates to this won't break your strategy.\n         :return float: New entry price value if provided\n-\n         \"\"\"\n-        # Limit orders to use and follow SMA200 as price target for the first 10 minutes since entry trigger for BTC/USDT pair.\n+\n+        # Limit entry orders to use and follow SMA200 as price target for the first 10 minutes since entry trigger for BTC/USDT pair.\n         if (\n-            pair == \"BTC/USDT\" \n+            is_entry\n+            and pair == \"BTC/USDT\" \n             and entry_tag == \"long_sma200\" \n             and side == \"long\" \n             and (current_time - timedelta(minutes=10)) <= trade.open_date_utc\n@@ -1007,6 +1018,26 @@ class AwesomeStrategy(IStrategy):\n         return current_order_rate\n ```\n \n+!!! danger \"Incompatibility with `adjust_*_price()`\"\n+    If you have both `adjust_order_price()` and `adjust_entry_price()`/`adjust_exit_price()` implemented, only `adjust_order_price()` will be used.\n+    If you need to adjust entry/exit prices, you can either implement the logic in `adjust_order_price()`, or use the split `adjust_entry_price()` / `adjust_exit_price()` callbacks, but not both.\n+    Mixing these is not supported and will raise an error during bot startup.\n+\n+### Adjust Entry Price\n+\n+The `adjust_entry_price()` callback may be used by strategy developer to refresh/replace entry limit orders upon arrival.\n+It's a sub-set of `adjust_order_price()` and is called only for entry orders.\n+All remaining behavior is identical to `adjust_order_price()`.\n+\n+The trade open-date (`trade.open_date_utc`) will remain at the time of the very first order placed.\n+Please make sure to be aware of this - and eventually adjust your logic in other callbacks to account for this, and use the date of the first filled order instead.\n+\n+### Adjust Exit Price\n+\n+The `adjust_exit_price()` callback may be used by strategy developer to refresh/replace exit limit orders upon arrival.\n+It's a sub-set of `adjust_order_price()` and is called only for exit orders.\n+All remaining behavior is identical to `adjust_order_price()`.\n+\n ## Leverage Callback\n \n When trading in markets that allow leverage, this method must return the desired Leverage (Defaults to 1 -> No leverage).\ndiff --git a/freqtrade/freqtradebot.py b/freqtrade/freqtradebot.py\nindex 84731117a78..a3bc6c11ffb 100644\n--- a/freqtrade/freqtradebot.py\n+++ b/freqtrade/freqtradebot.py\n@@ -1603,27 +1603,29 @@ def manage_open_orders(self) -> None:\n                         self.replace_order(order, open_order, trade)\n \n     def handle_cancel_order(\n-        self, order: CcxtOrder, order_obj: Order, trade: Trade, reason: str\n-    ) -> None:\n+        self, order: CcxtOrder, order_obj: Order, trade: Trade, reason: str, replacing: bool = False\n+    ) -> bool:\n         \"\"\"\n         Check if current analyzed order timed out and cancel if necessary.\n         :param order: Order dict grabbed with exchange.fetch_order()\n         :param order_obj: Order object from the database.\n         :param trade: Trade object.\n-        :return: None\n+        :return: True if the order was canceled, False otherwise.\n         \"\"\"\n         if order[\"side\"] == trade.entry_side:\n-            self.handle_cancel_enter(trade, order, order_obj, reason)\n+            return self.handle_cancel_enter(trade, order, order_obj, reason, replacing)\n         else:\n             canceled = self.handle_cancel_exit(trade, order, order_obj, reason)\n-            canceled_count = trade.get_canceled_exit_order_count()\n-            max_timeouts = self.config.get(\"unfilledtimeout\", {}).get(\"exit_timeout_count\", 0)\n-            if canceled and max_timeouts > 0 and canceled_count >= max_timeouts:\n-                logger.warning(\n-                    f\"Emergency exiting trade {trade}, as the exit order \"\n-                    f\"timed out {max_timeouts} times. force selling {order['amount']}.\"\n-                )\n-                self.emergency_exit(trade, order[\"price\"], order[\"amount\"])\n+            if not replacing:\n+                canceled_count = trade.get_canceled_exit_order_count()\n+                max_timeouts = self.config.get(\"unfilledtimeout\", {}).get(\"exit_timeout_count\", 0)\n+                if canceled and max_timeouts > 0 and canceled_count >= max_timeouts:\n+                    logger.warning(\n+                        f\"Emergency exiting trade {trade}, as the exit order \"\n+                        f\"timed out {max_timeouts} times. force selling {order['amount']}.\"\n+                    )\n+                    self.emergency_exit(trade, order[\"price\"], order[\"amount\"])\n+            return canceled\n \n     def emergency_exit(\n         self, trade: Trade, price: float, sub_trade_amt: float | None = None\n@@ -1659,9 +1661,9 @@ def replace_order_failed(self, trade: Trade, msg: str) -> None:\n     def replace_order(self, order: CcxtOrder, order_obj: Order | None, trade: Trade) -> None:\n         \"\"\"\n         Check if current analyzed entry order should be replaced or simply cancelled.\n-        To simply cancel the existing order(no replacement) adjust_entry_price() should return None\n-        To maintain existing order adjust_entry_price() should return order_obj.price\n-        To replace existing order adjust_entry_price() should return desired price for limit order\n+        To simply cancel the existing order(no replacement) adjust_order_price() should return None\n+        To maintain existing order adjust_order_price() should return order_obj.price\n+        To replace existing order adjust_order_price() should return desired price for limit order\n         :param order: Order dict grabbed with exchange.fetch_order()\n         :param order_obj: Order object.\n         :param trade: Trade object.\n@@ -1675,17 +1677,17 @@ def replace_order(self, order: CcxtOrder, order_obj: Order | None, trade: Trade)\n             self.strategy.timeframe, latest_candle_open_date\n         )\n         # Check if new candle\n-        if (\n-            order_obj\n-            and order_obj.side == trade.entry_side\n-            and latest_candle_close_date > order_obj.order_date_utc\n-        ):\n+        if order_obj and latest_candle_close_date > order_obj.order_date_utc:\n+            is_entry = order_obj.side == trade.entry_side\n             # New candle\n             proposed_rate = self.exchange.get_rate(\n-                trade.pair, side=\"entry\", is_short=trade.is_short, refresh=True\n+                trade.pair,\n+                side=\"entry\" if is_entry else \"exit\",\n+                is_short=trade.is_short,\n+                refresh=True,\n             )\n-            adjusted_entry_price = strategy_safe_wrapper(\n-                self.strategy.adjust_entry_price, default_retval=order_obj.safe_placement_price\n+            adjusted_price = strategy_safe_wrapper(\n+                self.strategy.adjust_order_price, default_retval=order_obj.safe_placement_price\n             )(\n                 trade=trade,\n                 order=order_obj,\n@@ -1695,36 +1697,51 @@ def replace_order(self, order: CcxtOrder, order_obj: Order | None, trade: Trade)\n                 current_order_rate=order_obj.safe_placement_price,\n                 entry_tag=trade.enter_tag,\n                 side=trade.trade_direction,\n+                is_entry=is_entry,\n             )\n \n             replacing = True\n             cancel_reason = constants.CANCEL_REASON[\"REPLACE\"]\n-            if not adjusted_entry_price:\n+            if not adjusted_price:\n                 replacing = False\n                 cancel_reason = constants.CANCEL_REASON[\"USER_CANCEL\"]\n-            if order_obj.safe_placement_price != adjusted_entry_price:\n+\n+            if order_obj.safe_placement_price != adjusted_price:\n                 # cancel existing order if new price is supplied or None\n-                res = self.handle_cancel_enter(\n-                    trade, order, order_obj, cancel_reason, replacing=replacing\n+                res = self.handle_cancel_order(\n+                    order, order_obj, trade, cancel_reason, replacing=replacing\n                 )\n                 if not res:\n                     self.replace_order_failed(\n                         trade, f\"Could not fully cancel order for {trade}, therefore not replacing.\"\n                     )\n                     return\n-                if adjusted_entry_price:\n+                if adjusted_price:\n                     # place new order only if new price is supplied\n                     try:\n-                        if not self.execute_entry(\n-                            pair=trade.pair,\n-                            stake_amount=(\n-                                order_obj.safe_remaining * order_obj.safe_price / trade.leverage\n-                            ),\n-                            price=adjusted_entry_price,\n-                            trade=trade,\n-                            is_short=trade.is_short,\n-                            mode=\"replace\",\n-                        ):\n+                        if is_entry:\n+                            succeeded = self.execute_entry(\n+                                pair=trade.pair,\n+                                stake_amount=(\n+                                    order_obj.safe_remaining * order_obj.safe_price / trade.leverage\n+                                ),\n+                                price=adjusted_price,\n+                                trade=trade,\n+                                is_short=trade.is_short,\n+                                mode=\"replace\",\n+                            )\n+                        else:\n+                            succeeded = self.execute_trade_exit(\n+                                trade,\n+                                adjusted_price,\n+                                exit_check=ExitCheckTuple(\n+                                    exit_type=ExitType.CUSTOM_EXIT,\n+                                    exit_reason=order_obj.ft_order_tag or \"order_replaced\",\n+                                ),\n+                                ordertype=\"limit\",\n+                                sub_trade_amt=order_obj.safe_remaining,\n+                            )\n+                        if not succeeded:\n                             self.replace_order_failed(\n                                 trade, f\"Could not replace order for {trade}.\"\n                             )\ndiff --git a/freqtrade/resolvers/strategy_resolver.py b/freqtrade/resolvers/strategy_resolver.py\nindex a3ec03e2b97..b56ed8e117f 100644\n--- a/freqtrade/resolvers/strategy_resolver.py\n+++ b/freqtrade/resolvers/strategy_resolver.py\n@@ -242,6 +242,14 @@ def validate_strategy(strategy: IStrategy) -> IStrategy:\n         if has_after_fill:\n             strategy._ft_stop_uses_after_fill = True\n \n+        if check_override(strategy, IStrategy, \"adjust_order_price\") and (\n+            check_override(strategy, IStrategy, \"adjust_entry_price\")\n+            or check_override(strategy, IStrategy, \"adjust_exit_price\")\n+        ):\n+            raise OperationalException(\n+                \"If you implement `adjust_order_price`, `adjust_entry_price` and \"\n+                \"`adjust_exit_price` will not be used. Please pick one approach for your strategy.\"\n+            )\n         return strategy\n \n     @staticmethod\ndiff --git a/freqtrade/strategy/interface.py b/freqtrade/strategy/interface.py\nindex 77fe2a84a2a..79ea094c973 100644\n--- a/freqtrade/strategy/interface.py\n+++ b/freqtrade/strategy/interface.py\n@@ -690,6 +690,104 @@ def adjust_entry_price(\n         \"\"\"\n         return current_order_rate\n \n+    def adjust_exit_price(\n+        self,\n+        trade: Trade,\n+        order: Order | None,\n+        pair: str,\n+        current_time: datetime,\n+        proposed_rate: float,\n+        current_order_rate: float,\n+        entry_tag: str | None,\n+        side: str,\n+        **kwargs,\n+    ) -> float:\n+        \"\"\"\n+        Exit price re-adjustment logic, returning the user desired limit price.\n+        This only executes when a order was already placed, still open (unfilled fully or partially)\n+        and not timed out on subsequent candles after entry trigger.\n+\n+        For full documentation please go to https://www.freqtrade.io/en/latest/strategy-callbacks/\n+\n+        When not implemented by a strategy, returns current_order_rate as default.\n+        If current_order_rate is returned then the existing order is maintained.\n+        If None is returned then order gets canceled but not replaced by a new one.\n+\n+        :param pair: Pair that's currently analyzed\n+        :param trade: Trade object.\n+        :param order: Order object\n+        :param current_time: datetime object, containing the current datetime\n+        :param proposed_rate: Rate, calculated based on pricing settings in entry_pricing.\n+        :param current_order_rate: Rate of the existing order in place.\n+        :param entry_tag: Optional entry_tag (buy_tag) if provided with the buy signal.\n+        :param side: 'long' or 'short' - indicating the direction of the proposed trade\n+        :param **kwargs: Ensure to keep this here so updates to this won't break your strategy.\n+        :return float: New entry price value if provided\n+\n+        \"\"\"\n+        return current_order_rate\n+\n+    def adjust_order_price(\n+        self,\n+        trade: Trade,\n+        order: Order | None,\n+        pair: str,\n+        current_time: datetime,\n+        proposed_rate: float,\n+        current_order_rate: float,\n+        entry_tag: str | None,\n+        side: str,\n+        is_entry: bool,\n+        **kwargs,\n+    ) -> float:\n+        \"\"\"\n+        Exit and entry order price re-adjustment logic, returning the user desired limit price.\n+        This only executes when a order was already placed, still open (unfilled fully or partially)\n+        and not timed out on subsequent candles after entry trigger.\n+\n+        For full documentation please go to https://www.freqtrade.io/en/latest/strategy-callbacks/\n+\n+        When not implemented by a strategy, returns current_order_rate as default.\n+        If current_order_rate is returned then the existing order is maintained.\n+        If None is returned then order gets canceled but not replaced by a new one.\n+\n+        :param pair: Pair that's currently analyzed\n+        :param trade: Trade object.\n+        :param order: Order object\n+        :param current_time: datetime object, containing the current datetime\n+        :param proposed_rate: Rate, calculated based on pricing settings in entry_pricing.\n+        :param current_order_rate: Rate of the existing order in place.\n+        :param entry_tag: Optional entry_tag (buy_tag) if provided with the buy signal.\n+        :param side: 'long' or 'short' - indicating the direction of the proposed trade\n+        :param is_entry: True if the order is an entry order, False if it's an exit order.\n+        :param **kwargs: Ensure to keep this here so updates to this won't break your strategy.\n+        :return float: New entry price value if provided\n+        \"\"\"\n+        if is_entry:\n+            return self.adjust_entry_price(\n+                trade=trade,\n+                order=order,\n+                pair=pair,\n+                current_time=current_time,\n+                proposed_rate=proposed_rate,\n+                current_order_rate=current_order_rate,\n+                entry_tag=entry_tag,\n+                side=side,\n+                **kwargs,\n+            )\n+        else:\n+            return self.adjust_exit_price(\n+                trade=trade,\n+                order=order,\n+                pair=pair,\n+                current_time=current_time,\n+                proposed_rate=proposed_rate,\n+                current_order_rate=current_order_rate,\n+                entry_tag=entry_tag,\n+                side=side,\n+                **kwargs,\n+            )\n+\n     def leverage(\n         self,\n         pair: str,\ndiff --git a/freqtrade/templates/strategy_subtemplates/strategy_methods_advanced.j2 b/freqtrade/templates/strategy_subtemplates/strategy_methods_advanced.j2\nindex 84d7f40c861..5ff48324371 100644\n--- a/freqtrade/templates/strategy_subtemplates/strategy_methods_advanced.j2\n+++ b/freqtrade/templates/strategy_subtemplates/strategy_methods_advanced.j2\n@@ -40,7 +40,7 @@ def custom_entry_price(\n     \"\"\"\n     return proposed_rate\n \n-def adjust_entry_price(\n+def adjust_order_price(\n     self,\n     trade: Trade,\n     order: Order | None,\n@@ -50,10 +50,11 @@ def adjust_entry_price(\n     current_order_rate: float,\n     entry_tag: str | None,\n     side: str,\n+    is_entry: bool,\n     **kwargs,\n ) -> float:\n     \"\"\"\n-    Entry price re-adjustment logic, returning the user desired limit price.\n+    Exit and entry order price re-adjustment logic, returning the user desired limit price.\n     This only executes when a order was already placed, still open (unfilled fully or partially)\n     and not timed out on subsequent candles after entry trigger.\n \n@@ -71,6 +72,7 @@ def adjust_entry_price(\n     :param current_order_rate: Rate of the existing order in place.\n     :param entry_tag: Optional entry_tag (buy_tag) if provided with the buy signal.\n     :param side: 'long' or 'short' - indicating the direction of the proposed trade\n+    :param is_entry: True if the order is an entry order, False if it's an exit order.\n     :param **kwargs: Ensure to keep this here so updates to this won't break your strategy.\n     :return float: New entry price value if provided\n \n", "test_patch": "diff --git a/freqtrade/optimize/backtesting.py b/freqtrade/optimize/backtesting.py\nindex d3f1bc63bf5..ab3e1459b60 100644\n--- a/freqtrade/optimize/backtesting.py\n+++ b/freqtrade/optimize/backtesting.py\n@@ -396,6 +396,8 @@ def prepare_backtest(self, enable_protections):\n         self.canceled_trade_entries = 0\n         self.canceled_entry_orders = 0\n         self.replaced_entry_orders = 0\n+        self.canceled_exit_orders = 0\n+        self.replaced_exit_orders = 0\n         self.dataprovider.clear_cache()\n         if enable_protections:\n             self._load_protections(self.strategy)\n@@ -1234,8 +1236,8 @@ def cancel_open_orders(self, trade: LocalTrade, current_time: datetime):\n         for order in [o for o in trade.orders if o.ft_is_open]:\n             if order.side == trade.entry_side:\n                 self.canceled_entry_orders += 1\n-            # elif order.side == trade.exit_side:\n-            #     self.canceled_exit_orders += 1\n+            elif order.side == trade.exit_side:\n+                self.canceled_exit_orders += 1\n             # canceled orders are removed from the trade\n             del trade.orders[trade.orders.index(order)]\n \n@@ -1299,9 +1301,10 @@ def check_order_replace(\n         Returns True if the trade should be deleted.\n         \"\"\"\n         # only check on new candles for open entry orders\n-        if order.side == trade.entry_side and current_time > order.order_date_utc:\n+        if current_time > order.order_date_utc:\n+            is_entry = order.side == trade.entry_side\n             requested_rate = strategy_safe_wrapper(\n-                self.strategy.adjust_entry_price, default_retval=order.ft_price\n+                self.strategy.adjust_order_price, default_retval=order.ft_price\n             )(\n                 trade=trade,  # type: ignore[arg-type]\n                 order=order,\n@@ -1311,6 +1314,7 @@ def check_order_replace(\n                 current_order_rate=order.ft_price,\n                 entry_tag=trade.enter_tag,\n                 side=trade.trade_direction,\n+                is_entry=is_entry,\n             )  # default value is current order price\n \n             # cancel existing order whenever a new rate is requested (or None)\n@@ -1319,22 +1323,35 @@ def check_order_replace(\n                 return False\n             else:\n                 del trade.orders[trade.orders.index(order)]\n-                self.canceled_entry_orders += 1\n+                if is_entry:\n+                    self.canceled_entry_orders += 1\n+                else:\n+                    self.canceled_exit_orders += 1\n \n             # place new order if result was not None\n             if requested_rate:\n-                self._enter_trade(\n-                    pair=trade.pair,\n-                    row=row,\n-                    trade=trade,\n-                    requested_rate=requested_rate,\n-                    requested_stake=(order.safe_remaining * order.ft_price / trade.leverage),\n-                    direction=\"short\" if trade.is_short else \"long\",\n-                )\n+                if is_entry:\n+                    self._enter_trade(\n+                        pair=trade.pair,\n+                        row=row,\n+                        trade=trade,\n+                        requested_rate=requested_rate,\n+                        requested_stake=(order.safe_remaining * order.ft_price / trade.leverage),\n+                        direction=\"short\" if trade.is_short else \"long\",\n+                    )\n+                    self.replaced_entry_orders += 1\n+                else:\n+                    self._exit_trade(\n+                        trade=trade,\n+                        sell_row=row,\n+                        close_rate=requested_rate,\n+                        amount=order.safe_remaining,\n+                        exit_reason=order.ft_order_tag,\n+                    )\n+                    self.replaced_exit_orders += 1\n                 # Delete trade if no successful entries happened (if placing the new order failed)\n-                if not trade.has_open_orders and trade.nr_of_successful_entries == 0:\n+                if not trade.has_open_orders and is_entry and trade.nr_of_successful_entries == 0:\n                     return True\n-                self.replaced_entry_orders += 1\n             else:\n                 # assumption: there can't be multiple open entry orders at any given time\n                 return trade.nr_of_successful_entries == 0\ndiff --git a/tests/freqtradebot/test_integration.py b/tests/freqtradebot/test_integration.py\nindex 9fc5807534f..2cb4b6aa8df 100644\n--- a/tests/freqtradebot/test_integration.py\n+++ b/tests/freqtradebot/test_integration.py\n@@ -436,6 +436,7 @@ def test_dca_order_adjust(default_conf_usdt, ticker_usdt, leverage, fee, mocker)\n \n     # Replace new order with diff. order at a lower price\n     freqtrade.strategy.adjust_entry_price = MagicMock(return_value=1.95)\n+    freqtrade.strategy.adjust_exit_price = MagicMock(side_effect=ValueError)\n     freqtrade.strategy.adjust_trade_position = MagicMock(return_value=None)\n     freqtrade.process()\n     trade = Trade.get_trades().first()\n@@ -445,6 +446,8 @@ def test_dca_order_adjust(default_conf_usdt, ticker_usdt, leverage, fee, mocker)\n     assert pytest.approx(trade.stake_amount) == 60\n     assert trade.orders[-1].price == 1.95\n     assert pytest.approx(trade.orders[-1].cost) == 120 * leverage\n+    assert freqtrade.strategy.adjust_entry_price.call_count == 1\n+    assert freqtrade.strategy.adjust_exit_price.call_count == 0\n \n     # Fill DCA order\n     freqtrade.strategy.adjust_trade_position = MagicMock(return_value=None)\n@@ -469,6 +472,7 @@ def test_dca_order_adjust(default_conf_usdt, ticker_usdt, leverage, fee, mocker)\n     mocker.patch(f\"{EXMS}._dry_is_price_crossed\", return_value=False)\n     freqtrade.strategy.custom_exit = MagicMock(return_value=\"Exit now\")\n     freqtrade.strategy.adjust_entry_price = MagicMock(return_value=2.02)\n+    freqtrade.strategy.adjust_exit_price = MagicMock(side_effect=ValueError)\n     freqtrade.process()\n     trade = Trade.get_trades().first()\n     assert len(trade.orders) == 5\n@@ -478,8 +482,9 @@ def test_dca_order_adjust(default_conf_usdt, ticker_usdt, leverage, fee, mocker)\n     assert pytest.approx(trade.amount) == 91.689215 * leverage\n     assert pytest.approx(trade.orders[-1].amount) == 91.689215 * leverage\n     assert freqtrade.strategy.adjust_entry_price.call_count == 0\n+    assert freqtrade.strategy.adjust_exit_price.call_count == 0\n \n-    # Process again, should not adjust entry price\n+    # Process again, should not adjust price\n     freqtrade.process()\n     trade = Trade.get_trades().first()\n \n@@ -490,6 +495,21 @@ def test_dca_order_adjust(default_conf_usdt, ticker_usdt, leverage, fee, mocker)\n     assert trade.orders[-1].price == 2.02\n     # Adjust entry price cannot be called - this is an exit order\n     assert freqtrade.strategy.adjust_entry_price.call_count == 0\n+    assert freqtrade.strategy.adjust_exit_price.call_count == 1\n+\n+    freqtrade.strategy.adjust_exit_price = MagicMock(return_value=2.03)\n+\n+    # Process again, should adjust exit price\n+    freqtrade.process()\n+    trade = Trade.get_trades().first()\n+\n+    assert trade.orders[-2].status == \"canceled\"\n+    assert len(trade.orders) == 6\n+    assert trade.orders[-1].side == trade.exit_side\n+    assert trade.orders[-1].status == \"open\"\n+    assert trade.orders[-1].price == 2.03\n+    assert freqtrade.strategy.adjust_entry_price.call_count == 0\n+    assert freqtrade.strategy.adjust_exit_price.call_count == 1\n \n \n @pytest.mark.parametrize(\"leverage\", [1, 2])\ndiff --git a/tests/optimize/__init__.py b/tests/optimize/__init__.py\nindex 3299c6a53c4..cdc42956fe0 100644\n--- a/tests/optimize/__init__.py\n+++ b/tests/optimize/__init__.py\n@@ -45,6 +45,7 @@ class BTContainer(NamedTuple):\n     leverage: float = 1.0\n     timeout: int | None = None\n     adjust_entry_price: float | None = None\n+    adjust_exit_price: float | None = None\n     adjust_trade_position: list[float] | None = None\n \n \ndiff --git a/tests/optimize/test_backtest_detail.py b/tests/optimize/test_backtest_detail.py\nindex 7ba53a1b385..736c4dcab34 100644\n--- a/tests/optimize/test_backtest_detail.py\n+++ b/tests/optimize/test_backtest_detail.py\n@@ -1217,6 +1217,46 @@\n     ],\n )\n \n+# Test 58: Custom-exit-price short - below all candles\n+tc58 = BTContainer(\n+    data=[\n+        # D   O     H     L     C    V    EL XL ES Xs  BT\n+        [0, 5000, 5050, 4950, 5000, 6172, 0, 0, 1, 0],\n+        [1, 5000, 5200, 4951, 5000, 6172, 0, 0, 0, 0],  # enter trade (signal on last candle)\n+        [2, 4900, 5250, 4900, 5100, 6172, 0, 0, 0, 1],  # Exit - delayed\n+        [3, 5100, 5100, 4650, 4750, 6172, 0, 0, 0, 0],  #\n+        [4, 4750, 5100, 4350, 4750, 6172, 0, 0, 0, 0],\n+    ],\n+    stop_loss=-0.10,\n+    roi={\"0\": 1.00},\n+    profit_perc=-0.01,\n+    use_exit_signal=True,\n+    timeout=1000,\n+    custom_exit_price=4300,\n+    adjust_exit_price=5050,\n+    trades=[BTrade(exit_reason=ExitType.EXIT_SIGNAL, open_tick=1, close_tick=4, is_short=True)],\n+)\n+\n+# Test 59: Custom-exit-price above all candles - readjust order\n+tc59 = BTContainer(\n+    data=[\n+        # D   O     H     L     C    V    EL XL ES Xs  BT\n+        [0, 5000, 5050, 4950, 5000, 6172, 1, 0],\n+        [1, 5000, 5500, 4951, 5000, 6172, 0, 0],\n+        [2, 4900, 5250, 4500, 5100, 6172, 0, 1],  # exit\n+        [3, 5100, 5100, 4650, 4750, 6172, 0, 0],  # order readjust\n+        [4, 4750, 4950, 4350, 4750, 6172, 0, 0],\n+    ],\n+    stop_loss=-0.2,\n+    roi={\"0\": 0.10},\n+    profit_perc=-0.02,\n+    use_exit_signal=True,\n+    timeout=1000,\n+    custom_exit_price=5300,\n+    adjust_exit_price=4900,\n+    trades=[BTrade(exit_reason=ExitType.EXIT_SIGNAL, open_tick=1, close_tick=4, is_short=False)],\n+)\n+\n \n TESTS = [\n     tc0,\n@@ -1277,6 +1317,8 @@\n     tc55,\n     tc56,\n     tc57,\n+    tc58,\n+    tc59,\n ]\n \n \n@@ -1330,6 +1372,8 @@ def test_backtest_results(default_conf, mocker, caplog, data: BTContainer) -> No\n         )\n     if data.adjust_entry_price:\n         backtesting.strategy.adjust_entry_price = MagicMock(return_value=data.adjust_entry_price)\n+    if data.adjust_exit_price:\n+        backtesting.strategy.adjust_exit_price = MagicMock(return_value=data.adjust_exit_price)\n \n     backtesting.strategy.use_custom_stoploss = data.use_custom_stoploss\n     backtesting.strategy.leverage = lambda **kwargs: data.leverage\ndiff --git a/tests/strategy/strats/broken_strats/broken_futures_strategies.py b/tests/strategy/strats/broken_strats/broken_futures_strategies.py\nindex b2131e63eaf..a3e51bc504a 100644\n--- a/tests/strategy/strats/broken_strats/broken_futures_strategies.py\n+++ b/tests/strategy/strats/broken_strats/broken_futures_strategies.py\n@@ -21,10 +21,12 @@ def populate_entry_trend(self, dataframe: DataFrame, metadata: dict) -> DataFram\n         return super().populate_entry_trend(dataframe, metadata)\n \n \n-class TestStrategyImplementCustomSell(TestStrategyNoImplementSell):\n+class TestStrategyImplementEmptyWorking(TestStrategyNoImplementSell):\n     def populate_exit_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame:\n         return super().populate_exit_trend(dataframe, metadata)\n \n+\n+class TestStrategyImplementCustomSell(TestStrategyImplementEmptyWorking):\n     def custom_sell(\n         self,\n         pair: str,\n@@ -55,3 +57,34 @@ def check_sell_timeout(\n         self, pair: str, trade, order: Order, current_time: datetime, **kwargs\n     ) -> bool:\n         return False\n+\n+\n+class TestStrategyAdjustOrderPrice(TestStrategyImplementEmptyWorking):\n+    def adjust_entry_price(\n+        self,\n+        trade,\n+        order,\n+        pair,\n+        current_time,\n+        proposed_rate,\n+        current_order_rate,\n+        entry_tag,\n+        side,\n+        **kwargs,\n+    ):\n+        return proposed_rate\n+\n+    def adjust_order_price(\n+        self,\n+        trade,\n+        order,\n+        pair,\n+        current_time,\n+        proposed_rate,\n+        current_order_rate,\n+        entry_tag,\n+        side,\n+        is_entry,\n+        **kwargs,\n+    ):\n+        return proposed_rate\ndiff --git a/tests/strategy/test_strategy_loading.py b/tests/strategy/test_strategy_loading.py\nindex 9b143ace616..927f334615a 100644\n--- a/tests/strategy/test_strategy_loading.py\n+++ b/tests/strategy/test_strategy_loading.py\n@@ -460,6 +460,10 @@ def test_missing_implements(default_conf, caplog):\n     ):\n         StrategyResolver.load_strategy(default_conf)\n \n+    default_conf[\"strategy\"] = \"TestStrategyAdjustOrderPrice\"\n+    with pytest.raises(OperationalException, match=r\"If you implement `adjust_order_price`.*\"):\n+        StrategyResolver.load_strategy(default_conf)\n+\n \n def test_call_deprecated_function(default_conf):\n     default_location = Path(__file__).parent / \"strats/broken_strats/\"\n", "problem_statement": "Limitation of replace_order to wait for new candles and inconsistency with exits\n## Describe your environment\n\n  * Operating system: Ubuntu 22.04\n  * Python Version: 3.10.12\n  * CCXT version: 4.4.43\n  * Freqtrade Version: 0866b8fdca8ced1eec0088f3b3a49f515954bff2\n \n## Steps to reproduce\n\nI first noticed this problem while I was investigating why `adjust_entry_price` isn't run immediately every 5 seconds according to `process_throttle_secs` but first it waits for a new candle and _then_ it starts running every 5 seconds (my intend was to see it running every 5 seconds immediately and it being able to replace orders immediately that way).\n\nBut after closer investigation of the code: it appears that `replace_order` is running replacements of orders only every new candle and I haven't figured out why `adjust_entry_price` is run every 5 seconds only after a new candle but it wouldn't matter anyway because the replacement of orders would only happen on a new candle anyway (apparently).\n\n## Expected behavior\n\nI would basically expect that if the user has a `process_throttle_secs` of 5 secs then replacement of limit orders (of either entry or exit) could happen every 5 seconds but apparently the user has to wait for a new candle which might save CPU time or network bandwidth but it unnecessarily lowers the actual responsiveness to the market.\n\n## Inconsistency with exits\n\nIt gets a bit worse than that because this behavior is not the same for exits and `replace_order` is actually restricted to entries so the behavior of the program should obviously be same for limit orders of either entry or exit and `replace_order` should also be renamed to `replace_entry_order` because it doesn't replace exits.\n", "hints_text": "`replace_order()` is not something the strategy defines or implements - but is an internal method. Naming of this doesn't matter from a user perspective.\n\n\nThe method you'll look at is `adjust_entry_price()`, which is part of the interface\nThis user-visible callback is named accordingly.\n\nThe [documentation](https://www.freqtrade.io/en/stable/strategy-callbacks/#adjust-entry-price) is very clear about the frequency this callback is called:\n\n> The adjust_entry_price() callback may be used by strategy developer to refresh/replace limit orders upon arrival of new candles.\n\nDoing a test - behavior is as expected- with the callback being called\n* once every candle if the order is replaced\n* every iteration UNLESS / until the order has been replaced _in this candle_ (so order replacement can happen at max. once per candle) - and will then \"wait\" until the next candle.\n\nI can see the wording in the docs can cause confusion, and will update the documentation to make behavior clear from reading the docs.\n\n\n> It gets a bit worse than that because this behavior is not the same for exits \n\nThis is correct - and as explained in #11171 - this is intentional as having a \"sticking\" exit order is currently a dangerous approach - and not something we'll currently be supporting.\nThere's work to improve behavior overall - but this callback is the least of the problems - and until proper signal handling (even with open orders) is implemented and merged, is not something reasonable.\nI see no reason to bar people from having certain options, because of an opinion on what is risky.\nMost of those risks were in literature that assume extremely low frequency trading.\nIn principle, that's correct, and if you read very carefully, i never said \"this will never be added\" - i said \"it doesn't make sense at this point\".\n", "created_at": "2025-02-20T19:27:32Z"}