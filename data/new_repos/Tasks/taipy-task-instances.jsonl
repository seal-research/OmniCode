{"repo": "Avaiga/taipy", "pull_number": 2464, "instance_id": "Avaiga__taipy-2464", "issue_numbers": ["2126", "2126"], "base_commit": "cf9f976645d883291f73d212528d796699c3ac65", "patch": "diff --git a/taipy/gui/_renderers/_markdown/preproc.py b/taipy/gui/_renderers/_markdown/preproc.py\nindex d819074be..2f5a4f7de 100644\n--- a/taipy/gui/_renderers/_markdown/preproc.py\n+++ b/taipy/gui/_renderers/_markdown/preproc.py\n@@ -61,7 +61,7 @@ class _Preprocessor(MdPreprocessor):\n     __PROPERTY_RE = re.compile(r\"((?:don'?t|not?)\\s+)?([a-zA-Z][\\.a-zA-Z_$0-9]*(?:\\[(?:.*?)\\])?)\\s*(?:=(.*))?$\")\n \n     # Error syntax detection regex\n-    __MISSING_LEADING_PIPE_RE = re.compile(r\"^<[^|](.*?)\\|>\")\n+    __MISSING_LEADING_PIPE_RE = re.compile(r\"^<[^|]([^>]*?)\\|>\")\n \n     _gui: \"Gui\"\n \n", "test_patch": "diff --git a/tests/gui/renderers/test_md_parsing.py b/tests/gui/renderers/test_md_parsing.py\nindex 62877cc34..b5d955646 100644\n--- a/tests/gui/renderers/test_md_parsing.py\n+++ b/tests/gui/renderers/test_md_parsing.py\n@@ -52,3 +52,9 @@ def test_md_link(gui: Gui, helpers):\n     md_string = \"[content](link)\"\n     expected_list = [\"<a\", 'href=\"link\"', \"content</a>\"]\n     helpers.test_control_md(gui, md_string, expected_list)\n+\n+\n+def test_html_in_md(gui: Gui, helpers):\n+    md_string = \"<center> <|Hello|text|> </center>\"\n+    expected_list = [\"<center>\", \"<div\", \"Hello\", \"</div>\", \"</center>\"]\n+    helpers.test_control_md(gui, md_string, expected_list)\n", "problem_statement": "[\ud83d\udc1b BUG] Issue with center tag\n### What went wrong? \ud83e\udd14\r\n\r\nUsing center tags along with visual elements will break the UI.\r\n\r\n```\r\n--- 1 warning(s) were found for page '/' in variable 'md' ---\r\n - Warning 1: Missing leading pipe '|' in opening tag line 2: '<center> <|Hello|text|> </center>'.\r\n--------------------------------------------------------------\r\n```\r\n\r\nThe workaround is to:\r\n\r\n```\r\nmd = \"\"\"\r\n<center> <|Hello|text|> </center>\r\n\"\"\"\r\n```\r\n\r\n->\r\n\r\n```\r\nmd = \"\"\"\r\n<center>\r\n<|Hello|text|>\r\n</center>\r\n\"\"\"\r\n```\r\n\r\n### Expected Behavior\r\n\r\nIt shouldn't break like in 3.1 and should center the viz element. It should be backported.\r\n\r\n### Steps to Reproduce Issue\r\n\r\n```python\r\nfrom taipy import Gui\r\n\r\nmd = \"\"\"\r\n<center> <|Hello|text|> </center>\r\n\"\"\"\r\n\r\nGui(md).run()\r\n```\r\n\r\n### Screenshots\r\n\r\n![image](https://github.com/user-attachments/assets/7b1fe943-e595-4e42-8433-2a634580266f)\r\n\r\n### Version of Taipy\r\n\r\n4.0\r\n\r\n### Acceptance Criteria\r\n\r\n- [ ] A unit test reproducing the bug is added.\r\n- [ ] Any new code is covered by a unit tested.\r\n- [ ] Check code coverage is at least 90%.\r\n- [ ] The bug reporter validated the fix.\r\n- [ ] Related issue(s) in taipy-doc are created for documentation and Release Notes are updated.\r\n\r\n\r\n### Code of Conduct\r\n\r\n- [X] I have checked the [existing issues](https://github.com/Avaiga/taipy/issues?q=is%3Aissue+).\r\n- [ ] I am willing to work on this issue (optional)\n[\ud83d\udc1b BUG] Issue with center tag\n### What went wrong? \ud83e\udd14\r\n\r\nUsing center tags along with visual elements will break the UI.\r\n\r\n```\r\n--- 1 warning(s) were found for page '/' in variable 'md' ---\r\n - Warning 1: Missing leading pipe '|' in opening tag line 2: '<center> <|Hello|text|> </center>'.\r\n--------------------------------------------------------------\r\n```\r\n\r\nThe workaround is to:\r\n\r\n```\r\nmd = \"\"\"\r\n<center> <|Hello|text|> </center>\r\n\"\"\"\r\n```\r\n\r\n->\r\n\r\n```\r\nmd = \"\"\"\r\n<center>\r\n<|Hello|text|>\r\n</center>\r\n\"\"\"\r\n```\r\n\r\n### Expected Behavior\r\n\r\nIt shouldn't break like in 3.1 and should center the viz element. It should be backported.\r\n\r\n### Steps to Reproduce Issue\r\n\r\n```python\r\nfrom taipy import Gui\r\n\r\nmd = \"\"\"\r\n<center> <|Hello|text|> </center>\r\n\"\"\"\r\n\r\nGui(md).run()\r\n```\r\n\r\n### Screenshots\r\n\r\n![image](https://github.com/user-attachments/assets/7b1fe943-e595-4e42-8433-2a634580266f)\r\n\r\n### Version of Taipy\r\n\r\n4.0\r\n\r\n### Acceptance Criteria\r\n\r\n- [ ] A unit test reproducing the bug is added.\r\n- [ ] Any new code is covered by a unit tested.\r\n- [ ] Check code coverage is at least 90%.\r\n- [ ] The bug reporter validated the fix.\r\n- [ ] Related issue(s) in taipy-doc are created for documentation and Release Notes are updated.\r\n\r\n\r\n### Code of Conduct\r\n\r\n- [X] I have checked the [existing issues](https://github.com/Avaiga/taipy/issues?q=is%3Aissue+).\r\n- [ ] I am willing to work on this issue (optional)\n", "hints_text": "Hello @FlorianJacta \r\nI am sorry the screenshot is not visible.\nIt is @naaa760 . This is the screenshot; there is nothing when there should be something\nThIs looks like a markdown parsing issue and not a center tag issue.\n@FlorianJacta \n\nfrom taipy import Gui\n\nmd = \"\"\"\n<center>\n<|Hello|text|>\n</center>\n\"\"\"\n\nGui(md).run()\n\nTry this\n[center tag is not supported in HTML5](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/center)\n\nbut I'll look into it\nHello @FlorianJacta \r\nI am sorry the screenshot is not visible.\nIt is @naaa760 . This is the screenshot; there is nothing when there should be something\nThIs looks like a markdown parsing issue and not a center tag issue.\n@FlorianJacta \n\nfrom taipy import Gui\n\nmd = \"\"\"\n<center>\n<|Hello|text|>\n</center>\n\"\"\"\n\nGui(md).run()\n\nTry this\n[center tag is not supported in HTML5](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/center)\n\nbut I'll look into it", "created_at": "2025-02-27T10:37:38Z"}
{"repo": "Avaiga/taipy", "pull_number": 2452, "instance_id": "Avaiga__taipy-2452", "issue_numbers": ["2344", "2344"], "base_commit": "acb9826c15d8377a2ade1115ccf4a54ea50fbcbd", "patch": "diff --git a/frontend/taipy-gui/src/context/taipyReducers.ts b/frontend/taipy-gui/src/context/taipyReducers.ts\nindex b0ac7c2574..885cee0f4f 100644\n--- a/frontend/taipy-gui/src/context/taipyReducers.ts\n+++ b/frontend/taipy-gui/src/context/taipyReducers.ts\n@@ -24,7 +24,7 @@ import { getBaseURL, TIMEZONE_CLIENT } from \"../utils\";\n import { parseData } from \"../utils/dataFormat\";\n import { MenuProps } from \"../utils/lov\";\n import { changeFavicon, getLocalStorageValue, IdMessage, storeClientId } from \"./utils\";\n-import { lightenPayload, sendWsMessage, TAIPY_CLIENT_ID, WsMessage } from \"./wsUtils\";\n+import { lightenPayload, sendWsMessage, TAIPY_APP_ID, TAIPY_CLIENT_ID, WsMessage } from \"./wsUtils\";\n \n export enum Types {\n     SocketConnected = \"SOCKET_CONNECTED\",\n@@ -181,7 +181,7 @@ const getUserTheme = (mode: PaletteMode) => {\n                     },\n                 },\n             },\n-        }),\n+        })\n     );\n };\n \n@@ -226,7 +226,7 @@ export const messageToAction = (message: WsMessage) => {\n                 (message as unknown as NavigateMessage).to,\n                 (message as unknown as NavigateMessage).params,\n                 (message as unknown as NavigateMessage).tab,\n-                (message as unknown as NavigateMessage).force,\n+                (message as unknown as NavigateMessage).force\n             );\n         } else if (message.type === \"ID\") {\n             return createIdAction((message as unknown as IdMessage).id);\n@@ -240,6 +240,8 @@ export const messageToAction = (message: WsMessage) => {\n             changeFavicon((message.payload as Record<string, string>)?.value);\n         } else if (message.type == \"BC\") {\n             stackBroadcast((message as NamePayload).name, (message as NamePayload).payload.value);\n+        } else if (message.type == \"AID\") {\n+            checkAppId((message.payload as Record<string, string>).id);\n         }\n     }\n     return {} as TaipyBaseAction;\n@@ -284,24 +286,46 @@ const initializeBroadcastManagement = (dispatch: Dispatch<TaipyBaseAction>) => {\n     }, broadcast_timeout);\n };\n \n+// App id\n+const checkAppId = (appId: string) => {\n+    if (!appId) {\n+        return;\n+    }\n+    appId = `${appId}`;\n+    const localAppId = getLocalStorageValue(TAIPY_APP_ID, \"\");\n+    if (!localAppId || localAppId !== appId) {\n+        localStorage && localStorage.setItem(TAIPY_APP_ID, appId);\n+        localAppId && window.location.assign(getBaseURL());\n+    }\n+};\n+\n+let lastReasonServer = false;\n+\n+// web socket\n export const initializeWebSocket = (socket: Socket | undefined, dispatch: Dispatch<TaipyBaseAction>): void => {\n     if (socket) {\n         // Websocket confirm successful initialization\n         socket.on(\"connect\", () => {\n             const id = getLocalStorageValue(TAIPY_CLIENT_ID, \"\");\n-            sendWsMessage(socket, \"ID\", TAIPY_CLIENT_ID, id, id, undefined, false, () => {\n+            const payload: Record<string, unknown> = { id };\n+            if (lastReasonServer) {\n+                payload[\"app_id\"] = Number(getLocalStorageValue(TAIPY_APP_ID, \"\"));\n+            }\n+            sendWsMessage(socket, \"ID\", TAIPY_CLIENT_ID, payload, id, undefined, false, () => {\n                 dispatch({ type: Types.SocketConnected });\n             });\n         });\n         // try to reconnect on connect_error\n-        socket.on(\"connect_error\", () => {\n-            setTimeout(() => {\n-                socket.connect();\n-            }, 500);\n+        socket.on(\"connect_error\", (error) => {\n+            if ((error as unknown as Record<string, unknown>).type === \"TransportError\") {\n+                lastReasonServer = true;\n+            }\n+            setTimeout(() => socket.connect(), 500);\n         });\n         // try to reconnect on server disconnection\n         socket.on(\"disconnect\", (reason) => {\n             if (reason === \"io server disconnect\") {\n+                lastReasonServer = true;\n                 socket.connect();\n             }\n         });\n@@ -395,7 +419,9 @@ export const taipyReducer = (state: TaipyState, baseAction: TaipyBaseAction): Ta\n             const deleteNotificationAction = action as unknown as TaipyNotificationAction;\n             return {\n                 ...state,\n-                notifications: state.notifications.filter(notification => notification.notificationId !== deleteNotificationAction.notificationId),\n+                notifications: state.notifications.filter(\n+                    (notification) => notification.notificationId !== deleteNotificationAction.notificationId\n+                ),\n             };\n         case Types.SetBlock:\n             const blockAction = action as unknown as TaipyBlockAction;\n@@ -497,7 +523,7 @@ export const taipyReducer = (state: TaipyState, baseAction: TaipyBaseAction): Ta\n                 action.payload,\n                 state.id,\n                 action.context,\n-                action.propagate,\n+                action.propagate\n             );\n             break;\n         case Types.Action:\n@@ -550,7 +576,7 @@ export const createSendUpdateAction = (\n     context: string | undefined,\n     onChange?: string,\n     propagate = true,\n-    relName?: string,\n+    relName?: string\n ): TaipyAction => ({\n     type: Types.SendUpdate,\n     name: name,\n@@ -603,7 +629,7 @@ export const createRequestChartUpdateAction = (\n     context: string | undefined,\n     columns: string[],\n     pageKey: string,\n-    decimatorPayload: unknown | undefined,\n+    decimatorPayload: unknown | undefined\n ): TaipyAction =>\n     createRequestDataUpdateAction(\n         name,\n@@ -614,7 +640,7 @@ export const createRequestChartUpdateAction = (\n         {\n             decimatorPayload: decimatorPayload,\n         },\n-        true,\n+        true\n     );\n \n export const createRequestTableUpdateAction = (\n@@ -636,7 +662,7 @@ export const createRequestTableUpdateAction = (\n     filters?: Array<FilterDesc>,\n     compare?: string,\n     compareDatas?: string,\n-    stateContext?: Record<string, unknown>,\n+    stateContext?: Record<string, unknown>\n ): TaipyAction =>\n     createRequestDataUpdateAction(\n         name,\n@@ -659,7 +685,7 @@ export const createRequestTableUpdateAction = (\n             compare,\n             compare_datas: compareDatas,\n             state_context: stateContext,\n-        }),\n+        })\n     );\n \n export const createRequestInfiniteTableUpdateAction = (\n@@ -682,7 +708,7 @@ export const createRequestInfiniteTableUpdateAction = (\n     compare?: string,\n     compareDatas?: string,\n     stateContext?: Record<string, unknown>,\n-    reverse?: boolean,\n+    reverse?: boolean\n ): TaipyAction =>\n     createRequestDataUpdateAction(\n         name,\n@@ -707,7 +733,7 @@ export const createRequestInfiniteTableUpdateAction = (\n             compare_datas: compareDatas,\n             state_context: stateContext,\n             reverse: !!reverse,\n-        }),\n+        })\n     );\n \n /**\n@@ -738,7 +764,7 @@ export const createRequestDataUpdateAction = (\n     pageKey: string,\n     payload: Record<string, unknown>,\n     allData = false,\n-    library?: string,\n+    library?: string\n ): TaipyAction => {\n     payload = payload || {};\n     if (id !== undefined) {\n@@ -776,7 +802,7 @@ export const createRequestUpdateAction = (\n     context: string | undefined,\n     names: string[],\n     forceRefresh = false,\n-    stateContext?: Record<string, unknown>,\n+    stateContext?: Record<string, unknown>\n ): TaipyAction => ({\n     type: Types.RequestUpdate,\n     name: \"\",\n@@ -851,7 +877,7 @@ export const createNavigateAction = (\n     to?: string,\n     params?: Record<string, string>,\n     tab?: string,\n-    force?: boolean,\n+    force?: boolean\n ): TaipyNavigateAction => ({\n     type: Types.Navigate,\n     to,\ndiff --git a/frontend/taipy-gui/src/context/wsUtils.ts b/frontend/taipy-gui/src/context/wsUtils.ts\nindex fc1cc35b0c..a6d28b4911 100644\n--- a/frontend/taipy-gui/src/context/wsUtils.ts\n+++ b/frontend/taipy-gui/src/context/wsUtils.ts\n@@ -2,6 +2,7 @@ import { Socket } from \"socket.io-client\";\n import { nanoid } from 'nanoid'\n \n export const TAIPY_CLIENT_ID = \"TaipyClientId\";\n+export const TAIPY_APP_ID = \"TaipyAppId\";\n \n export type WsMessageType =\n     | \"A\"\ndiff --git a/frontend/taipy/package-lock.json b/frontend/taipy/package-lock.json\nindex 7009e46d6d..f7c29ed2ff 100644\n--- a/frontend/taipy/package-lock.json\n+++ b/frontend/taipy/package-lock.json\n@@ -94,22 +94,21 @@\n       }\n     },\n     \"node_modules/@babel/core\": {\n-      \"version\": \"7.26.8\",\n-      \"resolved\": \"https://registry.npmjs.org/@babel/core/-/core-7.26.8.tgz\",\n-      \"integrity\": \"sha512-l+lkXCHS6tQEc5oUpK28xBOZ6+HwaH7YwoYQbLFiYb4nS2/l1tKnZEtEWkD0GuiYdvArf9qBS0XlQGXzPMsNqQ==\",\n+      \"version\": \"7.26.9\",\n+      \"resolved\": \"https://registry.npmjs.org/@babel/core/-/core-7.26.9.tgz\",\n+      \"integrity\": \"sha512-lWBYIrF7qK5+GjY5Uy+/hEgp8OJWOD/rpy74GplYRhEauvbHDeFB8t5hPOZxCZ0Oxf4Cc36tK51/l3ymJysrKw==\",\n       \"dev\": true,\n       \"dependencies\": {\n         \"@ampproject/remapping\": \"^2.2.0\",\n         \"@babel/code-frame\": \"^7.26.2\",\n-        \"@babel/generator\": \"^7.26.8\",\n+        \"@babel/generator\": \"^7.26.9\",\n         \"@babel/helper-compilation-targets\": \"^7.26.5\",\n         \"@babel/helper-module-transforms\": \"^7.26.0\",\n-        \"@babel/helpers\": \"^7.26.7\",\n-        \"@babel/parser\": \"^7.26.8\",\n-        \"@babel/template\": \"^7.26.8\",\n-        \"@babel/traverse\": \"^7.26.8\",\n-        \"@babel/types\": \"^7.26.8\",\n-        \"@types/gensync\": \"^1.0.0\",\n+        \"@babel/helpers\": \"^7.26.9\",\n+        \"@babel/parser\": \"^7.26.9\",\n+        \"@babel/template\": \"^7.26.9\",\n+        \"@babel/traverse\": \"^7.26.9\",\n+        \"@babel/types\": \"^7.26.9\",\n         \"convert-source-map\": \"^2.0.0\",\n         \"debug\": \"^4.1.0\",\n         \"gensync\": \"^1.0.0-beta.2\",\n@@ -140,12 +139,12 @@\n       }\n     },\n     \"node_modules/@babel/generator\": {\n-      \"version\": \"7.26.8\",\n-      \"resolved\": \"https://registry.npmjs.org/@babel/generator/-/generator-7.26.8.tgz\",\n-      \"integrity\": \"sha512-ef383X5++iZHWAXX0SXQR6ZyQhw/0KtTkrTz61WXRhFM6dhpHulO/RJz79L8S6ugZHJkOOkUrUdxgdF2YiPFnA==\",\n+      \"version\": \"7.26.9\",\n+      \"resolved\": \"https://registry.npmjs.org/@babel/generator/-/generator-7.26.9.tgz\",\n+      \"integrity\": \"sha512-kEWdzjOAUMW4hAyrzJ0ZaTOu9OmpyDIQicIh0zg0EEcEkYXZb2TjtBhnHi2ViX7PKwZqF4xwqfAm299/QMP3lg==\",\n       \"dependencies\": {\n-        \"@babel/parser\": \"^7.26.8\",\n-        \"@babel/types\": \"^7.26.8\",\n+        \"@babel/parser\": \"^7.26.9\",\n+        \"@babel/types\": \"^7.26.9\",\n         \"@jridgewell/gen-mapping\": \"^0.3.5\",\n         \"@jridgewell/trace-mapping\": \"^0.3.25\",\n         \"jsesc\": \"^3.0.2\"\n@@ -243,24 +242,24 @@\n       }\n     },\n     \"node_modules/@babel/helpers\": {\n-      \"version\": \"7.26.7\",\n-      \"resolved\": \"https://registry.npmjs.org/@babel/helpers/-/helpers-7.26.7.tgz\",\n-      \"integrity\": \"sha512-8NHiL98vsi0mbPQmYAGWwfcFaOy4j2HY49fXJCfuDcdE7fMIsH9a7GdaeXpIBsbT7307WU8KCMp5pUVDNL4f9A==\",\n+      \"version\": \"7.26.9\",\n+      \"resolved\": \"https://registry.npmjs.org/@babel/helpers/-/helpers-7.26.9.tgz\",\n+      \"integrity\": \"sha512-Mz/4+y8udxBKdmzt/UjPACs4G3j5SshJJEFFKxlCGPydG4JAHXxjWjAwjd09tf6oINvl1VfMJo+nB7H2YKQ0dA==\",\n       \"dev\": true,\n       \"dependencies\": {\n-        \"@babel/template\": \"^7.25.9\",\n-        \"@babel/types\": \"^7.26.7\"\n+        \"@babel/template\": \"^7.26.9\",\n+        \"@babel/types\": \"^7.26.9\"\n       },\n       \"engines\": {\n         \"node\": \">=6.9.0\"\n       }\n     },\n     \"node_modules/@babel/parser\": {\n-      \"version\": \"7.26.8\",\n-      \"resolved\": \"https://registry.npmjs.org/@babel/parser/-/parser-7.26.8.tgz\",\n-      \"integrity\": \"sha512-TZIQ25pkSoaKEYYaHbbxkfL36GNsQ6iFiBbeuzAkLnXayKR1yP1zFe+NxuZWWsUyvt8icPU9CCq0sgWGXR1GEw==\",\n+      \"version\": \"7.26.9\",\n+      \"resolved\": \"https://registry.npmjs.org/@babel/parser/-/parser-7.26.9.tgz\",\n+      \"integrity\": \"sha512-81NWa1njQblgZbQHxWHpxxCzNsa3ZwvFqpUg7P+NNUU6f3UU2jBEg4OlF/J6rl8+PQGh1q6/zWScd001YwcA5A==\",\n       \"dependencies\": {\n-        \"@babel/types\": \"^7.26.8\"\n+        \"@babel/types\": \"^7.26.9\"\n       },\n       \"bin\": {\n         \"parser\": \"bin/babel-parser.js\"\n@@ -492,9 +491,9 @@\n       }\n     },\n     \"node_modules/@babel/runtime\": {\n-      \"version\": \"7.26.7\",\n-      \"resolved\": \"https://registry.npmjs.org/@babel/runtime/-/runtime-7.26.7.tgz\",\n-      \"integrity\": \"sha512-AOPI3D+a8dXnja+iwsUqGRjr1BbZIe771sXdapOtYI531gSqpi92vXivKcq2asu/DFpdl1ceFAKZyRzK2PCVcQ==\",\n+      \"version\": \"7.26.9\",\n+      \"resolved\": \"https://registry.npmjs.org/@babel/runtime/-/runtime-7.26.9.tgz\",\n+      \"integrity\": \"sha512-aA63XwOkcl4xxQa3HjPMqOP6LiK0ZDv3mUPYEFXkpHbaFjtGggE1A61FjFzJnB+p7/oy2gA8E+rcBNl/zC1tMg==\",\n       \"dependencies\": {\n         \"regenerator-runtime\": \"^0.14.0\"\n       },\n@@ -503,28 +502,28 @@\n       }\n     },\n     \"node_modules/@babel/template\": {\n-      \"version\": \"7.26.8\",\n-      \"resolved\": \"https://registry.npmjs.org/@babel/template/-/template-7.26.8.tgz\",\n-      \"integrity\": \"sha512-iNKaX3ZebKIsCvJ+0jd6embf+Aulaa3vNBqZ41kM7iTWjx5qzWKXGHiJUW3+nTpQ18SG11hdF8OAzKrpXkb96Q==\",\n+      \"version\": \"7.26.9\",\n+      \"resolved\": \"https://registry.npmjs.org/@babel/template/-/template-7.26.9.tgz\",\n+      \"integrity\": \"sha512-qyRplbeIpNZhmzOysF/wFMuP9sctmh2cFzRAZOn1YapxBsE1i9bJIY586R/WBLfLcmcBlM8ROBiQURnnNy+zfA==\",\n       \"dependencies\": {\n         \"@babel/code-frame\": \"^7.26.2\",\n-        \"@babel/parser\": \"^7.26.8\",\n-        \"@babel/types\": \"^7.26.8\"\n+        \"@babel/parser\": \"^7.26.9\",\n+        \"@babel/types\": \"^7.26.9\"\n       },\n       \"engines\": {\n         \"node\": \">=6.9.0\"\n       }\n     },\n     \"node_modules/@babel/traverse\": {\n-      \"version\": \"7.26.8\",\n-      \"resolved\": \"https://registry.npmjs.org/@babel/traverse/-/traverse-7.26.8.tgz\",\n-      \"integrity\": \"sha512-nic9tRkjYH0oB2dzr/JoGIm+4Q6SuYeLEiIiZDwBscRMYFJ+tMAz98fuel9ZnbXViA2I0HVSSRRK8DW5fjXStA==\",\n+      \"version\": \"7.26.9\",\n+      \"resolved\": \"https://registry.npmjs.org/@babel/traverse/-/traverse-7.26.9.tgz\",\n+      \"integrity\": \"sha512-ZYW7L+pL8ahU5fXmNbPF+iZFHCv5scFak7MZ9bwaRPLUhHh7QQEMjZUg0HevihoqCM5iSYHN61EyCoZvqC+bxg==\",\n       \"dependencies\": {\n         \"@babel/code-frame\": \"^7.26.2\",\n-        \"@babel/generator\": \"^7.26.8\",\n-        \"@babel/parser\": \"^7.26.8\",\n-        \"@babel/template\": \"^7.26.8\",\n-        \"@babel/types\": \"^7.26.8\",\n+        \"@babel/generator\": \"^7.26.9\",\n+        \"@babel/parser\": \"^7.26.9\",\n+        \"@babel/template\": \"^7.26.9\",\n+        \"@babel/types\": \"^7.26.9\",\n         \"debug\": \"^4.3.1\",\n         \"globals\": \"^11.1.0\"\n       },\n@@ -533,9 +532,9 @@\n       }\n     },\n     \"node_modules/@babel/types\": {\n-      \"version\": \"7.26.8\",\n-      \"resolved\": \"https://registry.npmjs.org/@babel/types/-/types-7.26.8.tgz\",\n-      \"integrity\": \"sha512-eUuWapzEGWFEpHFxgEaBG8e3n6S8L3MSu0oda755rOfabWPnh0Our1AozNFVUxGFIhbKgd1ksprsoDGMinTOTA==\",\n+      \"version\": \"7.26.9\",\n+      \"resolved\": \"https://registry.npmjs.org/@babel/types/-/types-7.26.9.tgz\",\n+      \"integrity\": \"sha512-Y3IR1cRnOxOCDvMmNiym7XpXQ93iGDDPHx+Zj+NM+rg0fBaShfQLkg+hKPaZCEvg5N/LeCo4+Rj/i3FuJsIQaw==\",\n       \"dependencies\": {\n         \"@babel/helper-string-parser\": \"^7.25.9\",\n         \"@babel/helper-validator-identifier\": \"^7.25.9\"\n@@ -2129,12 +2128,6 @@\n       \"integrity\": \"sha512-AYnb1nQyY49te+VRAVgmzfcgjYS91mY5P0TKUDCLEM+gNnA+3T6rWITXRLYCpahpqSQbN5cE+gHpnPyXjHWxcw==\",\n       \"dev\": true\n     },\n-    \"node_modules/@types/gensync\": {\n-      \"version\": \"1.0.4\",\n-      \"resolved\": \"https://registry.npmjs.org/@types/gensync/-/gensync-1.0.4.tgz\",\n-      \"integrity\": \"sha512-C3YYeRQWp2fmq9OryX+FoDy8nXS6scQ7dPptD8LnFDAUNcKWJjXQKDNJD3HVm+kOUsXhTOkpi69vI4EuAr95bA==\",\n-      \"dev\": true\n-    },\n     \"node_modules/@types/graceful-fs\": {\n       \"version\": \"4.1.9\",\n       \"resolved\": \"https://registry.npmjs.org/@types/graceful-fs/-/graceful-fs-4.1.9.tgz\",\n@@ -2237,9 +2230,9 @@\n       \"dev\": true\n     },\n     \"node_modules/@types/node\": {\n-      \"version\": \"22.13.2\",\n-      \"resolved\": \"https://registry.npmjs.org/@types/node/-/node-22.13.2.tgz\",\n-      \"integrity\": \"sha512-Z+r8y3XL9ZpI2EY52YYygAFmo2/oWfNSj4BCpAXE2McAexDk8VcnBMGC9Djn9gTKt4d2T/hhXqmPzo4hfIXtTg==\",\n+      \"version\": \"22.13.4\",\n+      \"resolved\": \"https://registry.npmjs.org/@types/node/-/node-22.13.4.tgz\",\n+      \"integrity\": \"sha512-ywP2X0DYtX3y08eFVx5fNIw7/uIv8hYUKgXoK8oayJlLnKcRfEYCxWMVE1XagUdVtCJlZT1AU4LXEABW+L1Peg==\",\n       \"dev\": true,\n       \"dependencies\": {\n         \"undici-types\": \"~6.20.0\"\n@@ -2802,15 +2795,6 @@\n       \"integrity\": \"sha512-NM8/P9n3XjXhIZn1lLhkFaACTOURQXjWhV4BA/RnOv8xvgqtqpAX9IO4mRQxSx1Rlo4tqzeqb0sOlruaOy3dug==\",\n       \"dev\": true\n     },\n-    \"node_modules/ajv-keywords\": {\n-      \"version\": \"3.5.2\",\n-      \"resolved\": \"https://registry.npmjs.org/ajv-keywords/-/ajv-keywords-3.5.2.tgz\",\n-      \"integrity\": \"sha512-5p6WTN0DdTGVQk6VjcEju19IgaHudalcfabD7yhDGeA6bcQnmL+CpveLJq/3hvfwd1aof6L386Ougkx6RfyMIQ==\",\n-      \"dev\": true,\n-      \"peerDependencies\": {\n-        \"ajv\": \"^6.9.1\"\n-      }\n-    },\n     \"node_modules/ansi-escapes\": {\n       \"version\": \"4.3.2\",\n       \"resolved\": \"https://registry.npmjs.org/ansi-escapes/-/ansi-escapes-4.3.2.tgz\",\n@@ -3327,9 +3311,9 @@\n       }\n     },\n     \"node_modules/caniuse-lite\": {\n-      \"version\": \"1.0.30001699\",\n-      \"resolved\": \"https://registry.npmjs.org/caniuse-lite/-/caniuse-lite-1.0.30001699.tgz\",\n-      \"integrity\": \"sha512-b+uH5BakXZ9Do9iK+CkDmctUSEqZl+SP056vc5usa0PL+ev5OHw003rZXcnjNDv3L8P5j6rwT6C0BPKSikW08w==\",\n+      \"version\": \"1.0.30001700\",\n+      \"resolved\": \"https://registry.npmjs.org/caniuse-lite/-/caniuse-lite-1.0.30001700.tgz\",\n+      \"integrity\": \"sha512-2S6XIXwaE7K7erT8dY+kLQcpa5ms63XlRkMkReXjle+kf6c5g38vyMl+Z5y8dSxOFDhcFe+nxnn261PLxBSQsQ==\",\n       \"dev\": true,\n       \"funding\": [\n         {\n@@ -3909,9 +3893,9 @@\n       }\n     },\n     \"node_modules/electron-to-chromium\": {\n-      \"version\": \"1.5.98\",\n-      \"resolved\": \"https://registry.npmjs.org/electron-to-chromium/-/electron-to-chromium-1.5.98.tgz\",\n-      \"integrity\": \"sha512-bI/LbtRBxU2GzK7KK5xxFd2y9Lf9XguHooPYbcXWy6wUoT8NMnffsvRhPmSeUHLSDKAEtKuTaEtK4Ms15zkIEA==\",\n+      \"version\": \"1.5.101\",\n+      \"resolved\": \"https://registry.npmjs.org/electron-to-chromium/-/electron-to-chromium-1.5.101.tgz\",\n+      \"integrity\": \"sha512-L0ISiQrP/56Acgu4/i/kfPwWSgrzYZUnQrC0+QPFuhqlLP1Ir7qzPPDVS9BcKIyWTRU8+o6CC8dKw38tSWhYIA==\",\n       \"dev\": true\n     },\n     \"node_modules/emittery\": {\n@@ -4786,13 +4770,14 @@\n       }\n     },\n     \"node_modules/form-data\": {\n-      \"version\": \"4.0.1\",\n-      \"resolved\": \"https://registry.npmjs.org/form-data/-/form-data-4.0.1.tgz\",\n-      \"integrity\": \"sha512-tzN8e4TX8+kkxGPK8D5u0FNmjPUjw3lwC9lSLxxoB/+GtsJG91CO8bSWy73APlgAZzZbXEYZJuxjkHH2w+Ezhw==\",\n+      \"version\": \"4.0.2\",\n+      \"resolved\": \"https://registry.npmjs.org/form-data/-/form-data-4.0.2.tgz\",\n+      \"integrity\": \"sha512-hGfm/slu0ZabnNt4oaRZ6uREyfCj6P4fT/n6A1rGV+Z0VdGXjfOhVUpkn6qVQONHGIFwmveGXyDs75+nr6FM8w==\",\n       \"dev\": true,\n       \"dependencies\": {\n         \"asynckit\": \"^0.4.0\",\n         \"combined-stream\": \"^1.0.8\",\n+        \"es-set-tostringtag\": \"^2.1.0\",\n         \"mime-types\": \"^2.1.12\"\n       },\n       \"engines\": {\n@@ -9187,9 +9172,9 @@\n       }\n     },\n     \"node_modules/webpack\": {\n-      \"version\": \"5.97.1\",\n-      \"resolved\": \"https://registry.npmjs.org/webpack/-/webpack-5.97.1.tgz\",\n-      \"integrity\": \"sha512-EksG6gFY3L1eFMROS/7Wzgrii5mBAFe4rIr3r2BTfo7bcc+DWwFZ4OJ/miOuHJO/A85HwyI4eQ0F6IKXesO7Fg==\",\n+      \"version\": \"5.98.0\",\n+      \"resolved\": \"https://registry.npmjs.org/webpack/-/webpack-5.98.0.tgz\",\n+      \"integrity\": \"sha512-UFynvx+gM44Gv9qFgj0acCQK2VE1CtdfwFdimkapco3hlPCJ/zeq73n2yVKimVbtm+TnApIugGhLJnkU6gjYXA==\",\n       \"dev\": true,\n       \"dependencies\": {\n         \"@types/eslint-scope\": \"^3.7.7\",\n@@ -9210,9 +9195,9 @@\n         \"loader-runner\": \"^4.2.0\",\n         \"mime-types\": \"^2.1.27\",\n         \"neo-async\": \"^2.6.2\",\n-        \"schema-utils\": \"^3.2.0\",\n+        \"schema-utils\": \"^4.3.0\",\n         \"tapable\": \"^2.1.1\",\n-        \"terser-webpack-plugin\": \"^5.3.10\",\n+        \"terser-webpack-plugin\": \"^5.3.11\",\n         \"watchpack\": \"^2.4.1\",\n         \"webpack-sources\": \"^3.2.3\"\n       },\n@@ -9328,24 +9313,6 @@\n         \"node\": \">=4.0\"\n       }\n     },\n-    \"node_modules/webpack/node_modules/schema-utils\": {\n-      \"version\": \"3.3.0\",\n-      \"resolved\": \"https://registry.npmjs.org/schema-utils/-/schema-utils-3.3.0.tgz\",\n-      \"integrity\": \"sha512-pN/yOAvcC+5rQ5nERGuwrjLlYvLTbCibnZ1I7B1LaiAz9BRBlE9GMgE/eqV30P7aJQUf7Ddimy/RsbYO/GrVGg==\",\n-      \"dev\": true,\n-      \"dependencies\": {\n-        \"@types/json-schema\": \"^7.0.8\",\n-        \"ajv\": \"^6.12.5\",\n-        \"ajv-keywords\": \"^3.5.2\"\n-      },\n-      \"engines\": {\n-        \"node\": \">= 10.13.0\"\n-      },\n-      \"funding\": {\n-        \"type\": \"opencollective\",\n-        \"url\": \"https://opencollective.com/webpack\"\n-      }\n-    },\n     \"node_modules/whatwg-encoding\": {\n       \"version\": \"2.0.0\",\n       \"resolved\": \"https://registry.npmjs.org/whatwg-encoding/-/whatwg-encoding-2.0.0.tgz\",\ndiff --git a/taipy/gui/_default_config.py b/taipy/gui/_default_config.py\nindex 94660a338a..913c4b8e44 100644\n--- a/taipy/gui/_default_config.py\n+++ b/taipy/gui/_default_config.py\n@@ -42,6 +42,7 @@\n # Default config loaded by app.py\n default_config: Config = {\n     \"allow_unsafe_werkzeug\": False,\n+    \"app_id\": False,\n     \"async_mode\": \"gevent\",\n     \"change_delay\": None,\n     \"chart_dark_template\": None,\ndiff --git a/taipy/gui/config.py b/taipy/gui/config.py\nindex 5cef23968a..b82fa5d96b 100644\n--- a/taipy/gui/config.py\n+++ b/taipy/gui/config.py\n@@ -30,6 +30,7 @@\n \n ConfigParameter = t.Literal[\n     \"allow_unsafe_werkzeug\",\n+    \"app_id\",\n     \"async_mode\",\n     \"change_delay\",\n     \"chart_dark_template\",\n@@ -104,6 +105,7 @@\n     \"Config\",\n     {\n         \"allow_unsafe_werkzeug\": bool,\n+        \"app_id\": t.Optional[bool],\n         \"async_mode\": str,\n         \"change_delay\": t.Optional[int],\n         \"chart_dark_template\": t.Optional[t.Dict[str, t.Any]],\ndiff --git a/taipy/gui/data/data_scope.py b/taipy/gui/data/data_scope.py\nindex 53ee6fcac1..e039881097 100644\n--- a/taipy/gui/data/data_scope.py\n+++ b/taipy/gui/data/data_scope.py\n@@ -14,6 +14,8 @@\n import typing as t\n from types import SimpleNamespace\n \n+from taipy.common.logger._taipy_logger import _TaipyLogger\n+\n from .._warnings import _warn\n \n if t.TYPE_CHECKING:\n@@ -56,7 +58,7 @@ def get_scope(self, client_id: t.Optional[str]) -> t.Tuple[SimpleNamespace, t.Di\n             _warn(\"Empty session id, using global scope instead.\")\n             return self.__scopes[_DataScopes._GLOBAL_ID], self.__scopes_metadata[_DataScopes._GLOBAL_ID]\n         if client_id not in self.__scopes:\n-            _warn(\n+            _TaipyLogger._get_logger().debug(\n                 f\"Session id {client_id} not found in data scope. Taipy will automatically create a scope for this session id but you may have to reload your page.\"  # noqa: E501\n             )\n             self.create_scope(client_id)\ndiff --git a/taipy/gui/gui.py b/taipy/gui/gui.py\nindex 56f6ee45db..1db837843f 100644\n--- a/taipy/gui/gui.py\n+++ b/taipy/gui/gui.py\n@@ -700,8 +700,15 @@ def _manage_message(self, msg_type: _WsType, message: dict) -> None:\n         try:\n             client_id = None\n             if msg_type == _WsType.CLIENT_ID.value:\n-                res = self._bindings()._get_or_create_scope(message.get(\"payload\", \"\"))\n+                payload = message.get(\"payload\", {})\n+                res = self._bindings()._get_or_create_scope(\n+                    payload.get(\"id\", \"\") if isinstance(payload, dict) else str(payload)\n+                )\n                 client_id = res[0] if res[1] else None\n+                if self._config.config.get(\"app_id\", False):\n+                    front_app_id = payload.get(\"app_id\", None) if isinstance(payload, dict) else None\n+                    if front_app_id is not None:\n+                        self.__handle_ws_app_id({\"name\": message.get(\"name\"), \"payload\": front_app_id})\n             expected_client_id = client_id or message.get(Gui.__ARG_CLIENT_ID)\n             self.__set_client_id_in_context(expected_client_id)\n             g.ws_client_id = expected_client_id\n", "test_patch": "diff --git a/tests/gui/gui_specific/test_gui.py b/tests/gui/gui_specific/test_gui.py\nindex cf0fb2563e..385a446c9b 100644\n--- a/tests/gui/gui_specific/test_gui.py\n+++ b/tests/gui/gui_specific/test_gui.py\n@@ -38,8 +38,7 @@ def test__get_real_var_name(gui: Gui):\n def test__get_user_instance(gui: Gui):\n     gui.run(run_server=False)\n     with gui.get_flask_app().app_context():\n-        with pytest.warns(UserWarning):\n-            gui._get_user_instance(\"\", type(None))\n+        gui._get_user_instance(\"\", type(None))\n \n \n def test__refresh_expr(gui: Gui):\n", "problem_statement": "[\ud83d\udc1b BUG] De-synchronized front-ends and  back-end  \n### What went wrong? \ud83e\udd14\nFront-ends get de-synchronized when re-running an application.\n\nThis is more important than it looks like, as it happens frequently and gives users the wrong impression that their application has a bug. \n\nFor example, it happens frequently during an application's development phase, especially with the default behavior of Gui().run(), which opens a new tab without closing the previous tabs.\n\nIt also happens when re-deploying a live application, causing the wrong error messages at a very bad time.\n\n### Reproduce the situation\n\nThe problem arises when:\n\n- We run an application.\n- We access the application on a browser tab.\n- We shut down the application without closing the tab.\n- We re-run the application (or another application on the same port).\n- We use the same old tab that does not correspond to the new back-end application. This may create errors, warnings, or inconsistencies.\n\n### Expected Behavior\n\nDe-synchronized front-ends should be aware that the back-end version they are connected to is incorrect. The front-end application should automatically display a message to let the user know he/she should refresh the browser.\n\n### Solution Proposed\n\nWhat about generating a unique identifier each time we run the server? It could represent a `run_identifier`. Each of the clients (the tabs) could know this unique `run_identifier`. \nThe clients could pass the `run_identifier` to the back end every time it communicates with it. On the server side, the client request is properly rejected if the `run_identifier` received from the client does not match its own internal `run_identifier`. The front end should be able to display a message asking the user to refresh the tab.\n\n### Version of Taipy\n\n- 3.X,\n- 4.Y,\n- develop\n\n### Linked issues\n- https://github.com/Avaiga/taipy-enterprise/issues/574\n\n### Acceptance Criteria\n\n- [ ] A unit test reproducing the bug is added.\n- [ ] Any new code is covered by a unit tested.\n- [ ] Check code coverage is at least 90%.\n- [ ] The bug reporter validated the fix.\n- [ ] Related issue(s) in taipy-doc are created for documentation and Release Notes are updated.\n\n### Code of Conduct\n\n- [x] I have checked the [existing issues](https://github.com/Avaiga/taipy/issues?q=is%3Aissue+).\n- [ ] I am willing to work on this issue (optional)\n[\ud83d\udc1b BUG] De-synchronized front-ends and  back-end  \n### What went wrong? \ud83e\udd14\nFront-ends get de-synchronized when re-running an application.\n\nThis is more important than it looks like, as it happens frequently and gives users the wrong impression that their application has a bug. \n\nFor example, it happens frequently during an application's development phase, especially with the default behavior of Gui().run(), which opens a new tab without closing the previous tabs.\n\nIt also happens when re-deploying a live application, causing the wrong error messages at a very bad time.\n\n### Reproduce the situation\n\nThe problem arises when:\n\n- We run an application.\n- We access the application on a browser tab.\n- We shut down the application without closing the tab.\n- We re-run the application (or another application on the same port).\n- We use the same old tab that does not correspond to the new back-end application. This may create errors, warnings, or inconsistencies.\n\n### Expected Behavior\n\nDe-synchronized front-ends should be aware that the back-end version they are connected to is incorrect. The front-end application should automatically display a message to let the user know he/she should refresh the browser.\n\n### Solution Proposed\n\nWhat about generating a unique identifier each time we run the server? It could represent a `run_identifier`. Each of the clients (the tabs) could know this unique `run_identifier`. \nThe clients could pass the `run_identifier` to the back end every time it communicates with it. On the server side, the client request is properly rejected if the `run_identifier` received from the client does not match its own internal `run_identifier`. The front end should be able to display a message asking the user to refresh the tab.\n\n### Version of Taipy\n\n- 3.X,\n- 4.Y,\n- develop\n\n### Linked issues\n- https://github.com/Avaiga/taipy-enterprise/issues/574\n\n### Acceptance Criteria\n\n- [ ] A unit test reproducing the bug is added.\n- [ ] Any new code is covered by a unit tested.\n- [ ] Check code coverage is at least 90%.\n- [ ] The bug reporter validated the fix.\n- [ ] Related issue(s) in taipy-doc are created for documentation and Release Notes are updated.\n\n### Code of Conduct\n\n- [x] I have checked the [existing issues](https://github.com/Avaiga/taipy/issues?q=is%3Aissue+).\n- [ ] I am willing to work on this issue (optional)\n", "hints_text": "@FredLL-Avaiga Here is the previous implementation of App Id\nWS Type declaration https://github.com/Avaiga/taipy/blob/develop/taipy/gui/types.py#L46\nWS Handler \n- https://github.com/Avaiga/taipy/blob/develop/taipy/gui/gui.py#L729-L730\n- https://github.com/Avaiga/taipy/blob/develop/taipy/gui/gui.py#L1338-L1352\n\n@FredLL-Avaiga Here is the previous implementation of App Id\nWS Type declaration https://github.com/Avaiga/taipy/blob/develop/taipy/gui/types.py#L46\nWS Handler \n- https://github.com/Avaiga/taipy/blob/develop/taipy/gui/gui.py#L729-L730\n- https://github.com/Avaiga/taipy/blob/develop/taipy/gui/gui.py#L1338-L1352\n", "created_at": "2025-02-18T09:29:56Z"}
{"repo": "Avaiga/taipy", "pull_number": 2432, "instance_id": "Avaiga__taipy-2432", "issue_numbers": ["421"], "base_commit": "4cce531e86a0faf9fbd44e0addbc3668f88815cb", "patch": "diff --git a/taipy/common/config/config.pyi b/taipy/common/config/config.pyi\nindex e484f62cc..d75e28a7c 100644\n--- a/taipy/common/config/config.pyi\n+++ b/taipy/common/config/config.pyi\n@@ -16,6 +16,7 @@ from taipy.common.config._config import _Config\n from taipy.core.common.frequency import Frequency\n from taipy.core.common.scope import Scope\n from taipy.core.config import CoreSection, DataNodeConfig, JobConfig, ScenarioConfig, TaskConfig\n+from taipy.rest.config import RestConfig\n \n from .checker.issue_collector import IssueCollector\n from .common._classproperty import _Classproperty\n@@ -254,6 +255,10 @@ class Config:\n     def core(cls) -> Dict[str, CoreSection]:\n         \"\"\"\"\"\"\n \n+    @_Classproperty\n+    def rest(cls) -> Dict[str, RestConfig]:\n+        \"\"\"\"\"\"\n+\n     @staticmethod\n     def configure_scenario(\n         id: str,\n@@ -1022,3 +1027,27 @@ class Config:\n         Returns:\n             The Core configuration.\n         \"\"\"\n+\n+    @staticmethod\n+    def configure_rest(\n+        port: Optional[int] = None,\n+        host: Optional[str] = None,\n+        use_https: Optional[bool] = None,\n+        ssl_cert: Optional[str] = None,\n+        ssl_key: Optional[str] = None,\n+        **properties\n+    ) -> \"RestConfig\":\n+        \"\"\"Configure the Rest service.\n+\n+        Arguments:\n+            port (Optional[int]): The port on which the REST service will be running\n+            host (Optional[str]): The host on which the REST service will be running\n+            use_https (Optional[bool]): Whether to use HTTPS for the REST service\n+            ssl_cert (Optional[str]): The path to the SSL certificate file\n+            ssl_key (Optional[str]): The path to the SSL key file\n+            **properties (Dict[str, Any]): A keyworded variable length list of additional\n+                arguments configure the behavior of the `Rest^` service.\n+\n+        Returns:\n+            The Rest configuration.\n+        \"\"\"\ndiff --git a/taipy/common/config/stubs/generate_pyi.py b/taipy/common/config/stubs/generate_pyi.py\nindex 6f9ba51b9..7b799c994 100644\n--- a/taipy/common/config/stubs/generate_pyi.py\n+++ b/taipy/common/config/stubs/generate_pyi.py\n@@ -103,25 +103,25 @@ def _build_entity_config_pyi(base_pyi, filename, entity_map) -> str:\n     return base_pyi\n \n \n-def _generate_entity_and_property_maps(filename):\n+def _generate_entity_and_property_maps(filenames):\n     entities_map = {}\n     property_map = {}\n-    entity_tree = _get_file_ast(filename)\n-    functions = [\n-        f for f in ast.walk(entity_tree) if isinstance(f, ast.Call) and getattr(f.func, \"id\", \"\") == \"_inject_section\"\n-    ]\n-\n-    for f in functions:\n-        entity = ast.unparse(f.args[0])\n-        entities_map[entity] = {}\n-        property_map[eval(ast.unparse(f.args[1]))] = entity\n-        # Remove class name from function map\n-        text = ast.unparse(f.args[-1]).replace(f\"{entity}.\", \"\")\n-        matches = re.findall(r\"\\((.*?)\\)\", text)\n-\n-        for m in matches:\n-            v, k = m.replace(\"'\", \"\").split(\",\")\n-            entities_map[entity][k.strip()] = v\n+    for filename in filenames:\n+        etty_tree = _get_file_ast(filename)\n+        functions = [\n+            f for f in ast.walk(etty_tree) if isinstance(f, ast.Call) and getattr(f.func, \"id\", \"\") == \"_inject_section\"\n+        ]\n+        for f in functions:\n+            entity = ast.unparse(f.args[0])\n+            entities_map[entity] = {}\n+            property_map[eval(ast.unparse(f.args[1]))] = entity\n+            # Remove class name from function map\n+            text = ast.unparse(f.args[-1]).replace(f\"{entity}.\", \"\")\n+            matches = re.findall(r\"\\((.*?)\\)\", text)\n+\n+            for m in matches:\n+                v, k = m.replace(\"'\", \"\").split(\",\")\n+                entities_map[entity][k.strip()] = v\n     return entities_map, property_map\n \n \n@@ -142,8 +142,8 @@ def _build_header(filename) -> str:\n \n if __name__ == \"__main__\":\n     header_file = \"taipy/common/config/stubs/pyi_header.py\"\n-    config_init = Path(\"taipy/core/config/__init__.py\")\n     base_config = \"taipy/common/config/config.py\"\n+    config_init = [Path(\"taipy/core/config/__init__.py\"), Path(\"taipy/rest/config/__init__.py\")]\n \n     dn_filename = \"taipy/core/config/data_node_config.py\"\n     job_filename = \"taipy/core/config/job_config.py\"\n@@ -151,6 +151,8 @@ def _build_header(filename) -> str:\n     task_filename = \"taipy/core/config/task_config.py\"\n     core_filename = \"taipy/core/config/core_section.py\"\n \n+    rest_filename = \"taipy/rest/config/rest_config.py\"\n+\n     entities_map, property_map = _generate_entity_and_property_maps(config_init)\n     pyi = _build_header(header_file)\n     pyi = _build_base_config_pyi(base_config, pyi)\n@@ -161,6 +163,8 @@ def _build_header(filename) -> str:\n     pyi = _build_entity_config_pyi(pyi, job_filename, entities_map[\"JobConfig\"])\n     pyi = _build_entity_config_pyi(pyi, core_filename, entities_map[\"CoreSection\"])\n \n+    pyi = _build_entity_config_pyi(pyi, rest_filename, entities_map[\"RestConfig\"])\n+\n     # Remove the final redundant \\n\n     pyi = pyi[:-1]\n \ndiff --git a/taipy/common/config/stubs/pyi_header.py b/taipy/common/config/stubs/pyi_header.py\nindex 2a9848046..1035b88c3 100644\n--- a/taipy/common/config/stubs/pyi_header.py\n+++ b/taipy/common/config/stubs/pyi_header.py\n@@ -16,6 +16,7 @@\n from taipy.core.common.frequency import Frequency\n from taipy.core.common.scope import Scope\n from taipy.core.config import CoreSection, DataNodeConfig, JobConfig, ScenarioConfig, TaskConfig\n+from taipy.rest.config import RestConfig\n \n from .checker.issue_collector import IssueCollector\n from .common._classproperty import _Classproperty\ndiff --git a/taipy/rest/config/__init__.py b/taipy/rest/config/__init__.py\nnew file mode 100644\nindex 000000000..a5b1926a5\n--- /dev/null\n+++ b/taipy/rest/config/__init__.py\n@@ -0,0 +1,26 @@\n+# Copyright 2021-2025 Avaiga Private Limited\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+# the License. You may obtain a copy of the License at\n+#\n+#        http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+# an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+# specific language governing permissions and limitations under the License.\n+\"\"\"Configuration of the rest service.\"\"\"\n+\n+from taipy.common.config import _inject_section\n+from taipy.common.config.checker._checker import _Checker\n+\n+from .rest_checker import _RestConfigChecker\n+from .rest_config import RestConfig\n+\n+_inject_section(\n+    RestConfig,\n+    \"rest\",\n+    RestConfig.default_config(),\n+    [(\"configure_rest\", RestConfig._configure_rest)]\n+)\n+\n+_Checker.add_checker(_RestConfigChecker)\ndiff --git a/taipy/rest/config/rest_checker.py b/taipy/rest/config/rest_checker.py\nnew file mode 100644\nindex 000000000..c65791077\n--- /dev/null\n+++ b/taipy/rest/config/rest_checker.py\n@@ -0,0 +1,72 @@\n+# Copyright 2021-2025 Avaiga Private Limited\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+# the License. You may obtain a copy of the License at\n+#\n+#        http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+# an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+# specific language governing permissions and limitations under the License.\n+\n+from typing import cast\n+\n+from taipy.common.config._config import _Config\n+from taipy.common.config.checker._checkers._config_checker import _ConfigChecker\n+from taipy.common.config.checker.issue_collector import IssueCollector\n+\n+from .rest_config import RestConfig\n+\n+\n+class _RestConfigChecker(_ConfigChecker):\n+    def __init__(self, config: _Config, collector: IssueCollector):\n+        super().__init__(config, collector)\n+\n+    def _check(self) -> IssueCollector:\n+        if rest_configs := self._config._unique_sections.get(RestConfig.name):\n+            rest_config = cast(RestConfig, rest_configs)\n+            self._check_port(rest_config)\n+            self._check_host(rest_config)\n+            self._check_https_settings(rest_config)\n+        return self._collector\n+\n+    def _check_port(self, rest_config: RestConfig):\n+        if not isinstance(rest_config.port, int) or not (1 <= rest_config.port <= 65535):\n+            self._error(\n+                \"port\",\n+                rest_config.port,\n+                \"The port of the RestConfig must be an integer between 1 and 65535.\",\n+            )\n+\n+    def _check_host(self, rest_config: RestConfig):\n+        if not isinstance(rest_config.host, str) or not rest_config.host:\n+            self._error(\n+                \"host\", rest_config.host, \"The host of the RestConfig must be a non-empty string.\"\n+            )\n+\n+    def _check_https_settings(self, rest_config: RestConfig):\n+        if rest_config.use_https:\n+            if not rest_config.ssl_cert:\n+                self._error(\n+                    \"ssl_cert\",\n+                    rest_config.ssl_cert,\n+                    \"When HTTPS is enabled in the RestConfig ssl_cert must be set.\",\n+                )\n+            elif not isinstance(rest_config.ssl_cert, str):\n+                self._error(\n+                    \"ssl_cert\",\n+                    rest_config.ssl_cert,\n+                    \"The ssl_cert of the RestConfig must be valid string.\",\n+                )\n+            if not rest_config.ssl_key:\n+                self._error(\n+                    \"ssl_key\",\n+                    rest_config.ssl_key,\n+                    \"When HTTPS is enabled in the RestConfig ssl_key must be set.\",\n+                )\n+            elif not isinstance(rest_config.ssl_key, str):\n+                self._error(\n+                    \"ssl_key\",\n+                    rest_config.ssl_key,\n+                    \"The ssl_key of the RestConfig must be valid string.\",\n+                )\ndiff --git a/taipy/rest/config/rest_config.py b/taipy/rest/config/rest_config.py\nnew file mode 100644\nindex 000000000..195e73f58\n--- /dev/null\n+++ b/taipy/rest/config/rest_config.py\n@@ -0,0 +1,199 @@\n+# Copyright 2021-2025 Avaiga Private Limited\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+# the License. You may obtain a copy of the License at\n+#\n+#        http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+# an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+# specific language governing permissions and limitations under the License.\n+from copy import copy\n+from typing import Any, Dict, Optional, Tuple\n+\n+from taipy.common.config import UniqueSection\n+from taipy.common.config._config import _Config\n+from taipy.common.config.common._template_handler import _TemplateHandler as _tpl\n+from taipy.common.config.config import Config\n+\n+\n+class RestConfig(UniqueSection):\n+    \"\"\"Configuration parameters for running the `Rest^` service\"\"\"\n+\n+    name: str = \"REST\"\n+\n+    _PORT_KEY: str = \"port\"\n+    _DEFAULT_PORT: int = 5000\n+    _HOST_KEY: str = \"host\"\n+    _DEFAULT_HOST: str = \"127.0.0.1\"\n+    _USE_HTTPS_KEY: str = \"use_https\"\n+    _DEFAULT_USE_HTTPS: bool = False\n+    _SSL_CERT_KEY: str = \"ssl_cert\"\n+    _DEFAULT_SSL_CERT: Optional[str] = None\n+    _SSL_KEY_KEY: str = \"ssl_key\"\n+    _DEFAULT_SSL_KEY: Optional[str] = None\n+\n+    def __init__(\n+        self,\n+        port: Optional[int] = _DEFAULT_PORT,\n+        host: Optional[str] = _DEFAULT_HOST,\n+        use_https: Optional[bool] = _DEFAULT_USE_HTTPS,\n+        ssl_cert: Optional[str] = _DEFAULT_SSL_CERT,\n+        ssl_key: Optional[str] = _DEFAULT_SSL_KEY,\n+        **properties,\n+    ):\n+        self._port = port\n+        self._host = host\n+        self._use_https = use_https\n+        self._ssl_cert = ssl_cert\n+        self._ssl_key = ssl_key\n+        super().__init__(**properties)\n+\n+    def __copy__(self) -> \"RestConfig\":\n+        return RestConfig(\n+            self._port,\n+            self._host,\n+            self._use_https,\n+            self._ssl_cert,\n+            self._ssl_key,\n+            **copy(self._properties),\n+        )\n+\n+    def _clean(self):\n+        self._port = self._DEFAULT_PORT\n+        self._host = self._DEFAULT_HOST\n+        self._use_https = self._DEFAULT_USE_HTTPS\n+        self._ssl_cert = self._DEFAULT_SSL_CERT\n+        self._ssl_key = self._DEFAULT_SSL_KEY\n+        self._properties.clear()\n+\n+    def _update(self, config_as_dict: Dict, default_section=None):\n+        self._port = config_as_dict.pop(self._PORT_KEY, self.port)\n+        self._host = config_as_dict.pop(self._HOST_KEY, self.host)\n+        self._use_https = config_as_dict.pop(self._USE_HTTPS_KEY, self.use_https)\n+        self._ssl_cert = config_as_dict.pop(self._SSL_CERT_KEY, self.ssl_cert)\n+        self._ssl_key = config_as_dict.pop(self._SSL_KEY_KEY, self.ssl_key)\n+        self._properties.update(config_as_dict)\n+\n+    def _to_dict(self):\n+        as_dict = {\n+            key: value\n+            for key, value in {\n+                self._PORT_KEY: self._port,\n+                self._HOST_KEY: self._host,\n+                self._USE_HTTPS_KEY: self._use_https,\n+                self._SSL_CERT_KEY: self._ssl_cert,\n+                self._SSL_KEY_KEY: self._ssl_key\n+            }.items()\n+            if value is not None\n+        }\n+        as_dict.update(self._properties)\n+        return as_dict\n+\n+    @classmethod\n+    def _from_dict(cls, as_dict: Dict[str, Any], id=None, config: Optional[_Config] = None):\n+        port = as_dict.pop(cls._PORT_KEY, None)\n+        host = as_dict.pop(cls._HOST_KEY, None)\n+        use_https = as_dict.pop(cls._USE_HTTPS_KEY, None)\n+        ssl_cert = as_dict.pop(cls._SSL_CERT_KEY, None)\n+        ssl_key = as_dict.pop(cls._SSL_KEY_KEY, None)\n+        return RestConfig(port, host, use_https, ssl_cert, ssl_key, **as_dict)\n+\n+    @classmethod\n+    def default_config(cls) -> \"RestConfig\":\n+        \"\"\"Return a RestConfig with all the default values.\n+\n+        Returns:\n+            The default rest configuration.\n+        \"\"\"\n+        return RestConfig(\n+            cls._DEFAULT_PORT,\n+            cls._DEFAULT_HOST,\n+            cls._DEFAULT_USE_HTTPS,\n+            cls._DEFAULT_SSL_CERT,\n+            cls._DEFAULT_SSL_KEY,\n+        )\n+\n+    @property\n+    def port(self) -> int:\n+        \"\"\"The port on which the REST service will be running\"\"\"\n+        return _tpl._replace_templates(self._port)\n+\n+    @port.setter\n+    def port(self, value: int):\n+        self._port = value\n+\n+    @property\n+    def host(self) -> str:\n+        \"\"\"The host on which the REST service will be running\"\"\"\n+        return _tpl._replace_templates(self._host)\n+\n+    @host.setter\n+    def host(self, value: str):\n+        self._host = value\n+\n+    @property\n+    def use_https(self) -> bool:\n+        \"\"\"Whether to use HTTPS for the REST service\"\"\"\n+        return _tpl._replace_templates(self._use_https)\n+\n+    @use_https.setter\n+    def use_https(self, value: bool):\n+        self._use_https = value\n+\n+    @property\n+    def ssl_cert(self) -> Optional[str]:\n+        \"\"\"The path to the SSL certificate file\"\"\"\n+        return _tpl._replace_templates(self._ssl_cert)\n+\n+    @ssl_cert.setter\n+    def ssl_cert(self, value: Optional[str]):\n+        self._ssl_cert = value\n+\n+    @property\n+    def ssl_key(self) -> Optional[str]:\n+        \"\"\"The path to the SSL key file\"\"\"\n+        return _tpl._replace_templates(self._ssl_key)\n+\n+    @ssl_key.setter\n+    def ssl_key(self, value: Optional[str]):\n+        self._ssl_key = value\n+\n+    @property\n+    def ssl_context(self) -> Optional[Tuple[Optional[str], Optional[str]]]:\n+        \"\"\"The ssl_context as a tuple of the certificate and the key files\"\"\"\n+        return (self.ssl_cert, self.ssl_key) if self.use_https else None\n+\n+    @staticmethod\n+    def _configure_rest(\n+        port: Optional[int] = None,\n+        host: Optional[str] = None,\n+        use_https: Optional[bool] = None,\n+        ssl_cert: Optional[str] = None,\n+        ssl_key: Optional[str] = None,\n+        **properties\n+    ) -> \"RestConfig\":\n+        \"\"\"Configure the Rest service.\n+\n+        Arguments:\n+            port (Optional[int]): The port on which the REST service will be running\n+            host (Optional[str]): The host on which the REST service will be running\n+            use_https (Optional[bool]): Whether to use HTTPS for the REST service\n+            ssl_cert (Optional[str]): The path to the SSL certificate file\n+            ssl_key (Optional[str]): The path to the SSL key file\n+            **properties (Dict[str, Any]): A keyworded variable length list of additional\n+                arguments configure the behavior of the `Rest^` service.\n+\n+        Returns:\n+            The Rest configuration.\n+        \"\"\"\n+        section = RestConfig(\n+            port=port,\n+            host=host,\n+            use_https=use_https,\n+            ssl_cert=ssl_cert,\n+            ssl_key=ssl_key,\n+            **properties\n+        )\n+        Config._register(section)\n+        return Config.unique_sections[RestConfig.name]\ndiff --git a/taipy/rest/rest.py b/taipy/rest/rest.py\nindex def98b195..05484335c 100644\n--- a/taipy/rest/rest.py\n+++ b/taipy/rest/rest.py\n@@ -44,4 +44,12 @@ def run(self, **kwargs):\n         Arguments:\n             **kwargs : Options to provide to the application server.\n         \"\"\"\n+        rest_config = Config.rest\n+        kwargs.update(\n+            {\n+                \"port\": rest_config.port,\n+                \"host\": rest_config.host,\n+                \"ssl_context\": rest_config.ssl_context,\n+            }\n+        )\n         self._app.run(**kwargs)\n", "test_patch": "diff --git a/tests/conftest.py b/tests/conftest.py\nindex 9873b9326..067f57344 100644\n--- a/tests/conftest.py\n+++ b/tests/conftest.py\n@@ -22,6 +22,7 @@\n from taipy.common.config.checker._checker import _Checker\n from taipy.common.config.checker.issue_collector import IssueCollector\n from taipy.core.config import CoreSection, DataNodeConfig, JobConfig, ScenarioConfig, TaskConfig\n+from taipy.rest.config import RestConfig\n \n \n def pytest_addoption(parser: pytest.Parser) -> None:\n@@ -57,6 +58,7 @@ def remove_subparser(name: str) -> None:\n @pytest.fixture\n def clean_argparser() -> t.Callable:\n     \"\"\"Fixture to clean the argument parser.\"\"\"\n+\n     def _clean_argparser() -> None:\n         _TaipyParser._parser = argparse.ArgumentParser(conflict_handler=\"resolve\")\n         _TaipyParser._subparser_action = None\n@@ -71,6 +73,7 @@ def _clean_argparser() -> None:\n @pytest.fixture\n def reset_configuration_singleton() -> t.Callable:\n     \"\"\"Fixture to reset the configuration singleton.\"\"\"\n+\n     def _reset_configuration_singleton() -> None:\n         Config.unblock_update()\n \n@@ -90,6 +93,7 @@ def _reset_configuration_singleton() -> None:\n @pytest.fixture\n def inject_core_sections() -> t.Callable:\n     \"\"\"Fixture to inject core sections into the configuration.\"\"\"\n+\n     def _inject_core_sections() -> None:\n         _inject_section(\n             JobConfig,\n@@ -145,3 +149,17 @@ def _inject_core_sections() -> None:\n         )\n \n     return _inject_core_sections\n+\n+@pytest.fixture\n+def inject_rest_sections() -> t.Callable:\n+    \"\"\"Fixture to inject core sections into the configuration.\"\"\"\n+\n+    def _inject_rest_sections() -> None:\n+        _inject_section(\n+            RestConfig,\n+            \"rest\",\n+            default=RestConfig.default_config(),\n+            configuration_methods=[(\"configure_rest\", RestConfig._configure_rest)],\n+        )\n+\n+    return _inject_rest_sections\ndiff --git a/tests/rest/conftest.py b/tests/rest/conftest.py\nindex 9bbf627ef..a4fbfc811 100644\n--- a/tests/rest/conftest.py\n+++ b/tests/rest/conftest.py\n@@ -20,6 +20,7 @@\n from dotenv import load_dotenv\n \n from taipy.common.config import Config\n+from taipy.common.config.checker._checker import _Checker\n from taipy.core import Cycle, DataNodeId, Job, JobId, Scenario, Sequence, Task\n from taipy.core._orchestrator._orchestrator_factory import _OrchestratorFactory\n from taipy.core.common.frequency import Frequency\n@@ -29,6 +30,7 @@\n from taipy.core.job._job_manager import _JobManager\n from taipy.core.task._task_manager import _TaskManager\n from taipy.rest.app import create_app\n+from taipy.rest.config import _RestConfigChecker\n \n from .setup.shared.algorithms import evaluate, forecast\n \n@@ -309,11 +311,26 @@ def create_job_list():\n         manager._set(c)\n     return jobs\n \n+@pytest.fixture\n+def init_orchestrator():\n+    def _init_orchestrator():\n+        _OrchestratorFactory._remove_dispatcher()\n+\n+        if _OrchestratorFactory._orchestrator is None:\n+            _OrchestratorFactory._build_orchestrator()\n+        _OrchestratorFactory._build_dispatcher(force_restart=True)\n+        _OrchestratorFactory._orchestrator.jobs_to_run = Queue()\n+        _OrchestratorFactory._orchestrator.blocked_jobs = []\n+\n+    return _init_orchestrator\n \n @pytest.fixture(scope=\"function\", autouse=True)\n-def cleanup_files(reset_configuration_singleton, inject_core_sections):\n+def cleanup_files(reset_configuration_singleton, inject_rest_sections, inject_core_sections):\n     reset_configuration_singleton()\n     inject_core_sections()\n+    inject_rest_sections()\n+\n+    _Checker.add_checker(_RestConfigChecker)\n \n     Config.configure_core(repository_type=\"filesystem\")\n     if os.path.exists(\".data\"):\n@@ -325,17 +342,3 @@ def cleanup_files(reset_configuration_singleton, inject_core_sections):\n     for path in [\".data\", \".my_data\", \"user_data\", \".taipy\"]:\n         if os.path.exists(path):\n             shutil.rmtree(path, ignore_errors=True)\n-\n-\n-@pytest.fixture\n-def init_orchestrator():\n-    def _init_orchestrator():\n-        _OrchestratorFactory._remove_dispatcher()\n-\n-        if _OrchestratorFactory._orchestrator is None:\n-            _OrchestratorFactory._build_orchestrator()\n-        _OrchestratorFactory._build_dispatcher(force_restart=True)\n-        _OrchestratorFactory._orchestrator.jobs_to_run = Queue()\n-        _OrchestratorFactory._orchestrator.blocked_jobs = []\n-\n-    return _init_orchestrator\ndiff --git a/tests/rest/test_rest_config.py b/tests/rest/test_rest_config.py\nnew file mode 100644\nindex 000000000..4bea9bbed\n--- /dev/null\n+++ b/tests/rest/test_rest_config.py\n@@ -0,0 +1,195 @@\n+# Copyright 2021-2025 Avaiga Private Limited\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+# the License. You may obtain a copy of the License at\n+#\n+#        http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+# an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+# specific language governing permissions and limitations under the License.\n+import os\n+from unittest.mock import patch\n+\n+import pytest\n+\n+from taipy.common.config.config import Config\n+from taipy.common.config.exceptions import MissingEnvVariableError\n+from taipy.rest.config.rest_config import RestConfig\n+from tests.core.utils.named_temporary_file import NamedTemporaryFile\n+\n+\n+def test_rest_config_no_values():\n+    assert Config.rest.port == 5000\n+    assert Config.rest.host == \"127.0.0.1\"\n+    assert Config.rest.use_https is False\n+    assert Config.rest.ssl_cert is None\n+    assert Config.rest.ssl_key is None\n+\n+def test_rest_config_default_values():\n+    Config.configure_rest()\n+    assert Config.rest.port == RestConfig._DEFAULT_PORT\n+    assert Config.rest.host == RestConfig._DEFAULT_HOST\n+    assert Config.rest.use_https is RestConfig._DEFAULT_USE_HTTPS\n+    assert Config.rest.ssl_cert is RestConfig._DEFAULT_SSL_CERT\n+    assert Config.rest.ssl_key is RestConfig._DEFAULT_SSL_KEY\n+\n+def test_rest_config_only_part_of_custom_values():\n+    Config.configure_rest(\n+        use_https=True,\n+        ssl_cert=\"cert.pem\",\n+        ssl_key=\"key.pem\"\n+    )\n+    assert Config.rest.port == RestConfig._DEFAULT_PORT\n+    assert Config.rest.host == RestConfig._DEFAULT_HOST\n+    assert Config.rest.use_https is True\n+    assert Config.rest.ssl_cert == \"cert.pem\"\n+    assert Config.rest.ssl_key == \"key.pem\"\n+\n+def test_rest_config_custom_values_and_toml_override():\n+    # We override some default values with the Python API\n+    Config.configure_rest(\n+        port=8080,\n+        host=\"0.0.0.0\",\n+    )\n+    assert Config.rest.port == 8080\n+    assert Config.rest.host == \"0.0.0.0\"\n+    assert Config.rest.use_https is RestConfig._DEFAULT_USE_HTTPS\n+    assert Config.rest.ssl_cert is RestConfig._DEFAULT_SSL_CERT\n+    assert Config.rest.ssl_key is RestConfig._DEFAULT_SSL_KEY\n+\n+    # now we load a toml file\n+    toml_cfg = NamedTemporaryFile(\n+        content=\"\"\"\n+[TAIPY]\n+\n+[REST]\n+port = 2\n+host = \"192.168.0.87\"\n+use_https = \"true:bool\"\n+ssl_cert = \"cert.pem\"\n+ssl_key = \"key.pem\"\n+\"\"\"\n+    )\n+    Config.load(toml_cfg.filename)\n+    assert Config.rest.port == 2\n+    assert Config.rest.host == \"192.168.0.87\"\n+    assert Config.rest.use_https is True\n+    assert Config.rest.ssl_cert == \"cert.pem\"\n+    assert Config.rest.ssl_key == \"key.pem\"\n+\n+\n+def test_rest_config_custom_values_and_missing_env_var_override():\n+    #we use env variables\n+    Config.configure_rest(\n+        port=\"ENV[PORT]:int\",\n+        host=\"ENV[HOST]\",\n+        ssl_cert=\"ENV[SSL_CERT]\",\n+        ssl_key=\"ENV[SSL_KEY]\"\n+    )\n+    Config.rest.use_https = \"ENV[USE_HTTPS]\"\n+    with pytest.raises(MissingEnvVariableError):\n+        _ = Config.rest.port\n+    with pytest.raises(MissingEnvVariableError):\n+        _ = Config.rest.host\n+    with pytest.raises(MissingEnvVariableError):\n+        _ = Config.rest.use_https\n+    with pytest.raises(MissingEnvVariableError):\n+        _ = Config.rest.ssl_cert\n+    with pytest.raises(MissingEnvVariableError):\n+        _ = Config.rest.ssl_key\n+\n+def test_rest_config_custom_values_and_env_var_override():\n+    with patch.dict(os.environ, {\n+        \"PORT\": \"3\",\n+        \"HOST\": \"1.2.3.4\",\n+        \"USE_HTTPS\": \"true\",\n+        \"SSL_CERT\": \"cert.pem\",\n+        \"SSL_KEY\": \"key.pem\"\n+    }):\n+        # we use env variables\n+        Config.configure_rest(\n+            port=\"ENV[PORT]:int\",\n+            host=\"ENV[HOST]\",\n+            use_https=\"ENV[USE_HTTPS]:bool\",\n+            ssl_cert=\"ENV[SSL_CERT]\",\n+            ssl_key=\"ENV[SSL_KEY]\"\n+        )\n+        assert Config.rest.port == 3\n+        assert Config.rest.host == \"1.2.3.4\"\n+        assert Config.rest.use_https is True\n+        assert Config.rest.ssl_cert == \"cert.pem\"\n+        assert Config.rest.ssl_key == \"key.pem\"\n+\n+\n+def test_rest_config_copy():\n+    rest_config = Config.configure_rest(\n+        port=8080, host=\"0.0.0.0\", use_https=True, ssl_cert=\"cert.pem\", ssl_key=\"key.pem\"\n+    )\n+    rest_config_copy = rest_config.__copy__()\n+\n+    assert rest_config_copy.port == 8080\n+    assert rest_config_copy.host == \"0.0.0.0\"\n+    assert rest_config_copy.use_https is True\n+    assert rest_config_copy.ssl_cert == \"cert.pem\"\n+    assert rest_config_copy.ssl_key == \"key.pem\"\n+\n+    # Ensure it's a deep copy\n+    rest_config_copy.port = 9090\n+    assert rest_config.port == 8080\n+\n+\n+def test_rest_default_config_is_valid():\n+    issues = Config.check()\n+\n+    assert len(issues.errors) == 0\n+    assert len(issues.warnings) == 0\n+    assert len(issues.infos) == 0\n+\n+\n+def test_rest_config_checker_valid_config():\n+    Config.configure_rest(port=8080, host=\"0.0.0.0\", use_https=True, ssl_cert=\"cert.pem\", ssl_key=\"key.pem\")\n+    issues = Config.check()\n+\n+    assert len(issues.errors) == 0\n+    assert len(issues.warnings) == 0\n+    assert len(issues.infos) == 0\n+\n+\n+def test_rest_config_checker_invalid_port_and_host():\n+    Config.configure_rest(port=70000, host=\"\")  # Invalid port and host\n+    with pytest.raises(SystemExit):\n+        Config.check()\n+\n+    issues = Config._collector\n+    assert len(issues.errors) == 2\n+    assert len(issues.warnings) == 0\n+    assert len(issues.infos) == 0\n+    assert \"port\" in issues.errors[0].field\n+    assert \"host\" in issues.errors[1].field\n+\n+\n+def test_rest_config_checker_https_missing_cert_and_key():\n+    Config.configure_rest(use_https=True)  # Missing ssl_cert and ssl_key\n+    with pytest.raises(SystemExit):\n+        Config.check()\n+\n+    issues = Config._collector\n+    assert len(issues.errors) == 2\n+    assert len(issues.warnings) == 0\n+    assert len(issues.infos) == 0\n+    assert \"ssl_cert\" in issues.errors[0].field\n+    assert \"ssl_key\" in issues.errors[1].field\n+\n+\n+def test_rest_config_checker_https_invalid_cert_and_key():\n+    Config.configure_rest(use_https=True, ssl_cert=123, ssl_key=456)  # Invalid types for ssl_cert and ssl_key\n+    with pytest.raises(SystemExit):\n+        Config.check()\n+\n+    issues = Config._collector\n+    assert len(issues.errors) == 2\n+    assert len(issues.warnings) == 0\n+    assert len(issues.infos) == 0\n+    assert \"ssl_cert\" in issues.errors[0].field\n+    assert \"ssl_key\" in issues.errors[1].field\n", "problem_statement": "Support production environment for taipy-rest\n- Support changing port and host from Config (maybe a new Rest section) and CLI\n", "hints_text": "Hello! Could I get this issue assigned to me?\n@imkrishnasarathi, I am assigning you to this issue; thank you for your contribution. If you need more help, you can ask @jrobinAV. \n### ![New Quest! image](https://quine-assets.s3.amazonaws.com/assets/quest-bot/quest-generic/opening28.svg) New Quest!\n\n*A new Quest has been launched in @Avaiga\u2019s repo.\nMerge a PR that solves this issue to loot the Quest and earn your reward.*\n\n---\n\nSome loot has been stashed in this issue to reward the solver!\n\n\ud83d\udde1 Comment `@quest-bot embark` to check-in for this Quest and start solving the issue. Other solvers will be notified!\n\n\u2694\ufe0f When you submit a PR, comment `@quest-bot loot #421` to link your PR to this Quest.\n\nQuestions? Check out [the docs](https://docs.quira.sh/for-developers/quests/solver-quests).\n@quest-bot embark\r\n\nHey @imkrishnasarathi\n\nUnfortunately, we\u2019ve encountered an internal error and we couldn\u2019t handle your request \ud83e\udd15\n\n**We've been alerted and we'll fix this ASAP**.\n\nContact us at help@quira.sh if you need further assistance.\n\nApologies for any inconveniences \ud83d\ude4f\n@quest-bot embark\n@imkrishnasarathi has embarked on their Quest. \ud83d\udde1\n\n- @imkrishnasarathi has been on GitHub since **2021**.\n- They have merged **15** public PRs in that time.\n- Their swords are blessed with `CSS` and `TypeScript` magic \u2728\n- They haven't contributed to this repo before.\n\nQuestions? Check out [the docs](https://docs.quira.sh/for-developers/quests/solver-quests).\nHello! May I ask how do I test if everything's working fine after I finished writing the code ?\nHey @jrobinAV ! I am getting this error from I file which I haven't altered at all when I run the test_run.py file:\r\n![image](https://github.com/user-attachments/assets/f480fa92-4837-4265-a088-bf099601fb0d)\r\n\nThis issue has been labelled as \"\ud83e\udd76Waiting for contributor\" because it has been inactive for more than 14 days. If you would like to continue working on this issue, please add another comment or create a PR that links to this issue. If a PR has already been created which refers to this issue, then you should explicitly mention this issue in the relevant PR. Otherwise, you will be unassigned in 14 days. For more information please refer to the contributing guidelines.\nThis issue has been unassigned automatically because it has been marked as \"\ud83e\udd76Waiting for contributor\" for more than 14 days with no activity.", "created_at": "2025-01-29T00:49:59Z"}
{"repo": "Avaiga/taipy", "pull_number": 2429, "instance_id": "Avaiga__taipy-2429", "issue_numbers": ["2376"], "base_commit": "60556b935d76f567409fd03f980d795c272cc0fb", "patch": "diff --git a/taipy/gui/_renderers/_markdown/factory.py b/taipy/gui/_renderers/_markdown/factory.py\nindex fa47e3baf6..a00afb8bac 100644\n--- a/taipy/gui/_renderers/_markdown/factory.py\n+++ b/taipy/gui/_renderers/_markdown/factory.py\n@@ -22,11 +22,11 @@ class _MarkdownFactory(_Factory):\n     _TAIPY_BLOCK_TAGS = [\"layout\", \"part\", \"expandable\", \"dialog\", \"pane\"]\n \n     @staticmethod\n-    def create_element(gui, control_type: str, all_properties: str) -> t.Union[t.Any, str]:\n+    def create_element(gui, element_type: str, all_properties: str) -> t.Union[t.Any, str]:\n         # Create properties dict from all_properties\n         property_pairs = _Factory._PROPERTY_RE.findall(all_properties)\n         properties = {property[0]: property[1] for property in property_pairs}\n-        builder_md = _Factory.call_builder(gui, control_type, properties)\n+        builder_md = _Factory.call_builder(gui, element_type, properties)\n         if builder_md is None:\n-            return f\"<|INVALID SYNTAX - Control is '{control_type}'|>\"\n+            return f\"<|UNKNOWN ELEMENT TYPE '{element_type}'|>\"\n         return builder_md\ndiff --git a/taipy/gui/utils/_adapter.py b/taipy/gui/utils/_adapter.py\nindex 8a2de2d802..55faf411bf 100644\n--- a/taipy/gui/utils/_adapter.py\n+++ b/taipy/gui/utils/_adapter.py\n@@ -70,7 +70,8 @@ def run(self, var_name: str, value: t.Any, id_only=False) -> t.Any:\n         adapter = self.__get_for_var(var_name, value)\n         if isclass(lov) and issubclass(lov, Enum):\n             lov = list(lov)\n-        if isinstance(lov, (list, tuple)):\n+        # list or Lov value\n+        if isinstance(lov, list) or (isinstance(lov, tuple) and not id_only):\n             res = []\n             for elt in lov:\n                 v = self._run(adapter, elt, var_name, id_only)\n", "test_patch": "diff --git a/tests/gui/renderers/test_md_parsing.py b/tests/gui/renderers/test_md_parsing.py\nindex fcb7d436d7..62877cc344 100644\n--- a/tests/gui/renderers/test_md_parsing.py\n+++ b/tests/gui/renderers/test_md_parsing.py\n@@ -14,7 +14,7 @@\n \n def test_invalid_control_name(gui: Gui, helpers):\n     md_string = \"<|invalid|invalid|>\"\n-    expected_list = [\"INVALID SYNTAX - Control is 'invalid'\"]\n+    expected_list = [\"UNKNOWN ELEMENT TYPE 'invalid'\"]\n     helpers.test_control_md(gui, md_string, expected_list)\n \n \n", "problem_statement": "[\ud83d\udc1b BUG] Slider with tuple lov forced into multi-selection\n### What went wrong? \ud83e\udd14\n\nPrevious demonstrated this in #2290.\r\n\r\nCode example:\r\n\r\n```python\r\nfrom taipy.gui import Gui, Icon\r\nimport taipy.gui.builder as tgb\r\n\r\naggregation_list = [(\"minute\", \"Minute\"), (\"hour\", \"Hour\"), (\"day\", \"Day\"), (\"week\", \"Week\")]\r\nselected_aggregation = aggregation_list[0]\r\n\r\nwith tgb.Page() as page:\r\n    tgb.text(\"# Single selection for list[tuple[str, str | Icon]] lov\", mode=\"md\")\r\n    tgb.slider(\"{selected_aggregation}\", lov=\"{aggregation_list}\", value_by_id=False)\r\n    tgb.text(\"{selected_aggregation}\")\r\n\r\ndef on_change(state, var_name, var_value):\r\n    print(var_name, type(var_value), var_value)\r\n\r\nif __name__ == \"__main__\":\r\n    gui = Gui(page=page)\r\n    gui.run(run_browser=False, use_reloader=True)\r\n```\r\n\r\nVideo:\r\n\r\nhttps://github.com/user-attachments/assets/2337d348-3379-4ab1-8dfd-a1e33d474f98\r\n\r\n\r\n\n\n### Expected Behavior\n\nSlider should be single-select.\r\n\r\nFor multi-selection, `selected_aggregation` should have been initialized to a list (e.g. `[]` or `aggregation_list[:2]`).\r\n\n\n### Browsers\n\nChrome\n\n### OS\n\nWindows, Linux\n\n### Version of Taipy\n\ndevelop\n\n### Acceptance Criteria\n\n- [ ] A unit test reproducing the bug is added.\r\n- [ ] Any new code is covered by a unit tested.\r\n- [ ] Check code coverage is at least 90%.\r\n- [ ] The bug reporter validated the fix.\r\n- [ ] Related issue(s) in taipy-doc are created for documentation and Release Notes are updated.\r\n\n\n### Code of Conduct\n\n- [X] I have checked the [existing issues](https://github.com/Avaiga/taipy/issues?q=is%3Aissue+).\n- [ ] I am willing to work on this issue (optional)\n", "hints_text": "@arcanaxion I would like to pick this issue.\n@xyfer17 I'm not a maintainer of this project. I'm just here to complain and open issues \ud83d\ude04 \nThis hasn't been yet seen by the maintainers. We should be able to get back on this soon\n", "created_at": "2025-01-28T15:48:22Z"}
{"repo": "Avaiga/taipy", "pull_number": 2428, "instance_id": "Avaiga__taipy-2428", "issue_numbers": ["2420"], "base_commit": "60556b935d76f567409fd03f980d795c272cc0fb", "patch": "diff --git a/taipy/core/_version/_version_manager.py b/taipy/core/_version/_version_manager.py\nindex f49af7dab6..93660edb82 100644\n--- a/taipy/core/_version/_version_manager.py\n+++ b/taipy/core/_version/_version_manager.py\n@@ -136,8 +136,13 @@ def _replace_version_number(cls, version_number: Optional[str] = None):\n             return \"\"\n \n         try:\n-            if version := cls._get(version_number):\n-                return version.id\n+            if version_number == cls._get_development_version():\n+                if cls._exists(version_number):\n+                    return version_number\n+            else:\n+                if cls._get(version_number):\n+                    return version_number\n+\n         except InconsistentEnvVariableError:  # The version exist but the Config is alternated\n             return version_number\n         except ConfigCoreVersionMismatched as e:\n@@ -183,6 +188,9 @@ def _manage_version(cls) -> None:\n                 cls._set_experiment_version(current_version_number, Config.core.force)\n             except VersionAlreadyExistsAsDevelopment as err:\n                 raise SystemExit(err.message) from None\n+            except ConfigCoreVersionMismatched as e:\n+                cls._logger.error(e.message)\n+                raise SystemExit() from e\n \n         else:\n             raise SystemExit(f\"Undefined execution mode: {Config.core.mode}.\")\n", "test_patch": "diff --git a/tests/core/config/test_core_version.py b/tests/core/config/test_core_version.py\nindex 03a8d8e3d9..6a18c091c0 100644\n--- a/tests/core/config/test_core_version.py\n+++ b/tests/core/config/test_core_version.py\n@@ -14,24 +14,30 @@\n import pytest\n \n from taipy.common.config import Config\n+from taipy.core import Orchestrator, taipy\n from taipy.core._init_version import _read_version\n from taipy.core.config.core_section import CoreSection\n from taipy.core.exceptions import ConfigCoreVersionMismatched\n+from taipy.core.scenario._scenario_manager import _ScenarioManager\n from tests.core.utils.named_temporary_file import NamedTemporaryFile\n \n _MOCK_CORE_VERSION = \"3.1.1\"\n \n \n+def patch_core_version(mock_core_version: str):\n+    with mock.patch(\"taipy.core.config.core_section._read_version\") as mock_read_version:\n+        mock_read_version.return_value = mock_core_version\n+\n+    CoreSection._CURRENT_CORE_VERSION = mock_core_version\n+    Config._default_config._unique_sections[CoreSection.name] = CoreSection.default_config()\n+    Config._python_config._unique_sections[CoreSection.name] = CoreSection.default_config()\n+\n+\n @pytest.fixture(scope=\"function\", autouse=True)\n def mock_core_version():\n-    with mock.patch(\"taipy.core.config.core_section._read_version\") as mock_read_version:\n-        mock_read_version.return_value = _MOCK_CORE_VERSION\n-        CoreSection._CURRENT_CORE_VERSION = _MOCK_CORE_VERSION\n-        Config.unique_sections[CoreSection.name] = CoreSection.default_config()\n-        Config._default_config._unique_sections[CoreSection.name] = CoreSection.default_config()\n-        Config._python_config._unique_sections[CoreSection.name] = CoreSection.default_config()\n+    patch_core_version(_MOCK_CORE_VERSION)\n \n-        yield\n+    yield\n \n     CoreSection._CURRENT_CORE_VERSION = _read_version()\n \n@@ -137,3 +143,57 @@ def test_load_configuration_file_without_core_section(self):\n         )\n         Config.load(file_config.filename)\n         assert Config.unique_sections[CoreSection.name]._core_version == _MOCK_CORE_VERSION\n+\n+    def test_run_core_app_with_different_taipy_core_version_in_development_mode(self):\n+        with mock.patch(\"sys.argv\", [\"prog\", \"--development\"]):\n+            run_application()\n+\n+        # Run the application with a compatible version should NOT raise any error\n+        patch_core_version(f\"{self.major}.{self.minor}.{self.patch}.dev0\")\n+        with mock.patch(\"sys.argv\", [\"prog\", \"--development\"]):\n+            run_application()\n+\n+        # Run the application with an incompatible version in development mode should NOT raise an error\n+        patch_core_version(f\"{self.major}.{int(self.minor) + 1}.{self.patch}.dev0\")\n+        with mock.patch(\"sys.argv\", [\"prog\", \"--development\"]):\n+            run_application()\n+\n+    def test_run_core_app_with_different_taipy_core_version_in_experiment_mode(self, caplog):\n+        with mock.patch(\"sys.argv\", [\"prog\", \"--experiment\", \"1.0\"]):\n+            run_application()\n+\n+        # Run the application with a compatible version should not raise any error\n+        patch_core_version(f\"{self.major}.{self.minor}.{int(self.patch) + 1}.dev0\")\n+        with mock.patch(\"sys.argv\", [\"prog\", \"--experiment\", \"1.0\"]):\n+            run_application()\n+\n+        # Run the application with an incompatible version in experiment mode should raise SystemExit and log the error\n+        patch_core_version(f\"{self.major}.{int(self.minor) + 1}.{self.patch}.dev0\")\n+        with mock.patch(\"sys.argv\", [\"prog\", \"--experiment\", \"1.0\"]):\n+            with pytest.raises(SystemExit):\n+                run_application()\n+        assert (\n+            f\"The version {self.major}.{self.minor}.{self.patch} of Taipy's entities does not match version \"\n+            f\"of the Taipy Version management {self.major}.{int(self.minor) + 1}.{self.patch}.dev0\"\n+        ) in caplog.text\n+\n+\n+def twice(a):\n+    return [a * 2]\n+\n+\n+def run_application():\n+    Config.configure_data_node(id=\"d0\")\n+    data_node_1_config = Config.configure_data_node(id=\"d1\", storage_type=\"pickle\", default_data=\"abc\")\n+    data_node_2_config = Config.configure_data_node(id=\"d2\", storage_type=\"csv\")\n+    task_config = Config.configure_task(\"my_task\", twice, data_node_1_config, data_node_2_config)\n+    scenario_config = Config.configure_scenario(\"my_scenario\", [task_config])\n+    scenario_config.add_sequences({\"my_sequence\": [task_config]})\n+\n+    orchestrator = Orchestrator()\n+    orchestrator.run()\n+\n+    scenario = _ScenarioManager._create(scenario_config)\n+    taipy.submit(scenario)\n+\n+    orchestrator.stop()\n", "problem_statement": "Why Taipy is blocking config update in development version\n### Description\n\nI am in development version. I don't want to keep my .taipy and files generated by user_data.\n \nI change from a Taipy version to another but receive this message:\n\n```\n[2025-01-22 11:11:00.209][Taipy][ERROR] The version 4.1.0.dev0 of Taipy's entities does not match version of the Taipy Version management 4.0.2. Please update the core entities to be compatible with Taipy Core 4.0.2 using the `taipy migrate ...` command. For more information, please run `taipy help migrate`\n```\n\nWhy Taipy is blocking config update in development version?\n\n### Acceptance Criteria\n\n- [ ] Any new code is covered by a unit tested.\n- [ ] Check code coverage is at least 90%.\n\n\n### Code of Conduct\n\n- [x] I have checked the [existing issues](https://github.com/Avaiga/taipy/issues?q=is%3Aissue+).\n- [ ] I am willing to work on this issue (optional)\n", "hints_text": "@jrobinAV @FlorianJacta This is happening because of the `ConfigCoreVersionMismatched` exception is raised here because of the `_check_compatibility()` method.\n\nShould we skip the `_check_compatibility()` method when in development mode?\nThe `ConfigCoreVersionMismatched` exception is raised before the `clean_all_entity_by_version()` method, which is trying to load the old _Version entity and the old Config.\n\nProposal:\nUpdate the `_version_manager.py` lines 138 - 149 to:\n```python\n        try:\n            if version_number == cls._get_development_version():\n                if cls._exists(version_number):\n                    return version_number\n            else:\n                if cls._get(version_number):\n                    return version_number\n        except InconsistentEnvVariableError:  # The version exist but the Config is alternated\n            return version_number\n        except ConfigCoreVersionMismatched as e:\n            cls._logger.error(e.message)\n            raise SystemExit() from e\n```\n\nThe main difference is only calling the `_get` when it's not development mode, otherwise call the `_exists` method\nTo test the problem:\n\n1. Install taipy 4.0.0\n2. Run an application that create some entities in taipy 4.0.0 in both development mode and experiment mode (so we have entities for both dev and experiment versions)\n3. Install taipy 4.1.0.dev1\n4. Rerun the application in development mode. For the current code, it will log an error.\n    - Expected behavior: The application should run\n6. Rerun the application in experiment mode. For the current code, the exception is raised with the whole backlog\n    - Expected behavior: The error should be logged properly.", "created_at": "2025-01-28T10:09:41Z"}
{"repo": "Avaiga/taipy", "pull_number": 2423, "instance_id": "Avaiga__taipy-2423", "issue_numbers": ["2322"], "base_commit": "d7d82e159974ba9048016d5e829c1c7e98796bdf", "patch": "diff --git a/taipy/core/scenario/scenario.py b/taipy/core/scenario/scenario.py\nindex bdb5652963..1a7c391410 100644\n--- a/taipy/core/scenario/scenario.py\n+++ b/taipy/core/scenario/scenario.py\n@@ -17,6 +17,7 @@\n import networkx as nx\n \n from taipy.common.config.common._validate_id import _validate_id\n+from taipy.common.logger._taipy_logger import _TaipyLogger\n \n from .._entity._entity import _Entity\n from .._entity._labeled import _Labeled\n@@ -106,6 +107,8 @@ def by_two(x: int):\n     id: ScenarioId\n     \"\"\"The unique identifier of this scenario.\"\"\"\n \n+    _logger = _TaipyLogger._get_logger()\n+\n     def __init__(\n         self,\n         config_id: str,\n@@ -611,12 +614,32 @@ def _is_consistent(self) -> bool:\n         if dag.number_of_nodes() == 0:\n             return True\n         if not nx.is_directed_acyclic_graph(dag):\n+            self._logger.error(f'The DAG of scenario \"{self.id}\" is not a directed acyclic graph')\n             return False\n         for left_node, right_node in dag.edges:\n             if (isinstance(left_node, DataNode) and isinstance(right_node, Task)) or (\n                 isinstance(left_node, Task) and isinstance(right_node, DataNode)\n             ):\n                 continue\n+\n+            left_node_desc = (\n+                f'{left_node.__class__.__name__} \"{left_node.get_label()}\"'\n+                if isinstance(left_node, _Labeled)\n+                else left_node.__class__.__name__\n+                if left_node\n+                else \"None\"\n+            )\n+            right_node_desc = (\n+                f'{right_node.__class__.__name__} \"{right_node.get_label()}\"'\n+                if isinstance(right_node, _Labeled)\n+                else right_node.__class__.__name__\n+                if right_node\n+                else \"None\"\n+            )\n+            self._logger.error(\n+                f'Invalid edge detected in scenario \"{self.id}\": left node {left_node_desc} and right node '\n+                f\"{right_node_desc} must connect a Task and a DataNode\"\n+            )\n             return False\n         return True\n \ndiff --git a/taipy/core/sequence/sequence.py b/taipy/core/sequence/sequence.py\nindex b07d0e348d..2e8d1c33e7 100644\n--- a/taipy/core/sequence/sequence.py\n+++ b/taipy/core/sequence/sequence.py\n@@ -16,6 +16,7 @@\n import networkx as nx\n \n from taipy.common.config.common._validate_id import _validate_id\n+from taipy.common.logger._taipy_logger import _TaipyLogger\n \n from .._entity._entity import _Entity\n from .._entity._labeled import _Labeled\n@@ -118,6 +119,8 @@ def planning(forecast, capacity):\n     _MANAGER_NAME = \"sequence\"\n     __CHECK_INIT_DONE_ATTR_NAME = \"_init_done\"\n \n+    _logger = _TaipyLogger._get_logger()\n+\n     id: SequenceId\n     \"\"\"The unique identifier of the sequence.\"\"\"\n \n@@ -343,15 +346,37 @@ def _is_consistent(self) -> bool:\n         if dag.number_of_nodes() == 0:\n             return True\n         if not nx.is_directed_acyclic_graph(dag):\n+            self._logger.error(f'The DAG of sequence \"{self.id}\" is not a directed acyclic graph')\n             return False\n         if not nx.is_weakly_connected(dag):\n+            self._logger.error(f'The DAG of sequence \"{self.id}\" is not weakly connected')\n             return False\n         for left_node, right_node in dag.edges:\n             if (isinstance(left_node, DataNode) and isinstance(right_node, Task)) or (\n                 isinstance(left_node, Task) and isinstance(right_node, DataNode)\n             ):\n                 continue\n+\n+            left_node_desc = (\n+                f'{left_node.__class__.__name__} \"{left_node.get_label()}\"'\n+                if isinstance(left_node, _Labeled)\n+                else left_node.__class__.__name__\n+                if left_node\n+                else \"None\"\n+            )\n+            right_node_desc = (\n+                f'{right_node.__class__.__name__} \"{right_node.get_label()}\"'\n+                if isinstance(right_node, _Labeled)\n+                else right_node.__class__.__name__\n+                if right_node\n+                else \"None\"\n+            )\n+            self._logger.error(\n+                f'Invalid edge detected in sequence \"{self.id}\": left node {left_node_desc} and right node '\n+                f\"{right_node_desc} must connect a Task and a DataNode\"\n+            )\n             return False\n+\n         return True\n \n     def _get_tasks(self) -> Dict[str, Task]:\n", "test_patch": "diff --git a/tests/core/scenario/test_scenario.py b/tests/core/scenario/test_scenario.py\nindex 72899c20ef..515fe369fb 100644\n--- a/tests/core/scenario/test_scenario.py\n+++ b/tests/core/scenario/test_scenario.py\n@@ -1538,3 +1538,25 @@ def test_check_consistency():\n     task_5 = Task(\"bob\", {}, print, [data_node_5], [data_node_3], TaskId(\"t5\"))\n     scenario_9 = Scenario(\"scenario_9\", [task_1, task_2, task_3, task_4, task_5], {}, [], scenario_id=ScenarioId(\"s8\"))\n     assert scenario_9._is_consistent()\n+\n+\n+def test_check_inconsistency(caplog):\n+    class FakeDataNode:\n+        config_id = \"config_id_of_a_fake_dn\"\n+\n+    data_node_1 = InMemoryDataNode(\"foo\", Scope.SCENARIO, \"s1\")\n+    data_node_2 = InMemoryDataNode(\"bar\", Scope.SCENARIO, \"s2\")\n+\n+    task_1 = Task(\"grault\", {}, print, [data_node_1, data_node_2], [FakeDataNode()], TaskId(\"t1\"))\n+    task_2 = Task(\"garply\", {}, print, [data_node_1], [data_node_2], id=TaskId(\"t2\"))\n+    scenario_1 = Scenario(\"scenario_1\", [task_1, task_2], {}, [], scenario_id=ScenarioId(\"s1\"))\n+    assert not scenario_1._is_consistent()\n+    assert (\n+        'Invalid edge detected in scenario \"s1\": left node Task \"grault\" and right node FakeDataNode'\n+        \" must connect a Task and a DataNode\" in caplog.text\n+    )\n+\n+    task_3 = Task(\"waldo\", {}, print, [data_node_2], [data_node_1], id=TaskId(\"t3\"))\n+    scenario_2 = Scenario(\"scenario_2\", [task_2, task_3], {}, [], scenario_id=ScenarioId(\"s2\"))\n+    assert not scenario_2._is_consistent()\n+    assert 'The DAG of scenario \"s2\" is not a directed acyclic graph' in caplog.text\ndiff --git a/tests/core/sequence/test_sequence.py b/tests/core/sequence/test_sequence.py\nindex 9b78cb53df..f5cb7ca535 100644\n--- a/tests/core/sequence/test_sequence.py\n+++ b/tests/core/sequence/test_sequence.py\n@@ -30,6 +30,10 @@\n from taipy.core.task.task import Task, TaskId\n \n \n+class FakeDataNode:\n+    config_id = \"config_id_of_a_fake_dn\"\n+\n+\n def test_sequence_equals():\n     task_config = Config.configure_task(\"mult_by_3\", print, [], None)\n     scenario_config = Config.configure_scenario(\"scenario\", [task_config])\n@@ -143,7 +147,7 @@ def test_get_set_attribute():\n         sequence.bar = \"KeyAlreadyUsed\"\n \n \n-def test_check_consistency():\n+def test_check_consistency(caplog):\n     sequence_1 = Sequence({}, [], \"name_1\")\n     assert sequence_1._is_consistent()\n \n@@ -157,6 +161,7 @@ def test_check_consistency():\n     task_3 = Task(\"tfoo\", {}, print, [data_node_3], [data_node_3], TaskId(\"task_id_3\"))\n     sequence_3 = Sequence({}, [task_3], \"name_3\")\n     assert not sequence_3._is_consistent()  # Not a dag\n+    assert 'The DAG of sequence \"name_3\" is not a directed acyclic graph' in caplog.text\n \n     input_4 = InMemoryDataNode(\"foo\", Scope.SCENARIO)\n     output_4 = InMemoryDataNode(\"bar\", Scope.SCENARIO)\n@@ -164,9 +169,7 @@ def test_check_consistency():\n     task_4_2 = Task(\"tbar\", {}, print, [output_4], [input_4], TaskId(\"task_id_4_2\"))\n     sequence_4 = Sequence({}, [task_4_1, task_4_2], \"name_4\")\n     assert not sequence_4._is_consistent()  # Not a Dag\n-\n-    class FakeDataNode:\n-        config_id = \"config_id_of_a_fake_dn\"\n+    assert 'The DAG of sequence \"name_4\" is not a directed acyclic graph' in caplog.text\n \n     input_6 = DataNode(\"foo\", Scope.SCENARIO, \"input_id_5\")\n     output_6 = DataNode(\"bar\", Scope.SCENARIO, \"output_id_5\")\n@@ -174,6 +177,10 @@ class FakeDataNode:\n     task_6_2 = Task(\"tbar\", {}, print, [output_6], [FakeDataNode()], TaskId(\"task_id_5_2\"))\n     sequence_6 = Sequence({}, [task_6_1, task_6_2], \"name_5\")\n     assert not sequence_6._is_consistent()  # Not a DataNode\n+    assert (\n+        'Invalid edge detected in sequence \"name_5\": left node Task \"tbar\" and right node FakeDataNode '\n+        \"must connect a Task and a DataNode\" in caplog.text\n+    )\n \n     intermediate_7 = DataNode(\"foo\", Scope.SCENARIO, \"intermediate_id_7\")\n     output_7 = DataNode(\"bar\", Scope.SCENARIO, \"output_id_7\")\n@@ -197,6 +204,7 @@ class FakeDataNode:\n     task_9_2 = Task(\"tbar\", {}, print, [input_9_2], [output_9_2], TaskId(\"task_id_9_2\"))\n     sequence_9 = Sequence({}, [task_9_1, task_9_2], \"name_9\")\n     assert not sequence_9._is_consistent()  # Not connected\n+    assert 'The DAG of sequence \"name_9\" is not weakly connected' in caplog.text\n \n     input_10_1 = DataNode(\"foo\", Scope.SCENARIO, \"output_id_10_1\")\n     intermediate_10_1 = DataNode(\"bar\", Scope.SCENARIO, \"intermediate_id_10_1\")\n", "problem_statement": "[Refactor] Informative error messages on Scenario build failure\n### Description\n\nThe error message `raise InvalidScenario(scenario.id)`  when scenario building fails is not very informative, because it leads to something like:\r\n```\r\ntaipy.core.exceptions.exceptions.InvalidScenario: SCENARIO_MS_analysis_afc4e19b-be39-4651-bc9d-11f7807fd3af\r\n```\r\nwith Traceback pointing only at the Scenario Factory.\r\n\r\n\r\nI suggest adding a warning to \r\nhttps://github.com/Avaiga/taipy/blob/9cc59f2fbd5ed3d261905923a9cb85dcd623e3f3/taipy/core/scenario/scenario.py#L608-L621\r\n\r\nlike:\r\n```python\r\nimport warnings\r\nwarnings.warn( f\"Graph directed: {nx.is_directed( dag )}, Cycle found at: {nx.cycles.find_cycle( dag )}\" )\r\n```\r\nand\r\n```python\r\nif not (isinstance(left_node, DataNode) and isinstance(right_node, Task)) and \r\n   not (isinstance(left_node, Task) and isinstance(right_node, DataNode) ):\r\n    warnings.warn(f\"Edge between left node:{left_node.get_label()} and right node:{right_node.get_label()} does not connect {Task} and {DataNode}\")\r\n    return False\r\n```\n\n### Acceptance Criteria\n\n- [ ] Any new code is covered by a unit tested.\r\n- [ ] Check code coverage is at least 90%.\r\n\n\n### Code of Conduct\n\n- [X] I have checked the [existing issues](https://github.com/Avaiga/taipy/issues?q=is%3Aissue+).\n- [X] I am willing to work on this issue (optional)\n", "hints_text": "Hello @JosuaCarl \r\n\r\nThank you for your issue. It's a great idea. Would you like to be assigned?\r\n\r\nA few minor remarks:\r\n\r\n1. In Taipy, we handle logs with a logger that you can retrieve using the following code:\r\n    ```python\r\n    from taipy.common.logger._taipy_logger import _TaipyLogger\r\n\r\n    _logger = _TaipyLogger._get_logger()\r\n\r\n    _logger.error(\"My error message!\")\r\n    _logger.warning(\"My warning.\")\r\n    _logger.info(\"My info\")\r\n    ```\r\n\r\n2. They should be error messages and not warnings. Especially because we raise an exception in case it is inconsistent.\r\n \r\n3. We have a similar but slightly different piece of code for sequences. It should be covered by the issue as well. https://github.com/Avaiga/taipy/blob/9cc59f2fbd5ed3d261905923a9cb85dcd623e3f3/taipy/core/sequence/sequence.py#L341-L355\r\n\nYes, I would like to be assigned. Although I am not sure how much I will be able to do until the new year.\n> Yes, I would like to be assigned. Although I am not sure how much I will be able to do until the new year.\r\n\r\nThanks a lot! Don't worry, we are not in a rush for this issue.\nSmall question before I start:\r\nThe purpose of the `_is_constent` method is to evaluate consistency and return it. I suggested a warning, in order to enable the code to finish and pass on a boolean value (which is expected by following methods). Should I refactor the methods, that rely on `_is_constent`, such that an error is watched and raised later , resulting in equation to `False` or should the `_is_constent` method itself serve as the main Error handler, such that it can called without expecting a return and the code simply continues on, when no Error is raised ?\nThat's a good question. \r\n\r\nI would keep the current behavior for both `is_consistent` methods. They should still return a boolean. The only difference would be that they log a meaningful error before returning False.\r\nAnd we let the responsibility of raising an exception or not to the piece of code that calls the `is_consistent` method.\nThis issue has been labelled as \"\ud83e\udd76Waiting for contributor\" because it has been inactive for more than 14 days. If you would like to continue working on this issue, please add another comment or create a PR that links to this issue. If a PR has already been created which refers to this issue, then you should explicitly mention this issue in the relevant PR. Otherwise, you will be unassigned in 14 days. For more information please refer to the contributing guidelines.\nThis issue has been unassigned automatically because it has been marked as \"\ud83e\udd76Waiting for contributor\" for more than 14 days with no activity.", "created_at": "2025-01-23T09:38:34Z"}
{"repo": "Avaiga/taipy", "pull_number": 2404, "instance_id": "Avaiga__taipy-2404", "issue_numbers": ["2118"], "base_commit": "d7d82e159974ba9048016d5e829c1c7e98796bdf", "patch": "diff --git a/.coveragerc b/.coveragerc\nnew file mode 100644\nindex 0000000000..5dc3069f51\n--- /dev/null\n+++ b/.coveragerc\n@@ -0,0 +1,8 @@\n+[run]\n+omit =\n+    tests/*\n+\n+[report]\n+exclude_lines =\n+    # Ignore pragma: no cover comments\n+    pragma: no cover\ndiff --git a/pyproject.toml b/pyproject.toml\nindex 943381566e..837001344a 100644\n--- a/pyproject.toml\n+++ b/pyproject.toml\n@@ -51,6 +51,7 @@ exclude = [\n     \"build\",\n     \"dist\",\n     \"releases\",\n+    \"tools\",\n     \".venv\",\n     \".mypy_cache\",\n     \".pytest_cache\",\ndiff --git a/tools/coverage_check.py b/tools/coverage_check.py\nnew file mode 100644\nindex 0000000000..4cd307d14b\n--- /dev/null\n+++ b/tools/coverage_check.py\n@@ -0,0 +1,101 @@\n+# Copyright 2021-2025 Avaiga Private Limited\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+# the License. You may obtain a copy of the License at\n+#\n+#        http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+# an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+# specific language governing permissions and limitations under the License.\n+\n+import argparse\n+import xmltodict\n+import sys\n+import subprocess\n+\n+\n+def check_total_coverage(coverage_file, threshold=80):\n+    \"\"\"Check the total project coverage.\"\"\"\n+    with open(coverage_file) as f:\n+        data = xmltodict.parse(f.read())\n+    total_coverage = float(data['coverage']['@line-rate']) * 100\n+    print(f\"Total Coverage: {total_coverage:.2f}%\")\n+    if total_coverage < threshold:\n+        print(f\"Total project coverage is below {threshold}%: {total_coverage:.2f}%\")\n+        sys.exit(1)\n+\n+\n+def check_changed_files_coverage(coverage_file, changed_files, threshold=80):\n+    \"\"\"Check the coverage of changed files.\"\"\"\n+    with open(coverage_file) as f:\n+        data = xmltodict.parse(f.read())\n+\n+    # Handle multiple packages in the coverage report\n+    packages = data[\"coverage\"][\"packages\"][\"package\"]\n+    if not isinstance(packages, list):\n+        packages = [packages]\n+\n+    # Extract coverage data for all files\n+    files = {}\n+    for package in packages:\n+        classes = package[\"classes\"][\"class\"]\n+        if not isinstance(classes, list):\n+            classes = [classes]\n+        for cls in classes:\n+            files[cls[\"@filename\"]] = float(cls[\"@line-rate\"]) * 100\n+    qty = 0\n+    sum_coverage = 0\n+    for file in changed_files:\n+        if file in files:\n+            coverage = files[file]\n+            print(f\"Coverage for {file}: {coverage:.2f}%\")\n+            sum_coverage += coverage\n+            qty += 1\n+        else:\n+            print(f\"No coverage data found for {file}\")\n+\n+    if sum_coverage/qty < threshold:\n+        print(f\"Coverage for changed files is below {threshold}%: {sum_coverage/qty:.2f}%\")\n+        sys.exit(1)\n+    print(f\"Coverage for changed files: {sum_coverage/qty:.2f}%\")\n+\n+\n+def get_changed_files(base_branch):\n+    \"\"\"Get the list of changed Python files in the pull request.\"\"\"\n+    try:\n+        result = subprocess.run(\n+            ['git', 'diff', '--name-only', f\"origin/{base_branch}\", '--', '*.py'],\n+            capture_output=True,\n+            text=True,\n+            check=True,\n+        )\n+        changed_files = [\n+            file.replace(\"taipy/\", \"\") for file in result.stdout.strip().splitlines() if not file.startswith(('tests/', 'tools/'))\n+        ]\n+        return changed_files\n+    except subprocess.CalledProcessError as e:\n+        print(f\"Error fetching changed files: {e}\")\n+        sys.exit(1)\n+\n+\n+if __name__ == '__main__':\n+    parser = argparse.ArgumentParser(description=\"Coverage check script.\")\n+    parser.add_argument('command', choices=['check-total', 'check-changed'], help=\"Command to execute\")\n+    parser.add_argument('--coverage-file', default='coverage.xml', help=\"Path to the coverage XML file\")\n+    parser.add_argument('--threshold', type=float, default=80, help=\"Coverage threshold percentage\")\n+    parser.add_argument('--base-branch', help=\"Base branch for comparing changed files\")\n+\n+    args = parser.parse_args()\n+\n+    if args.command == 'check-total':\n+        check_total_coverage(args.coverage_file, args.threshold)\n+    elif args.command == 'check-changed':\n+        if not args.base_branch:\n+            print(\"Error: --base-branch is required for check-changed\")\n+            sys.exit(1)\n+        changed_files = get_changed_files(args.base_branch)\n+        if not changed_files:\n+            print(\"No relevant Python files changed.\")\n+            sys.exit(0)\n+        check_changed_files_coverage(args.coverage_file, changed_files, args.threshold)\n", "test_patch": "diff --git a/.github/workflows/overall-tests.yml b/.github/workflows/overall-tests.yml\nindex ccf20c23cb..a396c3ef94 100644\n--- a/.github/workflows/overall-tests.yml\n+++ b/.github/workflows/overall-tests.yml\n@@ -20,9 +20,12 @@ jobs:\n   coverage:\n     timeout-minutes: 50\n     runs-on: ubuntu-latest\n+\n     if: github.event_name == 'pull_request' && github.event.pull_request.base.repo.full_name == github.event.pull_request.head.repo.full_name\n     steps:\n       - uses: actions/checkout@v4\n+        with:\n+          fetch-depth: 0  # Fetch full history to enable proper diff\n \n       - uses: actions/setup-python@v5\n         with:\n@@ -38,13 +41,22 @@ jobs:\n \n       - name: Pytest\n         run: |\n-          pipenv run pytest --cov=taipy --cov-report=\"xml:overall-coverage.xml\" tests\n+          python -m pip install xmltodict\n+          pipenv run pytest --cov=taipy --cov-report=xml:${{ github.workspace }}/coverage.xml --cov-config=.coveragerc\n \n-      - name: Coverage\n-        uses: orgoro/coverage@v3.1\n-        with:\n-          coverageFile: overall-coverage.xml\n-          token: ${{ secrets.GITHUB_TOKEN }}\n+\n+      - name: Fetch base branch\n+        run: |\n+          git fetch origin ${{ github.event.pull_request.base.ref }}:refs/remotes/origin/${{ github.event.pull_request.base.ref }}\n+\n+\n+      - name: Check total project coverage\n+        run: |\n+          python tools/coverage_check.py check-total --coverage-file ${{ github.workspace }}/coverage.xml --threshold 80\n+\n+      - name: Check pull request coverage\n+        run: |\n+          python tools/coverage_check.py check-changed --coverage-file ${{ github.workspace }}/coverage.xml --threshold 80 --base-branch ${{ github.event.pull_request.base.ref }}\n \n   overall-tests:\n     needs: [partial-tests]\n", "problem_statement": "Allow all actions to be performed on a PR from external contributor\nSome GitHub actions require specific permissions (e.g., coverage requires writing the result as a comment in the PR). These actions cannot be performed on a Pull request from an external contributor.\n\nThis is still a problem when an Avaiga member manually triggers the actions from the PR.\n\n\n\n\n", "hints_text": "At least, we could *not* execute the job/step that we'll know will fail :-)\nI reopened it because I still want to investigate whether coverage can be checked before merging into `develop`.", "created_at": "2025-01-17T00:04:12Z"}
{"repo": "Avaiga/taipy", "pull_number": 2400, "instance_id": "Avaiga__taipy-2400", "issue_numbers": ["2399", "2399"], "base_commit": "0541ed62b3fe1270d4bbff261267c1a668ffbd4f", "patch": "diff --git a/taipy/gui/gui.py b/taipy/gui/gui.py\nindex 9d11e1ee08..641ef279dc 100644\n--- a/taipy/gui/gui.py\n+++ b/taipy/gui/gui.py\n@@ -1948,10 +1948,11 @@ def _is_ui_blocked(self):\n         return _getscopeattr(self, Gui.__UI_BLOCK_NAME, False)\n \n     def __get_on_cancel_block_ui(self, callback: t.Optional[str]):\n-        def _taipy_on_cancel_block_ui(guiApp, id: t.Optional[str], payload: t.Any):\n-            if _hasscopeattr(guiApp, Gui.__UI_BLOCK_NAME):\n-                _setscopeattr(guiApp, Gui.__UI_BLOCK_NAME, False)\n-            guiApp.__on_action(id, {\"action\": callback})\n+        def _taipy_on_cancel_block_ui(a_state: State, id: t.Optional[str], payload: t.Any):\n+            gui_app = a_state.get_gui()\n+            if _hasscopeattr(gui_app, Gui.__UI_BLOCK_NAME):\n+                _setscopeattr(gui_app, Gui.__UI_BLOCK_NAME, False)\n+            gui_app.__on_action(id, {\"action\": callback})\n \n         return _taipy_on_cancel_block_ui\n \n@@ -2391,15 +2392,13 @@ def _hold_actions(\n         callback: t.Optional[t.Union[str, t.Callable]] = None,\n         message: t.Optional[str] = \"Work in Progress...\",\n     ):  # pragma: no cover\n-        action_name = (\n-            callback\n-            if isinstance(callback, str)\n-            else _get_lambda_id(t.cast(LambdaType, callback))\n-            if _is_unnamed_function(callback)\n-            else callback.__name__\n-            if callback is not None\n-            else None\n-        )\n+        if _is_unnamed_function(callback):\n+            action_name = _get_lambda_id(t.cast(LambdaType, callback))\n+            self._bind_var_val(action_name, callback)\n+        else:\n+            action_name = (\n+                callback if isinstance(callback, str) else (callback.__name__ if callback is not None else None)\n+            )\n         func = self.__get_on_cancel_block_ui(action_name)\n         def_action_name = func.__name__\n         _setscopeattr(self, def_action_name, func)\n@@ -2579,7 +2578,11 @@ def __render_page(self, page_name: str) -> t.Any:\n             with self._set_locals_context(context):\n                 self._call_on_page_load(nav_page)\n             return self._server._render(\n-                page._rendered_jsx, page._script_paths if page._script_paths is not None else [], page._style if page._style is not None else \"\", page._head, context # noqa: E501\n+                page._rendered_jsx,\n+                page._script_paths if page._script_paths is not None else [],\n+                page._style if page._style is not None else \"\",\n+                page._head,\n+                context,  # noqa: E501\n             )\n         else:\n             return (\"No page template\", 404)\ndiff --git a/taipy/gui/utils/callable.py b/taipy/gui/utils/callable.py\nindex e5c47c37a4..40586f3c6a 100644\n--- a/taipy/gui/utils/callable.py\n+++ b/taipy/gui/utils/callable.py\n@@ -11,7 +11,6 @@\n \n import typing as t\n from inspect import isclass\n-from types import LambdaType\n \n \n def _is_function(s: t.Any) -> bool:\n@@ -28,4 +27,4 @@ def _function_name(s: t.Any) -> str:\n \n \n def _is_unnamed_function(s: t.Any):\n-    return isinstance(s, LambdaType) or (callable(s) and not hasattr(s, \"__name__\"))\n+    return (hasattr(s, \"__name__\") and s.__name__ == \"<lambda>\") or (callable(s) and not hasattr(s, \"__name__\"))\n", "test_patch": "diff --git a/tests/gui/gui_specific/test_callable.py b/tests/gui/gui_specific/test_callable.py\nnew file mode 100644\nindex 0000000000..2ac3f6906b\n--- /dev/null\n+++ b/tests/gui/gui_specific/test_callable.py\n@@ -0,0 +1,58 @@\n+# Copyright 2021-2025 Avaiga Private Limited\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+# the License. You may obtain a copy of the License at\n+#\n+#        http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+# an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+# specific language governing permissions and limitations under the License.\n+\n+from taipy.gui.utils.callable import _function_name, _is_function, _is_unnamed_function\n+\n+\n+def my_function():\n+    pass\n+\n+\n+class my_class:\n+    pass\n+\n+\n+class my_callable_class:\n+    def __call__(self):\n+        pass\n+\n+\n+def test__is_unnamed_function():\n+    assert _is_unnamed_function(my_function) is False\n+    assert _is_unnamed_function(lambda x: x) is True\n+    assert _is_unnamed_function(\"a\") is False\n+\n+\n+def test__is_function():\n+    assert _is_function(my_function) is True\n+    assert _is_function(lambda x: x) is True\n+    assert _is_function(\"a\") is False\n+\n+\n+def test__function_name():\n+    assert _function_name(my_function) == \"my_function\"\n+    assert _function_name(lambda x: x) == \"<lambda>\"\n+    assert _function_name(\"a\") == \"a\"\n+    assert _function_name(1) == \"1\"\n+    assert _function_name(1.0) == \"1.0\"\n+    assert _function_name(True) == \"True\"\n+    assert _function_name(False) == \"False\"\n+    assert _function_name(None) == \"None\"\n+    assert _function_name([]) == \"[]\"\n+    assert _function_name({}) == \"{}\"\n+    assert _function_name(set()) == \"set()\"\n+    assert _function_name(tuple()) == \"()\"  # noqa C408\n+    assert _function_name(object) == \"object\"\n+    assert _function_name(object()).startswith(\"<object \")\n+    assert _function_name(my_class) == \"my_class\"\n+    assert _function_name(my_class()).startswith(\"<tests.gui.gui_specific.test_callable.my_class \")\n+    assert _function_name(my_callable_class) == \"my_callable_class\"\n+    assert _function_name(my_callable_class()) == \"<instance of my_callable_class>\"\n", "problem_statement": "[\ud83d\udc1b BUG] Issue with hold_control\n### What went wrong? \ud83e\udd14\n\nCallback of *hold_control* does not seem to be called.\n\n### Expected Behavior\n\nIt should be called and print the correct output.\n\n### Steps to Reproduce Issue\n\nRun this and click on the button. It should print something:\r\n\r\n```python\r\nimport time\r\n\r\nfrom taipy.gui import Gui\r\nfrom taipy.gui import builder as tgb\r\nfrom taipy.gui import hold_control, resume_control\r\n\r\n\r\ndef cancel_callback(state, id):\r\n    print(f\"Callback triggered with id: {id} and state: {state}\")\r\n\r\n\r\ndef callback_with_hold(state):\r\n    hold_control(state, callback=cancel_callback, message=\"waiting\")\r\n    time.sleep(5)\r\n    resume_control(state)\r\n\r\n\r\nwith tgb.Page() as hold_and_resume_page:\r\n    tgb.text(\"# Hold and Resume control\", mode=\"md\")\r\n\r\n    tgb.button(\"trigger callback!\", on_action=callback_with_hold)\r\n\r\nif __name__ == \"__main__\":\r\n    Gui(page=hold_and_resume_page).run(use_reloader=True, dark_mode=False, port=1234)\r\n\r\n```\n\n### Version of Taipy\n\n4.0.2\n\n### Acceptance Criteria\n\n- [ ] A unit test reproducing the bug is added.\r\n- [ ] Any new code is covered by a unit tested.\r\n- [ ] Check code coverage is at least 90%.\r\n- [ ] The bug reporter validated the fix.\r\n- [ ] Related issue(s) in taipy-doc are created for documentation and Release Notes are updated.\r\n\n\n### Code of Conduct\n\n- [X] I have checked the [existing issues](https://github.com/Avaiga/taipy/issues?q=is%3Aissue+).\n- [ ] I am willing to work on this issue (optional)\n[\ud83d\udc1b BUG] Issue with hold_control\n### What went wrong? \ud83e\udd14\n\nCallback of *hold_control* does not seem to be called.\n\n### Expected Behavior\n\nIt should be called and print the correct output.\n\n### Steps to Reproduce Issue\n\nRun this and click on the button. It should print something:\r\n\r\n```python\r\nimport time\r\n\r\nfrom taipy.gui import Gui\r\nfrom taipy.gui import builder as tgb\r\nfrom taipy.gui import hold_control, resume_control\r\n\r\n\r\ndef cancel_callback(state, id):\r\n    print(f\"Callback triggered with id: {id} and state: {state}\")\r\n\r\n\r\ndef callback_with_hold(state):\r\n    hold_control(state, callback=cancel_callback, message=\"waiting\")\r\n    time.sleep(5)\r\n    resume_control(state)\r\n\r\n\r\nwith tgb.Page() as hold_and_resume_page:\r\n    tgb.text(\"# Hold and Resume control\", mode=\"md\")\r\n\r\n    tgb.button(\"trigger callback!\", on_action=callback_with_hold)\r\n\r\nif __name__ == \"__main__\":\r\n    Gui(page=hold_and_resume_page).run(use_reloader=True, dark_mode=False, port=1234)\r\n\r\n```\n\n### Version of Taipy\n\n4.0.2\n\n### Acceptance Criteria\n\n- [ ] A unit test reproducing the bug is added.\r\n- [ ] Any new code is covered by a unit tested.\r\n- [ ] Check code coverage is at least 90%.\r\n- [ ] The bug reporter validated the fix.\r\n- [ ] Related issue(s) in taipy-doc are created for documentation and Release Notes are updated.\r\n\n\n### Code of Conduct\n\n- [X] I have checked the [existing issues](https://github.com/Avaiga/taipy/issues?q=is%3Aissue+).\n- [ ] I am willing to work on this issue (optional)\n", "hints_text": "\n", "created_at": "2025-01-15T09:26:49Z"}
{"repo": "Avaiga/taipy", "pull_number": 2390, "instance_id": "Avaiga__taipy-2390", "issue_numbers": ["2338", "2338"], "base_commit": "b85c290a2df29e66aede94f5585dca7757987b99", "patch": "diff --git a/frontend/taipy-gui/src/components/Taipy/Chart.spec.tsx b/frontend/taipy-gui/src/components/Taipy/Chart.spec.tsx\nindex 0b333f655d..2705cfa790 100644\n--- a/frontend/taipy-gui/src/components/Taipy/Chart.spec.tsx\n+++ b/frontend/taipy-gui/src/components/Taipy/Chart.spec.tsx\n@@ -60,7 +60,7 @@ const chartValue = {\n     },\n };\n const chartConfig = JSON.stringify({\n-    columns: { Day_str: { dfid: \"Day\" }, \"Daily hospital occupancy\": { dfid: \"Daily hospital occupancy\" } },\n+    columns: [{ Day_str: { dfid: \"Day\" }, \"Daily hospital occupancy\": { dfid: \"Daily hospital occupancy\" } }],\n     traces: [[\"Day_str\", \"Daily hospital occupancy\"]],\n     xaxis: [\"x\"],\n     yaxis: [\"y\"],\n@@ -86,7 +86,7 @@ const mapValue = {\n     },\n };\n const mapConfig = JSON.stringify({\n-    columns: { Lat: { dfid: \"Lat\" }, Lon: { dfid: \"Lon\" } },\n+    columns: [{ Lat: { dfid: \"Lat\" }, Lon: { dfid: \"Lon\" } }],\n     traces: [[\"Lat\", \"Lon\"]],\n     xaxis: [\"x\"],\n     yaxis: [\"y\"],\n@@ -173,7 +173,7 @@ describe(\"Chart Component\", () => {\n             payload: { id: \"chart\", names: [\"varName\"], refresh: false },\n             type: \"REQUEST_UPDATE\",\n         });\n-        expect(dispatch).toHaveBeenCalledWith({\n+        await waitFor(() => expect(dispatch).toHaveBeenCalledWith({\n             name: \"data_var\",\n             payload: {\n                 alldata: true,\n@@ -183,7 +183,7 @@ describe(\"Chart Component\", () => {\n                 id: \"chart\",\n             },\n             type: \"REQUEST_DATA_UPDATE\",\n-        });\n+        }));\n     });\n     it(\"dispatch a well formed message on selection\", async () => {\n         const dispatch = jest.fn();\ndiff --git a/frontend/taipy-gui/src/components/Taipy/Chart.tsx b/frontend/taipy-gui/src/components/Taipy/Chart.tsx\nindex bdcc976fdd..86bebfc2ee 100644\n--- a/frontend/taipy-gui/src/components/Taipy/Chart.tsx\n+++ b/frontend/taipy-gui/src/components/Taipy/Chart.tsx\n@@ -60,6 +60,7 @@ interface ChartProp extends TaipyActiveProps, TaipyChangeProps {\n     defaultConfig: string;\n     config?: string;\n     data?: Record<string, TraceValueType>;\n+    //data${number}?: Record<string, TraceValueType>;\n     defaultLayout?: string;\n     layout?: string;\n     plotConfig?: string;\n@@ -69,13 +70,14 @@ interface ChartProp extends TaipyActiveProps, TaipyChangeProps {\n     template?: string;\n     template_Dark_?: string;\n     template_Light_?: string;\n-    //[key: `selected_${number}`]: number[];\n+    //[key: `selected${number}`]: number[];\n     figure?: Array<Record<string, unknown>>;\n     onClick?: string;\n+    dataVarNames?: string;\n }\n \n interface ChartConfig {\n-    columns: Record<string, ColumnDesc>;\n+    columns: Array<Record<string, ColumnDesc>>;\n     labels: string[];\n     modes: string[];\n     types: string[];\n@@ -217,7 +219,7 @@ export const getPlotIndex = (pt: PlotDatum) =>\n         : pt.pointIndex;\n \n const defaultConfig = {\n-    columns: {} as Record<string, ColumnDesc>,\n+    columns: [] as Array<Record<string, ColumnDesc>>,\n     labels: [],\n     modes: [],\n     types: [],\n@@ -285,6 +287,15 @@ const getDataKey = (columns?: Record<string, ColumnDesc>, decimators?: string[])\n     return [backCols, backCols.join(\"-\") + (decimators ? `--${decimators.join(\"\")}` : \"\")];\n };\n \n+const isDataRefresh = (data?: Record<string, TraceValueType>) => data?.__taipy_refresh !== undefined;\n+const getDataVarName = (updateVarName: string | undefined, dataVarNames: string[], idx: number) =>\n+    idx === 0 ? updateVarName : dataVarNames[idx - 1];\n+const getData = (\n+    data: Record<string, TraceValueType>,\n+    additionalDatas: Array<Record<string, TraceValueType>>,\n+    idx: number\n+) => (idx === 0 ? data : (idx <= additionalDatas.length ? additionalDatas[idx - 1]: undefined));\n+\n const Chart = (props: ChartProp) => {\n     const {\n         title = \"\",\n@@ -301,18 +312,36 @@ const Chart = (props: ChartProp) => {\n     const dispatch = useDispatch();\n     const [selected, setSelected] = useState<number[][]>([]);\n     const plotRef = useRef<HTMLDivElement>(null);\n-    const [dataKey, setDataKey] = useState(\"__default__\");\n+    const [dataKeys, setDataKeys] = useState<string[]>([]);\n     const lastDataPl = useRef<Data[]>([]);\n     const theme = useTheme();\n     const module = useModule();\n \n-    const refresh = useMemo(() => (data?.__taipy_refresh !== undefined ? nanoid() : false), [data]);\n     const className = useClassNames(props.libClassName, props.dynamicClassName, props.className);\n     const active = useDynamicProperty(props.active, props.defaultActive, true);\n     const render = useDynamicProperty(props.render, props.defaultRender, true);\n     const hover = useDynamicProperty(props.hoverText, props.defaultHoverText, undefined);\n     const baseLayout = useDynamicJsonProperty(props.layout, props.defaultLayout || \"\", emptyLayout);\n \n+    const dataVarNames = useMemo(() => (props.dataVarNames ? props.dataVarNames.split(\";\") : []), [props.dataVarNames]);\n+    const oldAdditionalDatas = useRef<Array<Record<string, TraceValueType>>>([]);\n+    const additionalDatas = useMemo(() => {\n+        const newAdditionalDatas = dataVarNames.map(\n+            (_, idx) => (props as unknown as Record<string, Record<string, TraceValueType>>)[`data${idx + 1}`]\n+        );\n+        if (newAdditionalDatas.length !== oldAdditionalDatas.current.length) {\n+            oldAdditionalDatas.current = newAdditionalDatas;\n+        } else if (!newAdditionalDatas.every((d, idx) => d === oldAdditionalDatas.current[idx])) {\n+            oldAdditionalDatas.current = newAdditionalDatas;\n+        }\n+        return oldAdditionalDatas.current;\n+    }, [dataVarNames, props]);\n+\n+    const refresh = useMemo(\n+        () => (isDataRefresh(data) || additionalDatas.some((d) => isDataRefresh(d)) ? nanoid() : false),\n+        [data, additionalDatas]\n+    );\n+\n     // get props.selected[i] values\n     useEffect(() => {\n         if (props.figure) {\n@@ -353,30 +382,53 @@ const Chart = (props: ChartProp) => {\n     const config = useDynamicJsonProperty(props.config, props.defaultConfig, defaultConfig);\n \n     useEffect(() => {\n-        if (updateVarName) {\n-            const [backCols, dtKey] = getDataKey(config.columns, config.decimators);\n-            setDataKey(dtKey);\n-            if (refresh || !data[dtKey]) {\n-                dispatch(\n-                    createRequestChartUpdateAction(\n-                        updateVarName,\n-                        id,\n-                        module,\n-                        backCols,\n-                        dtKey,\n-                        getDecimatorsPayload(\n-                            config.decimators,\n-                            plotRef.current,\n-                            config.modes,\n-                            config.columns,\n-                            config.traces\n-                        )\n-                    )\n-                );\n-            }\n-        }\n+        setDataKeys((oldDtKeys) => {\n+            let changed = false;\n+            const newDtKeys = (config.columns || []).map((columns, idx) => {\n+                const varName = getDataVarName(updateVarName, dataVarNames, idx);\n+                if (varName) {\n+                    const [backCols, dtKey] = getDataKey(columns, config.decimators);\n+                    changed = changed || idx > oldDtKeys.length || oldDtKeys[idx] !== dtKey;\n+                    const lData = getData(data, additionalDatas, idx);\n+                    if (lData === undefined || isDataRefresh(lData) || !lData[dtKey]) {\n+                        Promise.resolve().then(() =>\n+                            dispatch(\n+                                createRequestChartUpdateAction(\n+                                    varName,\n+                                    id,\n+                                    module,\n+                                    backCols,\n+                                    dtKey,\n+                                    getDecimatorsPayload(\n+                                        config.decimators,\n+                                        plotRef.current,\n+                                        config.modes,\n+                                        columns,\n+                                        config.traces\n+                                    )\n+                                )\n+                            )\n+                        );\n+                    }\n+                    return dtKey;\n+                }\n+                return \"\";\n+            });\n+            return changed ? newDtKeys : oldDtKeys;\n+        });\n         // eslint-disable-next-line react-hooks/exhaustive-deps\n-    }, [refresh, dispatch, config.columns, config.traces, config.modes, config.decimators, updateVarName, id, module]);\n+    }, [\n+        refresh,\n+        dispatch,\n+        config.columns,\n+        config.traces,\n+        config.modes,\n+        config.decimators,\n+        updateVarName,\n+        dataVarNames,\n+        id,\n+        module,\n+    ]);\n \n     useDispatchRequestUpdateOnFirstRender(dispatch, id, module, updateVars);\n \n@@ -411,14 +463,14 @@ const Chart = (props: ChartProp) => {\n             xaxis: {\n                 title:\n                     config.traces.length && config.traces[0].length && config.traces[0][0]\n-                        ? getColNameFromIndexed(config.columns[config.traces[0][0]]?.dfid)\n+                        ? getColNameFromIndexed(config.columns[0][config.traces[0][0]]?.dfid)\n                         : undefined,\n                 ...layout.xaxis,\n             },\n             yaxis: {\n                 title:\n-                    config.traces.length == 1 && config.traces[0].length > 1 && config.columns[config.traces[0][1]]\n-                        ? getColNameFromIndexed(config.columns[config.traces[0][1]]?.dfid)\n+                    config.traces.length == 1 && config.traces[0].length > 1 && config.columns[0][config.traces[0][1]]\n+                        ? getColNameFromIndexed(config.columns[0][config.traces[0][1]]?.dfid)\n                         : undefined,\n                 ...layout.yaxis,\n             },\n@@ -447,98 +499,112 @@ const Chart = (props: ChartProp) => {\n \n     const dataPl = useMemo(() => {\n         if (props.figure) {\n-            return lastDataPl.current;\n-        }\n-        if (data.__taipy_refresh !== undefined) {\n             return lastDataPl.current || [];\n         }\n-        const dtKey = getDataKey(config.columns, config.decimators)[1];\n-        if (!dataKey.startsWith(dtKey)) {\n+        const dataList = dataKeys.map((_, idx) => getData(data, additionalDatas, idx));\n+        if (!dataList.length || dataList.every((d) => !d || isDataRefresh(d) || !Object.keys(d).length)) {\n             return lastDataPl.current || [];\n         }\n-        const datum = data[dataKey];\n-        lastDataPl.current = datum\n-            ? config.traces.map((trace, idx) => {\n-                  const ret = {\n-                      ...getArrayValue(config.options, idx, {}),\n-                      type: config.types[idx],\n-                      mode: config.modes[idx],\n-                      name:\n-                          getArrayValue(config.names, idx) ||\n-                          (config.columns[trace[1]] ? getColNameFromIndexed(config.columns[trace[1]].dfid) : undefined),\n-                  } as Record<string, unknown>;\n-                  ret.marker = { ...getArrayValue(config.markers, idx, ret.marker || {}) };\n-                  if (Object.keys(ret.marker as object).length) {\n-                      MARKER_TO_COL.forEach((prop) => {\n-                          const val = (ret.marker as Record<string, unknown>)[prop];\n-                          if (typeof val === \"string\") {\n-                              const arr = getValueFromCol(datum, val as string);\n-                              if (arr.length) {\n-                                  (ret.marker as Record<string, unknown>)[prop] = arr;\n-                              }\n-                          }\n-                      });\n-                  } else {\n-                      delete ret.marker;\n-                  }\n-                  const xs = getValue(datum, trace, 0) || [];\n-                  const ys = getValue(datum, trace, 1) || [];\n-                  const addIndex = getArrayValue(config.addIndex, idx, true) && !ys.length;\n-                  const baseX = addIndex ? Array.from(Array(xs.length).keys()) : xs;\n-                  const baseY = addIndex ? xs : ys;\n-                  const axisNames = config.axisNames.length > idx ? config.axisNames[idx] : ([] as string[]);\n-                  if (baseX.length) {\n-                      if (axisNames.length > 0) {\n-                          ret[axisNames[0]] = baseX;\n-                      } else {\n-                          ret.x = baseX;\n-                      }\n-                  }\n-                  if (baseY.length) {\n-                      if (axisNames.length > 1) {\n-                          ret[axisNames[1]] = baseY;\n-                      } else {\n-                          ret.y = baseY;\n-                      }\n-                  }\n-                  const baseZ = getValue(datum, trace, 2, true);\n-                  if (baseZ) {\n-                      if (axisNames.length > 2) {\n-                          ret[axisNames[2]] = baseZ;\n-                      } else {\n-                          ret.z = baseZ;\n-                      }\n-                  }\n-                  // Hack for treemap charts: create a fallback 'parents' column if needed\n-                  // This works ONLY because 'parents' is the third named axis\n-                  // (see __CHART_AXIS in gui/utils/chart_config_builder.py)\n-                  else if (config.types[idx] === \"treemap\" && Array.isArray(ret.labels)) {\n-                      ret.parents = Array(ret.labels.length).fill(\"\");\n-                  }\n-                  // Other axis\n-                  for (let i = 3; i < axisNames.length; i++) {\n-                      ret[axisNames[i]] = getValue(datum, trace, i, true);\n-                  }\n-                  ret.text = getValue(datum, config.texts, idx, true);\n-                  ret.xaxis = config.xaxis[idx];\n-                  ret.yaxis = config.yaxis[idx];\n-                  ret.hovertext = getValue(datum, config.labels, idx, true);\n-                  const selPoints = getArrayValue(selected, idx, []);\n-                  if (selPoints?.length) {\n-                      ret.selectedpoints = selPoints;\n-                  }\n-                  ret.orientation = getArrayValue(config.orientations, idx);\n-                  ret.line = getArrayValue(config.lines, idx);\n-                  ret.textposition = getArrayValue(config.textAnchors, idx);\n-                  const selectedMarker = getArrayValue(config.selectedMarkers, idx);\n-                  if (selectedMarker) {\n-                      ret.selected = { marker: selectedMarker };\n-                  }\n-                  return ret as Data;\n-              })\n-            : lastDataPl.current || [];\n+        let changed = false;\n+        const newDataPl = config.traces.map((trace, idx) => {\n+            const currentData = idx < lastDataPl.current.length ? lastDataPl.current[idx] : {};\n+            const dataKey = idx < dataKeys.length ? dataKeys[idx] : dataKeys[0];\n+            const lData = idx < dataList.length ? dataList[idx] : dataList[0];\n+            if (!lData || isDataRefresh(lData) || !Object.keys(lData).length) {\n+                return currentData;\n+            }\n+            const dtKey = getDataKey(\n+                idx < config.columns?.length ? config.columns[idx] : undefined,\n+                config.decimators\n+            )[1];\n+            if (!dataKey.startsWith(dtKey) || !dtKey.length) {\n+                return currentData;\n+            }\n+            changed = true;\n+            const datum = lData[dataKey];\n+            const columns = config.columns[idx];\n+            const ret = {\n+                ...getArrayValue(config.options, idx, {}),\n+                type: config.types[idx],\n+                mode: config.modes[idx],\n+                name:\n+                    getArrayValue(config.names, idx) ||\n+                    (columns[trace[1]] ? getColNameFromIndexed(columns[trace[1]].dfid) : undefined),\n+            } as Record<string, unknown>;\n+            ret.marker = { ...getArrayValue(config.markers, idx, ret.marker || {}) };\n+            if (Object.keys(ret.marker as object).length) {\n+                MARKER_TO_COL.forEach((prop) => {\n+                    const val = (ret.marker as Record<string, unknown>)[prop];\n+                    if (typeof val === \"string\") {\n+                        const arr = getValueFromCol(datum, val as string);\n+                        if (arr.length) {\n+                            (ret.marker as Record<string, unknown>)[prop] = arr;\n+                        }\n+                    }\n+                });\n+            } else {\n+                delete ret.marker;\n+            }\n+            const xs = getValue(datum, trace, 0) || [];\n+            const ys = getValue(datum, trace, 1) || [];\n+            const addIndex = getArrayValue(config.addIndex, idx, true) && !ys.length;\n+            const baseX = addIndex ? Array.from(Array(xs.length).keys()) : xs;\n+            const baseY = addIndex ? xs : ys;\n+            const axisNames = config.axisNames.length > idx ? config.axisNames[idx] : ([] as string[]);\n+            if (baseX.length) {\n+                if (axisNames.length > 0) {\n+                    ret[axisNames[0]] = baseX;\n+                } else {\n+                    ret.x = baseX;\n+                }\n+            }\n+            if (baseY.length) {\n+                if (axisNames.length > 1) {\n+                    ret[axisNames[1]] = baseY;\n+                } else {\n+                    ret.y = baseY;\n+                }\n+            }\n+            const baseZ = getValue(datum, trace, 2, true);\n+            if (baseZ) {\n+                if (axisNames.length > 2) {\n+                    ret[axisNames[2]] = baseZ;\n+                } else {\n+                    ret.z = baseZ;\n+                }\n+            }\n+            // Hack for treemap charts: create a fallback 'parents' column if needed\n+            // This works ONLY because 'parents' is the third named axis\n+            // (see __CHART_AXIS in gui/utils/chart_config_builder.py)\n+            else if (config.types[idx] === \"treemap\" && Array.isArray(ret.labels)) {\n+                ret.parents = Array(ret.labels.length).fill(\"\");\n+            }\n+            // Other axis\n+            for (let i = 3; i < axisNames.length; i++) {\n+                ret[axisNames[i]] = getValue(datum, trace, i, true);\n+            }\n+            ret.text = getValue(datum, config.texts, idx, true);\n+            ret.xaxis = config.xaxis[idx];\n+            ret.yaxis = config.yaxis[idx];\n+            ret.hovertext = getValue(datum, config.labels, idx, true);\n+            const selPoints = getArrayValue(selected, idx, []);\n+            if (selPoints?.length) {\n+                ret.selectedpoints = selPoints;\n+            }\n+            ret.orientation = getArrayValue(config.orientations, idx);\n+            ret.line = getArrayValue(config.lines, idx);\n+            ret.textposition = getArrayValue(config.textAnchors, idx);\n+            const selectedMarker = getArrayValue(config.selectedMarkers, idx);\n+            if (selectedMarker) {\n+                ret.selected = { marker: selectedMarker };\n+            }\n+            return ret as Data;\n+        });\n+        if (changed) {\n+            lastDataPl.current = newDataPl;\n+        }\n         return lastDataPl.current;\n-    }, [props.figure, selected, data, config, dataKey]);\n+    }, [props.figure, selected, data, additionalDatas, config, dataKeys]);\n \n     const plotConfig = useMemo(() => {\n         let plConf: Partial<Config> = {};\n@@ -567,28 +633,41 @@ const Chart = (props: ChartProp) => {\n         (eventData: PlotRelayoutEvent) => {\n             onRangeChange && dispatch(createSendActionNameAction(id, module, { action: onRangeChange, ...eventData }));\n             if (config.decimators && !config.types.includes(\"scatter3d\")) {\n-                const [backCols, dtKeyBase] = getDataKey(config.columns, config.decimators);\n+                const [backCols, dtKeyBase] = getDataKey(\n+                    config.columns?.length ? config.columns[0] : undefined,\n+                    config.decimators\n+                );\n                 const dtKey = `${dtKeyBase}--${Object.entries(eventData)\n                     .map(([k, v]) => `${k}=${v}`)\n                     .join(\"-\")}`;\n-                setDataKey(dtKey);\n-                dispatch(\n-                    createRequestChartUpdateAction(\n-                        updateVarName,\n-                        id,\n-                        module,\n-                        backCols,\n-                        dtKey,\n-                        getDecimatorsPayload(\n-                            config.decimators,\n-                            plotRef.current,\n-                            config.modes,\n-                            config.columns,\n-                            config.traces,\n-                            eventData\n-                        )\n-                    )\n-                );\n+                setDataKeys((oldDataKeys) => {\n+                    if (oldDataKeys.length === 0) {\n+                        return [dtKey];\n+                    }\n+                    if (oldDataKeys[0] !== dtKey) {\n+                        Promise.resolve().then(() =>\n+                            dispatch(\n+                                createRequestChartUpdateAction(\n+                                    updateVarName,\n+                                    id,\n+                                    module,\n+                                    backCols,\n+                                    dtKey,\n+                                    getDecimatorsPayload(\n+                                        config.decimators,\n+                                        plotRef.current,\n+                                        config.modes,\n+                                        config.columns?.length ? config.columns[0] : {},\n+                                        config.traces,\n+                                        eventData\n+                                    )\n+                                )\n+                            )\n+                        );\n+                        return [dtKey, ...oldDataKeys.slice(1)];\n+                    }\n+                    return oldDataKeys;\n+                });\n             }\n         },\n         [\n@@ -646,15 +725,21 @@ const Chart = (props: ChartProp) => {\n     );\n \n     const getRealIndex = useCallback(\n-        (index?: number) =>\n-            typeof index === \"number\"\n+        (dataIdx: number, index?: number) => {\n+            const lData = getData(data, additionalDatas, dataIdx);\n+            if (!lData) {\n+                return index || 0;\n+            }\n+            const dtKey = dataKeys[dataIdx];\n+            return typeof index === \"number\"\n                 ? props.figure\n                     ? index\n-                    : data[dataKey].tp_index\n-                    ? (data[dataKey].tp_index[index] as number)\n+                    : lData[dtKey].tp_index\n+                    ? (lData[dtKey].tp_index[index] as number)\n                     : index\n-                : 0,\n-        [data, dataKey, props.figure]\n+                : 0;\n+        },\n+        [data, additionalDatas, dataKeys, props.figure]\n     );\n \n     const onSelect = useCallback(\n@@ -662,7 +747,7 @@ const Chart = (props: ChartProp) => {\n             if (updateVars) {\n                 const traces = (evt?.points || []).reduce((tr, pt) => {\n                     tr[pt.curveNumber] = tr[pt.curveNumber] || [];\n-                    tr[pt.curveNumber].push(getRealIndex(getPlotIndex(pt)));\n+                    tr[pt.curveNumber].push(getRealIndex(pt.curveNumber, getPlotIndex(pt)));\n                     return tr;\n                 }, [] as number[][]);\n                 if (config.traces.length === 0) {\ndiff --git a/taipy/gui/_renderers/builder.py b/taipy/gui/_renderers/builder.py\nindex 02eea87fae..ba9d5ee95a 100644\n--- a/taipy/gui/_renderers/builder.py\n+++ b/taipy/gui/_renderers/builder.py\n@@ -610,7 +610,7 @@ def _get_chart_config(self, default_type: str, default_mode: str):\n         self.__attributes[\"_default_mode\"] = default_mode\n         rebuild_fn_hash = self.__build_rebuild_fn(\n             self.__gui._get_call_method_name(\"_chart_conf\"),\n-            _CHART_NAMES + (\"_default_type\", \"_default_mode\", \"data\"),\n+            _CHART_NAMES + (\"_default_type\", \"_default_mode\"),\n         )\n         if rebuild_fn_hash:\n             self.__set_react_attribute(\"config\", rebuild_fn_hash)\n@@ -618,7 +618,23 @@ def _get_chart_config(self, default_type: str, default_mode: str):\n         # read column definitions\n         data = self.__attributes.get(\"data\")\n         data_hash = self.__hashes.get(\"data\", \"\")\n-        col_types = self.__gui._get_accessor().get_col_types(data_hash, _TaipyData(data, data_hash))\n+        col_types = [self.__gui._get_accessor().get_col_types(data_hash, _TaipyData(data, data_hash))]\n+\n+        if data_hash:\n+            data_updates: t.List[str] = []\n+            data_idx = 1\n+            name_idx = f\"data[{data_idx}]\"\n+            while add_data_hash := self.__hashes.get(name_idx):\n+                typed_hash = self.__get_typed_hash_name(add_data_hash, _TaipyData)\n+                data_updates.append(typed_hash)\n+                self.__set_react_attribute(f\"data{data_idx}\",_get_client_var_name(typed_hash))\n+                add_data = self.__attributes.get(name_idx)\n+                data_idx += 1\n+                name_idx = f\"data[{data_idx}]\"\n+                col_types.append(\n+                    self.__gui._get_accessor().get_col_types(add_data_hash, _TaipyData(add_data, add_data_hash))\n+                )\n+            self.set_attribute(\"dataVarNames\", \";\".join(data_updates))\n \n         config = _build_chart_config(self.__gui, self.__attributes, col_types)\n \ndiff --git a/taipy/gui/gui.py b/taipy/gui/gui.py\nindex e2d57fc0f8..eff45ecb09 100644\n--- a/taipy/gui/gui.py\n+++ b/taipy/gui/gui.py\n@@ -1903,11 +1903,18 @@ def _chart_conf(\n                 rebuild = rebuild_val if rebuild_val is not None else rebuild\n                 if rebuild:\n                     attributes, hashes = self.__get_attributes(attr_json, hash_json, kwargs)\n-                    data_hash = hashes.get(\"data\", \"\")\n+                    idx = 0\n+                    data_hashes = []\n+                    while data_hash := hashes.get(\"data\" if idx == 0 else f\"data[{idx}]\", \"\"):\n+                        data_hashes.append(data_hash)\n+                        idx += 1\n                     config = _build_chart_config(\n                         self,\n                         attributes,\n-                        self._get_accessor().get_col_types(data_hash, _TaipyData(kwargs.get(data_hash), data_hash)),\n+                        [\n+                            self._get_accessor().get_col_types(data_hash, _TaipyData(kwargs.get(data_hash), data_hash))\n+                            for data_hash in data_hashes\n+                        ],\n                     )\n \n                     return json.dumps(config, cls=_TaipyJsonEncoder)\ndiff --git a/taipy/gui/utils/chart_config_builder.py b/taipy/gui/utils/chart_config_builder.py\nindex 6206cb93f4..4ce9c68e66 100644\n--- a/taipy/gui/utils/chart_config_builder.py\n+++ b/taipy/gui/utils/chart_config_builder.py\n@@ -112,7 +112,7 @@ def __get_col_from_indexed(col_name: str, idx: int) -> t.Optional[str]:\n     return col_name\n \n \n-def _build_chart_config(gui: \"Gui\", attributes: t.Dict[str, t.Any], col_types: t.Dict[str, str]):  # noqa: C901\n+def _build_chart_config(gui: \"Gui\", attributes: t.Dict[str, t.Any], col_types_list: t.List[t.Dict[str, str]]):  # noqa: C901\n     if \"data\" not in attributes and \"figure\" in attributes:\n         return {\"traces\": []}\n     default_type = attributes.get(\"_default_type\", \"scatter\")\n@@ -167,32 +167,47 @@ def _build_chart_config(gui: \"Gui\", attributes: t.Dict[str, t.Any], col_types: t\n         # axis names\n         axis.append(__CHART_AXIS.get(trace[_Chart_iprops.type.value] or \"\", __CHART_DEFAULT_AXIS))\n \n+    idx = 1\n+    while f\"data[{idx}]\" in attributes:\n+        if idx >= len(traces):\n+            traces.append(list(traces[0]))\n+            axis.append(__CHART_AXIS.get(traces[0][_Chart_iprops.type.value] or \"\", __CHART_DEFAULT_AXIS))\n+        idx += 1\n+\n     # list of data columns name indexes with label text\n     dt_idx = tuple(e.value for e in (axis[0] + (_Chart_iprops.label, _Chart_iprops.text)))\n \n     # configure columns\n-    columns: t.Set[str] = set()\n-    for j, trace in enumerate(traces):\n+    columns: t.List[t.Set[str]] = [set()] * len(traces)\n+    for idx, trace in enumerate(traces):\n         dt_idx = tuple(\n-            e.value for e in (axis[j] if j < len(axis) else axis[0]) + (_Chart_iprops.label, _Chart_iprops.text)\n+            e.value for e in (axis[idx] if idx < len(axis) else axis[0]) + (_Chart_iprops.label, _Chart_iprops.text)\n         )\n-        columns.update([trace[i] or \"\" for i in dt_idx if trace[i]])\n+        columns[idx].update([trace[i] or \"\" for i in dt_idx if trace[i]])\n     # add optional column if any\n     markers = [\n         t[_Chart_iprops.marker.value]\n         or ({\"color\": t[_Chart_iprops.color.value]} if t[_Chart_iprops.color.value] else None)\n         for t in traces\n     ]\n-    opt_cols = set()\n-    for m in markers:\n+    opt_cols: t.List[t.Set[str]] = [set()] * len(traces)\n+    for idx, m in enumerate(markers):\n         if isinstance(m, (dict, _MapDict)):\n             for prop1 in __CHART_MARKER_TO_COLS:\n                 val = m.get(prop1)\n-                if isinstance(val, str) and val not in columns:\n-                    opt_cols.add(val)\n+                if isinstance(val, str) and val not in columns[idx]:\n+                    opt_cols[idx].add(val)\n \n     # Validate the column names\n-    col_dict = _get_columns_dict(attributes.get(\"data\"), list(columns), col_types, opt_columns=opt_cols)\n+    col_dicts = []\n+    for idx, col_types in enumerate(col_types_list):\n+        if add_col_dict := _get_columns_dict(\n+            attributes.get(\"data\" if idx == 0 else f\"data[{idx}]\"),\n+            list(columns[idx] if idx < len(columns) else columns[0]),\n+            col_types,\n+            opt_columns=opt_cols[idx] if idx < len(opt_cols) else opt_cols[0],\n+        ):\n+            col_dicts.append(add_col_dict)\n \n     # Manage Decimator\n     decimators: t.List[t.Optional[str]] = []\n@@ -208,7 +223,14 @@ def _build_chart_config(gui: \"Gui\", attributes: t.Dict[str, t.Any], col_types: t\n \n     # set default columns if not defined\n     icols = [\n-        [c2 for c2 in [__get_col_from_indexed(c1, i) for c1 in t.cast(dict, col_dict).keys()] if c2]\n+        [\n+            c2\n+            for c2 in [\n+                __get_col_from_indexed(c1, i)\n+                for c1 in t.cast(dict, col_dicts[i] if i < len(col_dicts) else col_dicts[0]).keys()\n+            ]\n+            if c2\n+        ]\n         for i in range(len(traces))\n     ]\n \n@@ -222,21 +244,24 @@ def _build_chart_config(gui: \"Gui\", attributes: t.Dict[str, t.Any], col_types: t\n                     for j, v in enumerate(tr)\n                 ]\n \n-    if col_dict is not None:\n-        reverse_cols = {str(cd.get(\"dfid\")): c for c, cd in col_dict.items()}\n+    if col_dicts:\n+        reverse_cols = [{str(cd.get(\"dfid\")): c for c, cd in col_dict.items()} for col_dict in col_dicts]\n+        for idx in range(len(traces)):\n+            if idx < len(reverse_cols):\n+                reverse_cols.append(reverse_cols[0])\n \n         # List used axis\n         used_axis = [[e for e in (axis[j] if j < len(axis) else axis[0]) if tr[e.value]] for j, tr in enumerate(traces)]\n \n         ret_dict = {\n-            \"columns\": col_dict,\n+            \"columns\": col_dicts,\n             \"labels\": [\n-                reverse_cols.get(tr[_Chart_iprops.label.value] or \"\", (tr[_Chart_iprops.label.value] or \"\"))\n-                for tr in traces\n+                reverse_cols[idx].get(tr[_Chart_iprops.label.value] or \"\", (tr[_Chart_iprops.label.value] or \"\"))\n+                for idx, tr in enumerate(traces)\n             ],\n             \"texts\": [\n-                reverse_cols.get(tr[_Chart_iprops.text.value] or \"\", (tr[_Chart_iprops.text.value] or None))\n-                for tr in traces\n+                reverse_cols[idx].get(tr[_Chart_iprops.text.value] or \"\", (tr[_Chart_iprops.text.value] or None))\n+                for idx, tr in enumerate(traces)\n             ],\n             \"modes\": [tr[_Chart_iprops.mode.value] for tr in traces],\n             \"types\": [tr[_Chart_iprops.type.value] for tr in traces],\n@@ -253,8 +278,8 @@ def _build_chart_config(gui: \"Gui\", attributes: t.Dict[str, t.Any], col_types: t\n                 for tr in traces\n             ],\n             \"traces\": [\n-                [reverse_cols.get(c or \"\", c) for c in [tr[e.value] for e in used_axis[j]]]\n-                for j, tr in enumerate(traces)\n+                [reverse_cols[idx].get(c or \"\", c) for c in [tr[e.value] for e in used_axis[idx]]]\n+                for idx, tr in enumerate(traces)\n             ],\n             \"orientations\": [tr[_Chart_iprops.orientation.value] for tr in traces],\n             \"names\": [tr[_Chart_iprops._name.value] for tr in traces],\ndiff --git a/taipy/gui/viselements.json b/taipy/gui/viselements.json\nindex bb14fded3c..6636a3caf4 100644\n--- a/taipy/gui/viselements.json\n+++ b/taipy/gui/viselements.json\n@@ -492,7 +492,7 @@\n                         \"name\": \"data\",\n                         \"default_property\": true,\n                         \"required\": true,\n-                        \"type\": \"dynamic(Any)\",\n+                        \"type\": \"indexed(dynamic(Any))\",\n                         \"doc\": \"The data object bound to this chart control.<br/>See the section on the <a href=\\\"#the-data-property\\\"><i>data</i> property</a> below for more details.\"\n                     },\n                     {\n", "test_patch": "diff --git a/tests/gui/builder/control/test_chart.py b/tests/gui/builder/control/test_chart.py\nindex fc3932b1df..7f3ba83691 100644\n--- a/tests/gui/builder/control/test_chart.py\n+++ b/tests/gui/builder/control/test_chart.py\n@@ -258,3 +258,21 @@ def test_chart_indexed_properties_with_arrays_builder(gui: Gui, helpers):\n         \"&quot;lines&quot;: [null, &#x7B;&quot;dash&quot;: &quot;dashdot&quot;&#x7D;, &#x7B;&quot;dash&quot;: &quot;dash&quot;&#x7D;, null, &#x7B;&quot;dash&quot;: &quot;dashdot&quot;&#x7D;, &#x7B;&quot;dash&quot;: &quot;dash&quot;&#x7D;]\",  # noqa: E501\n     ]\n     helpers.test_control_builder(gui, page, expected_list)\n+\n+def test_chart_multi_data(gui: Gui, helpers, csvdata):\n+    with tgb.Page(frame=None) as page:\n+        tgb.chart(  # type: ignore[attr-defined]\n+            data=\"{csvdata}\",\n+            x=\"Day\",\n+            y=\"Daily hospital occupancy\",\n+            data__1=\"{csvdata}\",\n+        )\n+    expected_list = [\n+        \"<Chart\",\n+        'updateVarName=\"_TpD_tpec_TpExPr_csvdata_TPMDL_0\"',\n+        'dataVarNames=\"_TpD_tpec_TpExPr_csvdata_TPMDL_0\"',\n+        \"data={_TpD_tpec_TpExPr_csvdata_TPMDL_0}\",\n+        \"data1={_TpD_tpec_TpExPr_csvdata_TPMDL_0}\",\n+    ]\n+    gui._set_frame(inspect.currentframe())\n+    helpers.test_control_builder(gui, page, expected_list)\ndiff --git a/tests/gui/control/test_chart.py b/tests/gui/control/test_chart.py\nindex c289b4b687..5694d52c07 100644\n--- a/tests/gui/control/test_chart.py\n+++ b/tests/gui/control/test_chart.py\n@@ -218,3 +218,15 @@ def test_chart_indexed_properties_with_arrays(gui: Gui, helpers):\n         \"&quot;lines&quot;: [null, &#x7B;&quot;dash&quot;: &quot;dashdot&quot;&#x7D;, &#x7B;&quot;dash&quot;: &quot;dash&quot;&#x7D;, null, &#x7B;&quot;dash&quot;: &quot;dashdot&quot;&#x7D;, &#x7B;&quot;dash&quot;: &quot;dash&quot;&#x7D;]\",  # noqa: E501\n     ]\n     helpers.test_control_md(gui, md, expected_list)\n+\n+def test_chart_multi_data(gui: Gui, helpers, csvdata):\n+    md_string = \"<|{csvdata}|chart|x=Day|y=Daily hospital occupancy|data[1]={csvdata}|>\"\n+    expected_list = [\n+        \"<Chart\",\n+        'updateVarName=\"_TpD_tpec_TpExPr_csvdata_TPMDL_0\"',\n+        'dataVarNames=\"_TpD_tpec_TpExPr_csvdata_TPMDL_0\"',\n+        \"data={_TpD_tpec_TpExPr_csvdata_TPMDL_0}\",\n+        \"data1={_TpD_tpec_TpExPr_csvdata_TPMDL_0}\",\n+    ]\n+    gui._set_frame(inspect.currentframe())\n+    helpers.test_control_md(gui, md_string, expected_list)\ndiff --git a/tests/gui/gui_specific/test_gui.py b/tests/gui/gui_specific/test_gui.py\nindex f7f3b8c2a8..cf0fb2563e 100644\n--- a/tests/gui/gui_specific/test_gui.py\n+++ b/tests/gui/gui_specific/test_gui.py\n@@ -73,7 +73,7 @@ def test__chart_conf(gui: Gui):\n \n         d = json.loads(res)\n         assert isinstance(d, dict)\n-        assert d[\"columns\"][\"col1\"][\"type\"] == \"int\"\n+        assert d[\"columns\"][0][\"col1\"][\"type\"] == \"int\"\n \n         res = gui._chart_conf(False, None, \"\", \"\")\n         assert repr(res) == \"Taipy: Do not update\"\n", "problem_statement": "Add support for data slice update in charts\n### Description\n\nMulti-trace charts rely on a single *data* property, which is a limitation.\n\n### Solution Proposed\n\nMake *data* an indexed property.\n\n### Acceptance Criteria\n\n- [ ] If applicable, a new demo code is provided to show the new feature in action.\r\n- [ ] Integration tests exhibiting how the functionality works are added.\r\n- [ ] Any new code is covered by a unit tested.\r\n- [ ] Check code coverage is at least 90%.\r\n- [ ] Related issue(s) in taipy-doc are created for documentation and Release Notes are updated.\r\n\n\n### Code of Conduct\n\n- [X] I have checked the [existing issues](https://github.com/Avaiga/taipy/issues?q=is%3Aissue+).\n- [ ] I am willing to work on this issue (optional)\nAdd support for data slice update in charts\n### Description\n\nMulti-trace charts rely on a single *data* property, which is a limitation.\n\n### Solution Proposed\n\nMake *data* an indexed property.\n\n### Acceptance Criteria\n\n- [ ] If applicable, a new demo code is provided to show the new feature in action.\r\n- [ ] Integration tests exhibiting how the functionality works are added.\r\n- [ ] Any new code is covered by a unit tested.\r\n- [ ] Check code coverage is at least 90%.\r\n- [ ] Related issue(s) in taipy-doc are created for documentation and Release Notes are updated.\r\n\n\n### Code of Conduct\n\n- [X] I have checked the [existing issues](https://github.com/Avaiga/taipy/issues?q=is%3Aissue+).\n- [ ] I am willing to work on this issue (optional)\n", "hints_text": "This issue has been labelled as \"\ud83e\udd76Waiting for contributor\" because it has been inactive for more than 14 days. If you would like to continue working on this issue, please add another comment or create a PR that links to this issue. If a PR has already been created which refers to this issue, then you should explicitly mention this issue in the relevant PR. Otherwise, you will be unassigned in 14 days. For more information please refer to the contributing guidelines.\nTo add my two cents to the topic, when communicating about this indexed data topic, instead of `data slice,` I would suggest using something else like `data layer` or `data stratum` or any better naming since data slicing already means something in data processing.\r\n\r\n\nThis issue has been labelled as \"\ud83e\udd76Waiting for contributor\" because it has been inactive for more than 14 days. If you would like to continue working on this issue, please add another comment or create a PR that links to this issue. If a PR has already been created which refers to this issue, then you should explicitly mention this issue in the relevant PR. Otherwise, you will be unassigned in 14 days. For more information please refer to the contributing guidelines.\nTo add my two cents to the topic, when communicating about this indexed data topic, instead of `data slice,` I would suggest using something else like `data layer` or `data stratum` or any better naming since data slicing already means something in data processing.\r\n\r\n", "created_at": "2025-01-10T16:34:43Z"}
{"repo": "Avaiga/taipy", "pull_number": 2367, "instance_id": "Avaiga__taipy-2367", "issue_numbers": ["2263"], "base_commit": "d536592428d16c6833601632788a782621f625fc", "patch": "diff --git a/taipy/templates/default/hooks/post_gen_project.py b/taipy/templates/default/hooks/post_gen_project.py\nindex 0774c93193..45253b0ddb 100644\n--- a/taipy/templates/default/hooks/post_gen_project.py\n+++ b/taipy/templates/default/hooks/post_gen_project.py\n@@ -77,33 +77,29 @@ def handle_single_page_app():\n         main_file.write(\"\\n\")\n         main_file.write(\"    gui = Gui(page=page)\\n\")\n \n+    with open(os.path.join(os.getcwd(), \"sections\", \"import.txt\"), \"a\") as import_file:\n+        import_file.write(\"import taipy.gui.builder as tgb\\n\")\n+\n     handle_run_service()\n \n     with open(os.path.join(os.getcwd(), \"sections\", \"page_content.txt\"), \"a\") as page_content_file:\n         page_content_file.write(\n-            '''\n-page = \"\"\"\n-<center>\n-<|navbar|lov={[(\"home\", \"Homepage\")]}|>\n-</center>\n+            \"\"\"\n+with tgb.Page() as page:\n+    tgb.navbar(lov=\"{[('home', 'Homepage')]}\")\n \n \"\"\"\n-'''\n         )\n \n \n def handle_multi_page_app(pages):\n     for page_name in pages:\n         os.mkdir(os.path.join(os.getcwd(), \"pages\", page_name))\n-        with open(os.path.join(os.getcwd(), \"pages\", \"page_example\", \"page_example.md\"), \"r\") as page_md_file:\n-            page_md_content = page_md_file.read()\n-        page_md_content = page_md_content.replace(\"Page example\", page_name.replace(\"_\", \" \").title())\n-        with open(os.path.join(os.getcwd(), \"pages\", page_name, page_name + \".md\"), \"w\") as page_md_file:\n-            page_md_file.write(page_md_content)\n \n         with open(os.path.join(os.getcwd(), \"pages\", \"page_example\", \"page_example.py\"), \"r\") as page_content_file:\n             page_py_content = page_content_file.read()\n         page_py_content = page_py_content.replace(\"page_example\", page_name)\n+        page_py_content = page_py_content.replace(\"Page example\", page_name.replace(\"_\", \" \").title())\n         with open(os.path.join(os.getcwd(), \"pages\", page_name, page_name + \".py\"), \"w\") as page_content_file:\n             page_content_file.write(page_py_content)\n \ndiff --git a/taipy/templates/default/{{cookiecutter.__root_folder}}/pages/page_example/page_example.md b/taipy/templates/default/{{cookiecutter.__root_folder}}/pages/page_example/page_example.md\ndeleted file mode 100644\nindex dc0bea2fd6..0000000000\n--- a/taipy/templates/default/{{cookiecutter.__root_folder}}/pages/page_example/page_example.md\n+++ /dev/null\n@@ -1,1 +0,0 @@\n-# Page example\ndiff --git a/taipy/templates/default/{{cookiecutter.__root_folder}}/pages/page_example/page_example.py b/taipy/templates/default/{{cookiecutter.__root_folder}}/pages/page_example/page_example.py\nindex 15dcc83469..ac1a6b94b5 100644\n--- a/taipy/templates/default/{{cookiecutter.__root_folder}}/pages/page_example/page_example.py\n+++ b/taipy/templates/default/{{cookiecutter.__root_folder}}/pages/page_example/page_example.py\n@@ -11,11 +11,12 @@\n \n \"\"\"\n A page of the application.\n-Page content is imported from the page_example.md file.\n+Page content is built using the Page builder API.\n \n-Please refer to https://docs.taipy.io/en/latest/manuals/userman/gui/pages for more details.\n+Please refer to https://docs.taipy.io/en/latest/userman/gui/pages/builder/ for more details.\n \"\"\"\n \n-from taipy.gui import Markdown\n+import taipy.gui.builder as tgb\n \n-page_example = Markdown(\"pages/page_example/page_example.md\")\n+with tgb.Page() as page_example:\n+    tgb.text(\"# Page example\", mode=\"md\")\ndiff --git a/taipy/templates/default/{{cookiecutter.__root_folder}}/pages/root.md b/taipy/templates/default/{{cookiecutter.__root_folder}}/pages/root.md\ndeleted file mode 100644\nindex 0216ecc457..0000000000\n--- a/taipy/templates/default/{{cookiecutter.__root_folder}}/pages/root.md\n+++ /dev/null\n@@ -1,3 +0,0 @@\n-<center>\n-<|navbar|>\n-</center>\ndiff --git a/taipy/templates/default/{{cookiecutter.__root_folder}}/pages/root.py b/taipy/templates/default/{{cookiecutter.__root_folder}}/pages/root.py\nindex c06b1fae6c..ac91eaffad 100644\n--- a/taipy/templates/default/{{cookiecutter.__root_folder}}/pages/root.py\n+++ b/taipy/templates/default/{{cookiecutter.__root_folder}}/pages/root.py\n@@ -11,11 +11,12 @@\n \n \"\"\"\n The root page of the application.\n-Page content is imported from the root.md file.\n+Page content is built using the Page builder API.\n \n-Please refer to https://docs.taipy.io/en/latest/manuals/userman/gui/pages for more details.\n+Please refer to https://docs.taipy.io/en/latest/userman/gui/pages/builder/ for more details.\n \"\"\"\n \n-from taipy.gui import Markdown\n+import taipy.gui.builder as tgb\n \n-root_page = Markdown(\"pages/root.md\")\n+with tgb.Page() as root_page:\n+    tgb.navbar()\ndiff --git a/taipy/templates/sdm/{{cookiecutter.__root_folder}}/pages/job_page/job_page.md b/taipy/templates/sdm/{{cookiecutter.__root_folder}}/pages/job_page/job_page.md\ndeleted file mode 100644\nindex b498167e96..0000000000\n--- a/taipy/templates/sdm/{{cookiecutter.__root_folder}}/pages/job_page/job_page.md\n+++ /dev/null\n@@ -1,1 +0,0 @@\n-<|job_selector|>\ndiff --git a/taipy/templates/sdm/{{cookiecutter.__root_folder}}/pages/job_page/job_page.py b/taipy/templates/sdm/{{cookiecutter.__root_folder}}/pages/job_page/job_page.py\nindex d3d7f527dc..fb50ed5e3d 100644\n--- a/taipy/templates/sdm/{{cookiecutter.__root_folder}}/pages/job_page/job_page.py\n+++ b/taipy/templates/sdm/{{cookiecutter.__root_folder}}/pages/job_page/job_page.py\n@@ -9,6 +9,7 @@\n # an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n # specific language governing permissions and limitations under the License.\n \n-from taipy.gui import Markdown\n+import taipy.gui.builder as tgb\n \n-job_page = Markdown(\"pages/job_page/job_page.md\")\n+with tgb.Page() as job_page:\n+    tgb.job_selector()\ndiff --git a/taipy/templates/sdm/{{cookiecutter.__root_folder}}/pages/root.md b/taipy/templates/sdm/{{cookiecutter.__root_folder}}/pages/root.md\ndeleted file mode 100644\nindex 994124b8fd..0000000000\n--- a/taipy/templates/sdm/{{cookiecutter.__root_folder}}/pages/root.md\n+++ /dev/null\n@@ -1,21 +0,0 @@\n-<|layout|columns=1 5|\n-\n-<|sidebar|\n-\n-<|{selected_scenario}|scenario_selector|>\n-\n-<|part|render={selected_scenario}|\n-<|{selected_data_node}|data_node_selector|not display_cycles|>\n-|>\n-|>\n-\n-<|part|class_name=main|\n-\n-<|navbar|>\n-\n-<|part|class_name=main|\n-<|content|>\n-|>\n-\n-|>\n-|>\ndiff --git a/taipy/templates/sdm/{{cookiecutter.__root_folder}}/pages/root.py b/taipy/templates/sdm/{{cookiecutter.__root_folder}}/pages/root.py\nindex f82dd0bce0..62b5838ed9 100644\n--- a/taipy/templates/sdm/{{cookiecutter.__root_folder}}/pages/root.py\n+++ b/taipy/templates/sdm/{{cookiecutter.__root_folder}}/pages/root.py\n@@ -9,10 +9,23 @@\n # an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n # specific language governing permissions and limitations under the License.\n \n-from taipy.gui import Markdown\n+import taipy.gui.builder as tgb\n \n selected_scenario = None\n selected_data_node = None\n content = \"\"\n \n-root = Markdown(\"pages/root.md\")\n+\n+with tgb.Page() as root:\n+    with tgb.layout(columns=\"1, 5\"):\n+        with tgb.part(class_name=\"sidebar\"):\n+            tgb.scenario_selector(\"{selected_scenario}\")\n+\n+            with tgb.part(render=\"{selected_scenario}\"):\n+                tgb.data_node_selector(\"{selected_data_node}\", display_cycles=False)\n+\n+        with tgb.part(class_name=\"main\"):\n+            tgb.navbar()\n+\n+            with tgb.part(class_name=\"main\"):\n+                tgb.text(\"{content}\")\ndiff --git a/taipy/templates/sdm/{{cookiecutter.__root_folder}}/pages/scenario_page/scenario_page.md b/taipy/templates/sdm/{{cookiecutter.__root_folder}}/pages/scenario_page/scenario_page.md\ndeleted file mode 100644\nindex 6c26000f84..0000000000\n--- a/taipy/templates/sdm/{{cookiecutter.__root_folder}}/pages/scenario_page/scenario_page.md\n+++ /dev/null\n@@ -1,12 +0,0 @@\n-<|layout|columns=1 1|\n-\n-<|part|render={selected_scenario}|\n-\n-<|{selected_scenario}|scenario|not expandable|expanded|on_submission_change=notify_on_submission|>\n-\n-<|{selected_scenario}|scenario_dag|>\n-|>\n-\n-<|part|partial={data_node_partial}|render={selected_data_node}|>\n-\n-|>\ndiff --git a/taipy/templates/sdm/{{cookiecutter.__root_folder}}/pages/scenario_page/scenario_page.py b/taipy/templates/sdm/{{cookiecutter.__root_folder}}/pages/scenario_page/scenario_page.py\nindex 3e791b1806..2ae27ca268 100644\n--- a/taipy/templates/sdm/{{cookiecutter.__root_folder}}/pages/scenario_page/scenario_page.py\n+++ b/taipy/templates/sdm/{{cookiecutter.__root_folder}}/pages/scenario_page/scenario_page.py\n@@ -9,7 +9,8 @@\n # an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n # specific language governing permissions and limitations under the License.\n \n-from taipy.gui import Markdown, notify\n+import taipy.gui.builder as tgb\n+from taipy.gui import notify\n \n from .data_node_management import manage_partial\n \n@@ -27,4 +28,16 @@ def manage_data_node_partial(state):\n     manage_partial(state)\n \n \n-scenario_page = Markdown(\"pages/scenario_page/scenario_page.md\")\n+with tgb.Page() as scenario_page:\n+    with tgb.layout(columns=\"1, 1\"):\n+        with tgb.part(render=\"{selected_scenario}\"):\n+            tgb.scenario(\n+                \"{selected_scenario}\",\n+                expandable=False,\n+                expanded=True,\n+                on_submission_change=notify_on_submission,\n+            )\n+\n+            tgb.scenario_dag(\"{selected_scenario}\")\n+\n+        tgb.part(partial=\"{data_node_partial}\", render=\"{selected_data_node}\")\n", "test_patch": "diff --git a/tests/templates/test_default_template.py b/tests/templates/test_default_template.py\nindex 61fef9902f..5574a084c9 100644\n--- a/tests/templates/test_default_template.py\n+++ b/tests/templates/test_default_template.py\n@@ -145,7 +145,7 @@ def test_multipage_gui_template(tmpdir):\n \n     assert sorted(os.listdir(os.path.join(tmpdir, \"foo_app\"))) == sorted([\"requirements.txt\", \"main.py\", \"pages\"])\n     assert sorted(os.listdir(os.path.join(tmpdir, \"foo_app\", \"pages\"))) == sorted(\n-        [\"name_1\", \"name_2\", \"name_3\", \"root.md\", \"root.py\", \"__init__.py\"]\n+        [\"name_1\", \"name_2\", \"name_3\", \"root.py\", \"__init__.py\"]\n     )\n \n     taipy_path = os.getcwd()\n", "problem_statement": "Convert templates from Markdown to TGB\n### Description\n\nWe want to push the Python API instead of the Markdown API.\n\n### Acceptance Criteria\n\n\n\n\n### Code of Conduct\n\n- [x] I have checked the [existing issues](https://github.com/Avaiga/taipy/issues?q=is%3Aissue+).\n- [ ] I am willing to work on this issue (optional)\n", "hints_text": "hey @jrobinAV  Can you describe more? \r\nCorrect me if i am wrong but as per this issue you want to conver all of the markdown to taipy graphical builder. \r\nBut here, I dont see much of markdown code.\r\n![image](https://github.com/user-attachments/assets/c58c5b55-1727-4195-8d72-a5f632b6c323)\r\n\r\nIf i am searching for it in the wrong place then where can i see the markdown code which is to be converted?\nHello @Ujj1225,\n\nIndeed, there is not much to convert. \n\nOn the default template: \n- In `pages/root.py`. Instead of using a Markdown page from `pages/root.md`, we want to use the GUI builder.\n- The Same in `pages/page_example/page_example.py`, where we don't want to use the `pages/page_example/page_example.md` anymore.\n \nOn the default template:\n- In `pages/root.py`. Instead of using a Markdown page from `pages/root.md`, we want to use the GUI builder.\n- The Same in `pages/scenario_page/scenario_page.py`. We no longer want to use `pages/scenario_page/scenario_page.md`.\n- - The Same in `pages/job_page/job_page.py`. We no longer want to use `pages/job_page/job_page.md`.\n\nDo you want to be assigned to the issue?", "created_at": "2024-12-24T09:13:20Z"}
{"repo": "Avaiga/taipy", "pull_number": 2357, "instance_id": "Avaiga__taipy-2357", "issue_numbers": ["562"], "base_commit": "d353533072ed47cf8c71421eef26f4ba36735b81", "patch": "diff --git a/taipy/gui_core/_context.py b/taipy/gui_core/_context.py\nindex 02355b2d40..5ff66032aa 100644\n--- a/taipy/gui_core/_context.py\n+++ b/taipy/gui_core/_context.py\n@@ -33,7 +33,6 @@\n     Sequence,\n     SequenceId,\n     Submission,\n-    SubmissionId,\n     cancel_job,\n     create_scenario,\n     delete_job,\n@@ -155,7 +154,7 @@ def scenario_refresh(self, scenario_id: t.Optional[str]):\n         self.broadcast_core_changed({\"scenario\": scenario_id or True})\n \n     def submission_status_callback(self, submission_id: t.Optional[str] = None, event: t.Optional[Event] = None):\n-        if not submission_id or not is_readable(t.cast(SubmissionId, submission_id)):\n+        if not submission_id:\n             return\n         submission = None\n         new_status: t.Optional[SubmissionStatus] = None\n", "test_patch": "diff --git a/tests/gui_core/test_context_is_readable.py b/tests/gui_core/test_context_is_readable.py\nindex 389dcf747b..528a0219bd 100644\n--- a/tests/gui_core/test_context_is_readable.py\n+++ b/tests/gui_core/test_context_is_readable.py\n@@ -213,10 +213,6 @@ def sub_cb():\n             assert found is True\n             mockget.reset_mock()\n \n-            with patch(\"taipy.gui_core._context.is_readable\", side_effect=mock_is_readable_false):\n-                gui_core_context.submission_status_callback(a_submission.id)\n-                mockget.assert_not_called()\n-\n     def test_data_node_adapter(self):\n         with patch(\"taipy.gui_core._context.core_get\", side_effect=mock_core_get):\n             gui_core_context = _GuiCoreContext(Mock())\n@@ -384,7 +380,7 @@ def test_get_scenarios_for_owner(self):\n             mockget.reset_mock()\n \n             with patch(\"taipy.gui_core._context.is_readable\", side_effect=mock_is_readable_false):\n-                gui_core_context.submission_status_callback(a_scenario.id)\n+                gui_core_context.get_scenarios_for_owner(a_scenario.id)\n                 mockget.assert_not_called()\n \n     def test_update_data(self):\n", "problem_statement": "partial.update_content() not updating as expected\n**Description**\nI expected partial.update_content() to immediately change a partial, which would allow for a dynamic element. In a callback there is immediate reaction to changes in the bound variables, but partial.update_content() seems to execute after the callback has finished. This leads to a raised exception in the example. \n\n**How to reproduce**\n```python\nimport taipy as tp\n\n\ndef make_partial(state):\n    state.my_partial.update_content(state, \"\"\"<|empty|>\"\"\")\n\n    if state.select == \"with Y\":\n        state.data_for_display = state.data\n    else:\n        state.data_for_display = state.data2\n\n    content = \"\"\"<|\n\"\"\"\n    for key in state.data_for_display.keys():\n        content = (\n            content + key + \"\"\" = <|{data_for_display['\"\"\" + key + \"\"\"']}|><br />\"\"\"\n        )\n    content = (\n        content\n        + \"\"\"\n|>\"\"\"\n    )\n\n    state.my_partial.update_content(state, content)\n\n\nif __name__ == \"__main__\":\n    data = {\"x\": \"X\", \"y\": \"Y\"}\n    data2 = {\"x\": \"X\"}\n\n    data_for_display = data\n    select = 1\n\n    gui = tp.Gui()\n    gui.add_page(\n        \"page\",\n        page=\"\"\"\n<|selector|value={select}|lov={['with Y','Exception without Y']}|adapter={lambda i: str(i)}|on_change=make_partial|>\n<br />\n<|part|partial={my_partial}|>  \n\"\"\",\n    )\n\n    my_partial = gui.add_partial(page=\"\"\"\"\"\")\n\n    tp.run(gui)\n```\n\n\n", "hints_text": "partial update is asynchronous by design\nyou could add a bit of test in your expression to avoid the exception\n\n```python\nfrom taipy.gui import Gui\n\n\ndef make_partial(state):\n    state.my_partial.update_content(state, \"<|empty|>\")\n\n    if state.select == \"with Y\":\n        state.data_for_display = state.data\n    else:\n        state.data_for_display = state.data2\n\n    content = \"\"\"<|\n\"\"\"\n    for key in state.data_for_display.keys():\n        content = f\"{content}{key} = <|{{data_for_display['{key}'] if '{key}' in data_for_display else ''}}|><br />\"\n    content += \"\"\"\n|>\"\"\"\n\n    state.my_partial.update_content(state, content)\n\n\nif __name__ == \"__main__\":\n    data = {\"x\": \"X\", \"y\": \"Y\"}\n    data2 = {\"x\": \"X\"}\n\n    data_for_display = data\n    select = None\n\n    gui = Gui()\n    gui.add_page(\n        \"page\",\n        page=\"\"\"\n<|selector|value={select}|lov=with Y;Exception without Y|on_change=make_partial|>\n<br />\n<|part|partial={my_partial}|>\n\"\"\",\n    )\n\n    my_partial = gui.add_partial(page=\"\")\n\n    gui.run()\n\n```\nDoes that answer your question @chrisOnWheels ?\nHi Fred,\r\n \r\nthis is exactly what I'm doing. Change the underlying data first, then rebuild/adapt the content for the partial, finally call update_partial. But I keep getting these exceptions.\r\nMy only problem is that these exceptions spam the console.\r\n \r\nBest regards,\r\nChris\r\n \r\n\r\n> Fred Lef\u00e9v\u00e8re-Laoide ***@***.***> hat am 14.09.2023 17:27 GMT geschrieben:\r\n>  \r\n>  \r\n> \r\n>  \r\n> \r\n> you could add a bit of test in your expression to avoid the exception\r\n> \r\n> from taipy.gui import Gui\r\n> \r\n> \r\n> def make_partial(state):\r\n> state.my_partial.update_content(state, \"<|empty|>\")\r\n> \r\n> if state.select == \"with Y\":\r\n> state.data_for_display = state.data\r\n> else:\r\n> state.data_for_display = state.data2\r\n> \r\n> content = \"\"\"<|\r\n> \"\"\"\r\n> for key in state.data_for_display.keys():\r\n> content = f\"{content}{key} = <|{{data_for_display['{key}'] if '{key}' in data_for_display else ''}}|><br />\"\r\n> content += \"\"\"\r\n> |>\"\"\"\r\n> \r\n> state.my_partial.update_content(state, content)\r\n> \r\n> \r\n> if __name__ == \"__main__\":\r\n> data = {\"x\": \"X\", \"y\": \"Y\"}\r\n> data2 = {\"x\": \"X\"}\r\n> \r\n> data_for_display = data\r\n> select = None\r\n> \r\n> gui = Gui()\r\n> gui.add_page(\r\n> \"page\",\r\n> page=\"\"\"\r\n> <|selector|value={select}|lov=with Y;Exception without Y|on_change=make_partial|>\r\n> <br />\r\n> <|part|partial={my_partial}|>\r\n> \"\"\",\r\n> )\r\n> \r\n> my_partial = gui.add_partial(page=\"\")\r\n> \r\n> gui.run()\r\n> \r\n> \r\n> \u2014\r\n> Reply to this email directly, view it on GitHub https://github.com/Avaiga/taipy/issues/562, or unsubscribe https://github.com/notifications/unsubscribe-auth/BB46L2Z3OCFIIQBBCI43BJDX2M46NANCNFSM6AAAAAA3SBI3GA.\r\n> You are receiving this because you authored the thread.Message ID: ***@***.***>\r\n> \r\n\nI don't get any exception with the code I provided.\nCan you give me some example ?\nI will try to isolate it, it's gonna take a while\r\n\r\n> Fred Lef\u00e9v\u00e8re-Laoide ***@***.***> hat am 19.09.2023 07:47 GMT geschrieben:\r\n>  \r\n>  \r\n> \r\n>  \r\n> \r\n> I don't get any exception with the code provided.\r\n> Can you give me some example ?\r\n> \r\n> \u2014\r\n> Reply to this email directly, view it on GitHub https://github.com/Avaiga/taipy/issues/562, or unsubscribe https://github.com/notifications/unsubscribe-auth/BB46L23GNSGFTBABZAXGR43X3FE2HANCNFSM6AAAAAA3SBI3GA.\r\n> You are receiving this because you were mentioned.Message ID: ***@***.***>\r\n> \r\n\n\ud83d\udc4d\nHi @chrisOnWheels \nIs this issue still relevant ?\nI'll not be working on the project in the near future, so it's up to you.\r\nThanks for the support :-)\nHere is a modified version of the code that works properly.\r\n\r\nAll I did was postpone the update of state.data_for_display until just before the partial gets updated.\r\nPlease let us know if this works for you, so we can Close the issue with a smile on our faces.\r\n\r\n```python\r\nimport taipy as tp\r\n\r\n\r\ndef make_partial(state):\r\n    state.my_partial.update_content(state, \"<|empty|>\")\r\n\r\n    new_data = data if state.select == \"with Y\" else data2\r\n    content = \"<|\\n\"\r\n    for key in new_data.keys():\r\n        content = content + key + f\" = <|{{data_for_display['{key}']}}|><br />\\n\"\r\n    content = content + \"|>\"\r\n\r\n    state.data_for_display = new_data\r\n    state.my_partial.update_content(state, content)\r\n\r\n\r\ndata = {\"x\": \"X\", \"y\": \"Y\"}\r\ndata2 = {\"x\": \"X\"}\r\n\r\nif __name__ == \"__main__\":\r\n\r\n    data_for_display = data\r\n    select = 1\r\n\r\n    gui = tp.Gui()\r\n    gui.add_page(\r\n        \"page\",\r\n        page=\"\"\"\r\n<|selector|value={select}|lov={['with Y','Exception without Y']}|adapter={lambda i: str(i)}|on_change=make_partial|>\r\n<br />\r\n<|part|partial={my_partial}|>  \r\n\"\"\",\r\n    )\r\n\r\n    my_partial = gui.add_partial(page=\"<|empty|>\")\r\n\r\n    tp.run(gui)\r\n``` \nClosed as answered. ", "created_at": "2024-12-19T08:13:17Z"}
{"repo": "Avaiga/taipy", "pull_number": 2355, "instance_id": "Avaiga__taipy-2355", "issue_numbers": ["2152", "2152"], "base_commit": "11ff2778e86668b082ba6f44243bff8e63fc574e", "patch": "diff --git a/frontend/taipy-gui/public/stylekit/controls/button.css b/frontend/taipy-gui/public/stylekit/controls/button.css\nindex 9bf4d9a171..f2b1e56a6e 100644\n--- a/frontend/taipy-gui/public/stylekit/controls/button.css\n+++ b/frontend/taipy-gui/public/stylekit/controls/button.css\n@@ -21,6 +21,10 @@\n               MODIFIER CLASSES\n **************************************************/\n \n+.taipy-button {\n+    margin: 4px 0;\n+}\n+\n /* fullwidth :  */\n .taipy-button.fullwidth {\n     display: flex;\ndiff --git a/frontend/taipy-gui/public/stylekit/controls/file_download.css b/frontend/taipy-gui/public/stylekit/controls/file_download.css\nindex 54085e4b4c..903818c918 100644\n--- a/frontend/taipy-gui/public/stylekit/controls/file_download.css\n+++ b/frontend/taipy-gui/public/stylekit/controls/file_download.css\n@@ -20,6 +20,9 @@\n /*************************************************\n               MODIFIER CLASSES\n **************************************************/\n+.taipy-file-download>button {\n+    margin: 4px 0;\n+}\n \n /* fullwidth :  */\n .taipy-file-download.fullwidth button {\ndiff --git a/frontend/taipy-gui/public/stylekit/controls/file_selector.css b/frontend/taipy-gui/public/stylekit/controls/file_selector.css\nindex 08515985d8..d99757cdb8 100644\n--- a/frontend/taipy-gui/public/stylekit/controls/file_selector.css\n+++ b/frontend/taipy-gui/public/stylekit/controls/file_selector.css\n@@ -20,6 +20,9 @@\n /*************************************************\n               MODIFIER CLASSES\n **************************************************/\n+.taipy-file-selector .MuiButtonBase-root {\n+    margin: 4px 0;\n+}\n \n /* fullwidth :  */\n .taipy-file-selector.fullwidth [role='button'] {\ndiff --git a/frontend/taipy-gui/public/stylekit/controls/selector.css b/frontend/taipy-gui/public/stylekit/controls/selector.css\nindex 0e56ecdc7d..cdb929aca4 100644\n--- a/frontend/taipy-gui/public/stylekit/controls/selector.css\n+++ b/frontend/taipy-gui/public/stylekit/controls/selector.css\n@@ -22,7 +22,7 @@\n **************************************************/\n \n .taipy-selector {\n-  margin: 0;\n+  margin: 4px 0;\n }\n \n \ndiff --git a/frontend/taipy-gui/public/stylekit/controls/slider.css b/frontend/taipy-gui/public/stylekit/controls/slider.css\nindex 4bba39e40a..e978642689 100644\n--- a/frontend/taipy-gui/public/stylekit/controls/slider.css\n+++ b/frontend/taipy-gui/public/stylekit/controls/slider.css\n@@ -26,4 +26,5 @@\n     max-width: 100%;\n     min-height: 48px;\n     align-items: center;\n+    margin: 4px 0;\n }\ndiff --git a/frontend/taipy-gui/public/stylekit/controls/status.css b/frontend/taipy-gui/public/stylekit/controls/status.css\nindex c0e1d73381..3643303e77 100644\n--- a/frontend/taipy-gui/public/stylekit/controls/status.css\n+++ b/frontend/taipy-gui/public/stylekit/controls/status.css\n@@ -25,4 +25,5 @@\n     display: inline-flex;\n     min-height: 48px;\n     padding-top: 0.5em;\n+    margin: 4px 0;\n }\ndiff --git a/frontend/taipy-gui/public/stylekit/controls/toggle.css b/frontend/taipy-gui/public/stylekit/controls/toggle.css\nindex 7ff2b1afe9..2a75e9ee5e 100644\n--- a/frontend/taipy-gui/public/stylekit/controls/toggle.css\n+++ b/frontend/taipy-gui/public/stylekit/controls/toggle.css\n@@ -36,6 +36,9 @@\n /*************************************************\n               MODIFIER CLASSES\n **************************************************/\n+.taipy-toggle {\n+    margin: 4px 0;\n+}\n \n /* relative : Reset the theme toggle position to fit page flow */\n .taipy-toggle.relative {\ndiff --git a/taipy/gui_core/_context.py b/taipy/gui_core/_context.py\nindex 82f8b7bdad..59ba3dddad 100644\n--- a/taipy/gui_core/_context.py\n+++ b/taipy/gui_core/_context.py\n@@ -33,7 +33,6 @@\n     Sequence,\n     SequenceId,\n     Submission,\n-    SubmissionId,\n     can_create,\n     cancel_job,\n     create_scenario,\n@@ -166,67 +165,64 @@ def submission_status_callback(self, submission_id: t.Optional[str] = None, even\n         if not submission_id:\n             return\n         submission = None\n-        new_status = None\n+        new_status: t.Optional[SubmissionStatus] = None\n         payload: t.Optional[t.Dict[str, t.Any]] = None\n         client_id: t.Optional[str] = None\n+        submission_name: t.Optional[str] = None\n         try:\n-            last_client_status = self.client_submission.get(submission_id)\n-            if not last_client_status:\n+            submission = t.cast(Submission, core_get(submission_id))\n+            if not submission or not submission.entity_id:\n                 return\n+            new_status = submission.submission_status\n \n-            client_id = last_client_status.client_id\n-\n-            with self.gui._get_authorization(client_id):\n-                if not is_readable(t.cast(SubmissionId, submission_id)):\n-                    return\n-                submission = t.cast(Submission, core_get(submission_id))\n-                if not submission or not submission.entity_id:\n+            with self.submissions_lock:\n+                last_client_status = self.client_submission.get(submission_id)\n+                if not last_client_status:\n                     return\n \n                 payload = {}\n-                new_status = t.cast(SubmissionStatus, submission.submission_status)\n-\n-                if client_id:\n-                    running_tasks = {}\n-                    # with self.gui._get_authorization(client_id):\n-                    for job in submission.jobs:\n-                        job = job if isinstance(job, Job) else t.cast(Job, core_get(job))\n-                        running_tasks[job.task.id] = (\n-                            SubmissionStatus.RUNNING.value\n-                            if job.is_running()\n-                            else SubmissionStatus.PENDING.value\n-                            if job.is_pending()\n-                            else None\n-                        )\n-                    payload.update(tasks=running_tasks)\n-\n-                    if last_client_status.submission_status is not new_status:\n-                        # callback\n-                        submission_name = submission.properties.get(\"on_submission\")\n-                        if submission_name:\n-                            self.gui.invoke_callback(\n-                                client_id,\n-                                submission_name,\n-                                [\n-                                    core_get(submission.id),\n-                                    {\n-                                        \"submission_status\": new_status.name,\n-                                        \"submittable_entity\": core_get(submission.entity_id),\n-                                        **(event.metadata if event else {}),\n-                                    },\n-                                ],\n-                                submission.properties.get(\"module_context\"),\n+                if last_client_status.submission_status is not new_status:\n+                    # callback\n+                    submission_name = submission.properties.get(\"on_submission\")\n+\n+                if new_status in (\n+                    SubmissionStatus.COMPLETED,\n+                    SubmissionStatus.FAILED,\n+                    SubmissionStatus.CANCELED,\n+                ):\n+                    self.client_submission.pop(submission_id, None)\n+                else:\n+                    last_client_status.submission_status = new_status\n+\n+            if client_id:= submission.properties.get(\"client_id\"):\n+                with self.gui._get_authorization(client_id):\n+                    if payload is not None:\n+                        running_tasks = {}\n+                        for job in submission.jobs:\n+                            job = job if isinstance(job, Job) else t.cast(Job, core_get(job))\n+                            running_tasks[job.task.id] = (\n+                                SubmissionStatus.RUNNING.value\n+                                if job.is_running()\n+                                else SubmissionStatus.PENDING.value\n+                                if job.is_pending()\n+                                else None\n                             )\n+                        payload.update(tasks=running_tasks)\n \n-            if new_status in (\n-                SubmissionStatus.COMPLETED,\n-                SubmissionStatus.FAILED,\n-                SubmissionStatus.CANCELED,\n-            ):\n-                with self.submissions_lock:\n-                    self.client_submission.pop(submission_id, None)\n-            else:\n-                last_client_status.submission_status = new_status\n+                    if submission_name:\n+                        self.gui.invoke_callback(\n+                            client_id,\n+                            submission_name,\n+                            [\n+                                core_get(submission.id),\n+                                {\n+                                    \"submission_status\": new_status.name if new_status else \"None\",\n+                                    \"submittable_entity\": core_get(submission.entity_id),\n+                                    **(event.metadata if event else {}),\n+                                },\n+                            ],\n+                            submission.properties.get(\"module_context\"),\n+                        )\n \n         except Exception as e:\n             _warn(f\"Submission ({submission_id}) is not available\", e)\n", "test_patch": "diff --git a/tests/gui_core/test_context_is_readable.py b/tests/gui_core/test_context_is_readable.py\nindex d321f31fb6..a2a4101bc9 100644\n--- a/tests/gui_core/test_context_is_readable.py\n+++ b/tests/gui_core/test_context_is_readable.py\n@@ -215,10 +215,6 @@ def test_submission_status_callback(self):\n             assert found is True\n             mockget.reset_mock()\n \n-            with patch(\"taipy.gui_core._context.is_readable\", side_effect=mock_is_readable_false):\n-                gui_core_context.submission_status_callback(a_submission.id)\n-                mockget.assert_not_called()\n-\n     def test_data_node_adapter(self):\n         with patch(\"taipy.gui_core._context.core_get\", side_effect=mock_core_get):\n             gui_core_context = _GuiCoreContext(Mock())\n@@ -386,7 +382,7 @@ def test_get_scenarios_for_owner(self):\n             mockget.reset_mock()\n \n             with patch(\"taipy.gui_core._context.is_readable\", side_effect=mock_is_readable_false):\n-                gui_core_context.submission_status_callback(a_scenario.id)\n+                gui_core_context.get_scenarios_for_owner(a_scenario.id)\n                 mockget.assert_not_called()\n \n     def test_update_data(self):\n", "problem_statement": "[\ud83d\udc1b BUG] On_submission_change - submission is completed twice\n### What went wrong? \ud83e\udd14\n\nThe callback is called twice sometimes with the same parameters. It leads to notifying twice the user that the scenario is completed.\n\n## How to replicate\n\n```python\nfrom taipy import Config\nimport taipy as tp\nfrom taipy.gui import Gui, notify\n\n\n# Normal function used by Taipy\ndef double(nb):\n    return nb * 2\n\n\n# Configuration of Data Nodes\ninput_cfg = Config.configure_data_node(\"input_dn\", default_data=21)\noutput_cfg = Config.configure_data_node(\"output_dn\")\n\n\n# Configuration of tasks\nfirst_task_cfg = Config.configure_task(\"double\",\n                                       double,\n                                       input_cfg,\n                                       output_cfg)\n\n\n# Configuration of scenario\nscenario_cfg = Config.configure_scenario(id=\"my_scenario\",\n                                         task_configs=[first_task_cfg],\n                                         name=\"my_scenario\")\n\n\n\ndef notify_from_submissions(state, submittable, details):\n    submission_status = details.get('submission_status')\n\n    if submission_status == 'COMPLETED':\n        print(\"COMPLETED\")\n        print(submittable)\n        print(details)\n        notify(state, 'success', 'Completed!')\n        # Add additional actions here, like updating the GUI or logging the completion.\n\n    elif submission_status == 'FAILED':\n        print(\"FAILED\")\n        notify(state, 'error', 'FAILED!')\n        # Handle failure, like sending notifications or logging the error.\n\n\nif __name__==\"__main__\":\n    tp.Orchestrator().run()\n    scenario_1 = tp.create_scenario(scenario_cfg)\n\n    scenario_md = \"\"\"\n<|{scenario_1}|scenario|on_submission_change=notify_from_submissions|>\n\"\"\"\n    Gui(scenario_md).run()\n```\n\nThis is what I receive sometimes. The callback is called twice:\n\n```console\n[2024-10-25 11:50:04.385][Taipy][INFO] job JOB_double_bd8e666f-5ce5-40ad-8694-af7d02a3faec is completed.\nCOMPLETED\nCOMPLETED\n<taipy.core.submission.submission.Submission object at 0x000001BAC6CCCE90>\n<taipy.core.submission.submission.Submission object at 0x000001BAC6CCD310>\n{'submission_status': 'COMPLETED', 'submittable_entity': my_scenario, 'origin_entity_id': 'SCENARIO_my_scenario_6c3d70af-a896-46f8-a0dc-4f17628b29d4', 'origin_entity_type': 'SCENARIO', 'origin_entity_config_id': 'my_scenario', 'creation_date': datetime.datetime(2024, 10, 25, 11, 50, 4, 207191), 'version': '5395d6e1-e5b7-4c2e-a391-7f71d04e8047', 'job_triggered_submission_status_changed': 'JOB_double_bd8e666f-5ce5-40ad-8694-af7d02a3faec'}\n{'submission_status': 'COMPLETED', 'submittable_entity': my_scenario}\n```\n\n## Expected behavior\n\nThis callback should be called once with these parameters\n\n### Version of Taipy\n\n- release/4.0\n- develop\n\n### Acceptance Criteria\n\n- [ ] A unit test reproducing the bug is added.\n- [ ] Any new code is covered by a unit tested.\n- [ ] Check code coverage is at least 90%.\n- [ ] The bug reporter validated the fix.\n- [ ] Related issue(s) in taipy-doc are created for documentation and Release Notes are updated.\n\n\n### Code of Conduct\n\n- [X] I have checked the [existing issues](https://github.com/Avaiga/taipy/issues?q=is%3Aissue+).\n- [ ] I am willing to work on this issue (optional)\n[\ud83d\udc1b BUG] On_submission_change - submission is completed twice\n### What went wrong? \ud83e\udd14\n\nThe callback is called twice sometimes with the same parameters. It leads to notifying twice the user that the scenario is completed.\n\n## How to replicate\n\n```python\nfrom taipy import Config\nimport taipy as tp\nfrom taipy.gui import Gui, notify\n\n\n# Normal function used by Taipy\ndef double(nb):\n    return nb * 2\n\n\n# Configuration of Data Nodes\ninput_cfg = Config.configure_data_node(\"input_dn\", default_data=21)\noutput_cfg = Config.configure_data_node(\"output_dn\")\n\n\n# Configuration of tasks\nfirst_task_cfg = Config.configure_task(\"double\",\n                                       double,\n                                       input_cfg,\n                                       output_cfg)\n\n\n# Configuration of scenario\nscenario_cfg = Config.configure_scenario(id=\"my_scenario\",\n                                         task_configs=[first_task_cfg],\n                                         name=\"my_scenario\")\n\n\n\ndef notify_from_submissions(state, submittable, details):\n    submission_status = details.get('submission_status')\n\n    if submission_status == 'COMPLETED':\n        print(\"COMPLETED\")\n        print(submittable)\n        print(details)\n        notify(state, 'success', 'Completed!')\n        # Add additional actions here, like updating the GUI or logging the completion.\n\n    elif submission_status == 'FAILED':\n        print(\"FAILED\")\n        notify(state, 'error', 'FAILED!')\n        # Handle failure, like sending notifications or logging the error.\n\n\nif __name__==\"__main__\":\n    tp.Orchestrator().run()\n    scenario_1 = tp.create_scenario(scenario_cfg)\n\n    scenario_md = \"\"\"\n<|{scenario_1}|scenario|on_submission_change=notify_from_submissions|>\n\"\"\"\n    Gui(scenario_md).run()\n```\n\nThis is what I receive sometimes. The callback is called twice:\n\n```console\n[2024-10-25 11:50:04.385][Taipy][INFO] job JOB_double_bd8e666f-5ce5-40ad-8694-af7d02a3faec is completed.\nCOMPLETED\nCOMPLETED\n<taipy.core.submission.submission.Submission object at 0x000001BAC6CCCE90>\n<taipy.core.submission.submission.Submission object at 0x000001BAC6CCD310>\n{'submission_status': 'COMPLETED', 'submittable_entity': my_scenario, 'origin_entity_id': 'SCENARIO_my_scenario_6c3d70af-a896-46f8-a0dc-4f17628b29d4', 'origin_entity_type': 'SCENARIO', 'origin_entity_config_id': 'my_scenario', 'creation_date': datetime.datetime(2024, 10, 25, 11, 50, 4, 207191), 'version': '5395d6e1-e5b7-4c2e-a391-7f71d04e8047', 'job_triggered_submission_status_changed': 'JOB_double_bd8e666f-5ce5-40ad-8694-af7d02a3faec'}\n{'submission_status': 'COMPLETED', 'submittable_entity': my_scenario}\n```\n\n## Expected behavior\n\nThis callback should be called once with these parameters\n\n### Version of Taipy\n\n- release/4.0\n- develop\n\n### Acceptance Criteria\n\n- [ ] A unit test reproducing the bug is added.\n- [ ] Any new code is covered by a unit tested.\n- [ ] Check code coverage is at least 90%.\n- [ ] The bug reporter validated the fix.\n- [ ] Related issue(s) in taipy-doc are created for documentation and Release Notes are updated.\n\n\n### Code of Conduct\n\n- [X] I have checked the [existing issues](https://github.com/Avaiga/taipy/issues?q=is%3Aissue+).\n- [ ] I am willing to work on this issue (optional)\n", "hints_text": "Hmmm I'm running it on the develop branch and it doesn't seem to have this issue\r\n![image](https://github.com/user-attachments/assets/a0f69c6c-d456-437a-be4a-f5db99d87e9d)\r\n\nBut the problem does happen on 4.0!\r\n![image](https://github.com/user-attachments/assets/541d8390-8418-42d4-85b3-46ab64aac632)\r\n\nI can see it is closed. \r\nIt should be backported to release/4.0. Did I miss the PR for the backport, or is it planned for the future?\r\n@toan-quach @FredLL-Avaiga \nI guess @FabienLelaquais has backported this ?\nAll right. Thx!\nIt doesn't seem to be fixed in 4.0.2.dev1.\r\n\r\n```\r\n[2024-12-18 14:47:46.742][Taipy][INFO] Updating configuration with command-line arguments...\r\n[2024-12-18 14:47:46.743][Taipy][INFO] Managing application's version...\r\n[2024-12-18 14:47:46.744][Taipy][INFO] Development mode: Clean all entities of version 1b849301-77bb-43bd-b4c4-c4f0f33d15b5\r\n[2024-12-18 14:47:46.793][Taipy][INFO] Checking application's version...\r\n[2024-12-18 14:47:46.794][Taipy][INFO] Blocking configuration update...\r\n[2024-12-18 14:47:46.795][Taipy][INFO] Starting job dispatcher...\r\n[2024-12-18 14:47:46.798][Taipy][INFO] Orchestrator service has been started.\r\n[2024-12-18 14:47:48.220][Taipy][INFO]  * Server starting on http://127.0.0.1:5000\r\n[2024-12-18 14:47:52.302][Taipy][INFO] job JOB_double_2312965a-c72d-4649-aa26-53e9a2c74e68 is completed.\r\nCOMPLETED\r\n<taipy.core.submission.submission.Submission object at 0x000002B99723BC10>\r\nCOMPLETED\r\n<taipy.core.submission.submission.Submission object at 0x000002B9972600D0>\r\n{'submission_status': 'COMPLETED', 'submittable_entity': my_scenario}\r\n{'submission_status': 'COMPLETED', 'submittable_entity': my_scenario, 'origin_entity_id': 'SCENARIO_my_scenario_069b8ca0-845d-4929-a1bc-b59341925b2c', 'origin_entity_type': 'SCENARIO', 'origin_entity_config_id': 'my_scenario', 'creation_date': datetime.datetime(2024, 12, 18, 14, 47, 52, 88398), 'version': '1b849301-77bb-43bd-b4c4-c4f0f33d15b5', 'job_triggered_submission_status_changed': 'JOB_double_2312965a-c72d-4649-aa26-53e9a2c74e68'}\r\n```\non it\nHmmm I'm running it on the develop branch and it doesn't seem to have this issue\r\n![image](https://github.com/user-attachments/assets/a0f69c6c-d456-437a-be4a-f5db99d87e9d)\r\n\nBut the problem does happen on 4.0!\r\n![image](https://github.com/user-attachments/assets/541d8390-8418-42d4-85b3-46ab64aac632)\r\n\nI can see it is closed. \r\nIt should be backported to release/4.0. Did I miss the PR for the backport, or is it planned for the future?\r\n@toan-quach @FredLL-Avaiga \nI guess @FabienLelaquais has backported this ?\nAll right. Thx!\nIt doesn't seem to be fixed in 4.0.2.dev1.\r\n\r\n```\r\n[2024-12-18 14:47:46.742][Taipy][INFO] Updating configuration with command-line arguments...\r\n[2024-12-18 14:47:46.743][Taipy][INFO] Managing application's version...\r\n[2024-12-18 14:47:46.744][Taipy][INFO] Development mode: Clean all entities of version 1b849301-77bb-43bd-b4c4-c4f0f33d15b5\r\n[2024-12-18 14:47:46.793][Taipy][INFO] Checking application's version...\r\n[2024-12-18 14:47:46.794][Taipy][INFO] Blocking configuration update...\r\n[2024-12-18 14:47:46.795][Taipy][INFO] Starting job dispatcher...\r\n[2024-12-18 14:47:46.798][Taipy][INFO] Orchestrator service has been started.\r\n[2024-12-18 14:47:48.220][Taipy][INFO]  * Server starting on http://127.0.0.1:5000\r\n[2024-12-18 14:47:52.302][Taipy][INFO] job JOB_double_2312965a-c72d-4649-aa26-53e9a2c74e68 is completed.\r\nCOMPLETED\r\n<taipy.core.submission.submission.Submission object at 0x000002B99723BC10>\r\nCOMPLETED\r\n<taipy.core.submission.submission.Submission object at 0x000002B9972600D0>\r\n{'submission_status': 'COMPLETED', 'submittable_entity': my_scenario}\r\n{'submission_status': 'COMPLETED', 'submittable_entity': my_scenario, 'origin_entity_id': 'SCENARIO_my_scenario_069b8ca0-845d-4929-a1bc-b59341925b2c', 'origin_entity_type': 'SCENARIO', 'origin_entity_config_id': 'my_scenario', 'creation_date': datetime.datetime(2024, 12, 18, 14, 47, 52, 88398), 'version': '1b849301-77bb-43bd-b4c4-c4f0f33d15b5', 'job_triggered_submission_status_changed': 'JOB_double_2312965a-c72d-4649-aa26-53e9a2c74e68'}\r\n```\non it", "created_at": "2024-12-18T16:03:58Z"}
{"repo": "Avaiga/taipy", "pull_number": 2342, "instance_id": "Avaiga__taipy-2342", "issue_numbers": ["2152", "2152"], "base_commit": "1a4b844baff70e1eb4afdffb00ab97777f7b76d9", "patch": "diff --git a/taipy/gui_core/_context.py b/taipy/gui_core/_context.py\nindex 0823b8b10d..1d8cb6cc77 100644\n--- a/taipy/gui_core/_context.py\n+++ b/taipy/gui_core/_context.py\n@@ -68,6 +68,7 @@\n     _GuiCoreScenarioProperties,\n     _invoke_action,\n )\n+from ._utils import _ClientStatus\n from .filters import CustomScenarioFilter\n \n \n@@ -89,7 +90,7 @@ def __init__(self, gui: Gui) -> None:\n         self.data_nodes_by_owner: t.Optional[t.Dict[t.Optional[str], t.List[DataNode]]] = None\n         self.scenario_configs: t.Optional[t.List[t.Tuple[str, str]]] = None\n         self.jobs_list: t.Optional[t.List[Job]] = None\n-        self.client_submission: t.Dict[str, SubmissionStatus] = {}\n+        self.client_submission: t.Dict[str, _ClientStatus] = {}\n         # register to taipy core notification\n         reg_id, reg_queue = Notifier.register()\n         # locks\n@@ -161,8 +162,8 @@ def submission_status_callback(self, submission_id: t.Optional[str] = None, even\n         payload: t.Optional[t.Dict[str, t.Any]] = None\n         client_id: t.Optional[str] = None\n         try:\n-            last_status = self.client_submission.get(submission_id)\n-            if not last_status:\n+            last_client_status = self.client_submission.get(submission_id)\n+            if not last_client_status:\n                 return\n \n             submission = t.cast(Submission, core_get(submission_id))\n@@ -187,7 +188,7 @@ def submission_status_callback(self, submission_id: t.Optional[str] = None, even\n                         )\n                     payload.update(tasks=running_tasks)\n \n-                    if last_status is not new_status:\n+                    if last_client_status.submission_status is not new_status:\n                         # callback\n                         submission_name = submission.properties.get(\"on_submission\")\n                         if submission_name:\n@@ -213,7 +214,7 @@ def submission_status_callback(self, submission_id: t.Optional[str] = None, even\n                 ):\n                     self.client_submission.pop(submission_id, None)\n                 else:\n-                    self.client_submission[submission_id] = new_status\n+                    last_client_status.submission_status = new_status\n \n         except Exception as e:\n             _warn(f\"Submission ({submission_id}) is not available\", e)\n@@ -617,11 +618,10 @@ def submit_entity(self, state: State, id: str, payload: t.Dict[str, str]):\n                     client_id=self.gui._get_client_id(),\n                     module_context=self.gui._get_locals_context(),\n                 )\n+                client_status = _ClientStatus(self.gui._get_client_id(), None)\n                 with self.submissions_lock:\n-                    self.client_submission[submission_entity.id] = submission_entity.submission_status\n+                    self.client_submission[submission_entity.id] = client_status\n                 if Config.core.mode == \"development\":\n-                    with self.submissions_lock:\n-                        self.client_submission[submission_entity.id] = SubmissionStatus.SUBMITTED\n                     self.submission_status_callback(submission_entity.id)\n                 _GuiCoreContext.__assign_var(state, error_var, \"\")\n         except Exception as e:\ndiff --git a/taipy/gui_core/_utils.py b/taipy/gui_core/_utils.py\nnew file mode 100644\nindex 0000000000..27fe9f09f1\n--- /dev/null\n+++ b/taipy/gui_core/_utils.py\n@@ -0,0 +1,20 @@\n+# Copyright 2021-2024 Avaiga Private Limited\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+# the License. You may obtain a copy of the License at\n+#\n+#        http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+# an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+# specific language governing permissions and limitations under the License.\n+import typing as t\n+from dataclasses import dataclass\n+\n+from taipy.core.submission.submission_status import SubmissionStatus\n+\n+\n+@dataclass\n+class _ClientStatus:\n+    client_id: t.Optional[str]\n+    submission_status: t.Optional[SubmissionStatus]\n", "test_patch": "diff --git a/tests/gui_core/test_context_is_readable.py b/tests/gui_core/test_context_is_readable.py\nindex 29242610ec..389dcf747b 100644\n--- a/tests/gui_core/test_context_is_readable.py\n+++ b/tests/gui_core/test_context_is_readable.py\n@@ -25,10 +25,11 @@\n from taipy.core.job._job_manager_factory import _JobManagerFactory\n from taipy.core.scenario._scenario_manager_factory import _ScenarioManagerFactory\n from taipy.core.submission._submission_manager_factory import _SubmissionManagerFactory\n-from taipy.core.submission.submission import Submission, SubmissionStatus\n+from taipy.core.submission.submission import Submission\n from taipy.core.task._task_manager_factory import _TaskManagerFactory\n from taipy.gui import Gui\n from taipy.gui_core._context import _GuiCoreContext\n+from taipy.gui_core._utils import _ClientStatus\n \n a_cycle = Cycle(Frequency.DAILY, {}, datetime.now(), datetime.now(), datetime.now(), id=CycleId(\"CYCLE_id\"))\n a_scenario = Scenario(\"scenario_config_id\", None, {}, sequences={\"sequence\": {}})\n@@ -201,7 +202,7 @@ def test_submission_status_callback(self):\n             def sub_cb():\n                 return True\n \n-            gui_core_context.client_submission[a_submission.id] = SubmissionStatus.UNDEFINED\n+            gui_core_context.client_submission[a_submission.id] = _ClientStatus(\"client_id\", None)\n             gui_core_context.submission_status_callback(a_submission.id)\n             mockget.assert_called()\n             found = False\n", "problem_statement": "[\ud83d\udc1b BUG] On_submission_change - submission is completed twice\n### What went wrong? \ud83e\udd14\n\nThe callback is called twice sometimes with the same parameters. It leads to notifying twice the user that the scenario is completed.\n\n## How to replicate\n\n```python\nfrom taipy import Config\nimport taipy as tp\nfrom taipy.gui import Gui, notify\n\n\n# Normal function used by Taipy\ndef double(nb):\n    return nb * 2\n\n\n# Configuration of Data Nodes\ninput_cfg = Config.configure_data_node(\"input_dn\", default_data=21)\noutput_cfg = Config.configure_data_node(\"output_dn\")\n\n\n# Configuration of tasks\nfirst_task_cfg = Config.configure_task(\"double\",\n                                       double,\n                                       input_cfg,\n                                       output_cfg)\n\n\n# Configuration of scenario\nscenario_cfg = Config.configure_scenario(id=\"my_scenario\",\n                                         task_configs=[first_task_cfg],\n                                         name=\"my_scenario\")\n\n\n\ndef notify_from_submissions(state, submittable, details):\n    submission_status = details.get('submission_status')\n\n    if submission_status == 'COMPLETED':\n        print(\"COMPLETED\")\n        print(submittable)\n        print(details)\n        notify(state, 'success', 'Completed!')\n        # Add additional actions here, like updating the GUI or logging the completion.\n\n    elif submission_status == 'FAILED':\n        print(\"FAILED\")\n        notify(state, 'error', 'FAILED!')\n        # Handle failure, like sending notifications or logging the error.\n\n\nif __name__==\"__main__\":\n    tp.Orchestrator().run()\n    scenario_1 = tp.create_scenario(scenario_cfg)\n\n    scenario_md = \"\"\"\n<|{scenario_1}|scenario|on_submission_change=notify_from_submissions|>\n\"\"\"\n    Gui(scenario_md).run()\n```\n\nThis is what I receive sometimes. The callback is called twice:\n\n```console\n[2024-10-25 11:50:04.385][Taipy][INFO] job JOB_double_bd8e666f-5ce5-40ad-8694-af7d02a3faec is completed.\nCOMPLETED\nCOMPLETED\n<taipy.core.submission.submission.Submission object at 0x000001BAC6CCCE90>\n<taipy.core.submission.submission.Submission object at 0x000001BAC6CCD310>\n{'submission_status': 'COMPLETED', 'submittable_entity': my_scenario, 'origin_entity_id': 'SCENARIO_my_scenario_6c3d70af-a896-46f8-a0dc-4f17628b29d4', 'origin_entity_type': 'SCENARIO', 'origin_entity_config_id': 'my_scenario', 'creation_date': datetime.datetime(2024, 10, 25, 11, 50, 4, 207191), 'version': '5395d6e1-e5b7-4c2e-a391-7f71d04e8047', 'job_triggered_submission_status_changed': 'JOB_double_bd8e666f-5ce5-40ad-8694-af7d02a3faec'}\n{'submission_status': 'COMPLETED', 'submittable_entity': my_scenario}\n```\n\n## Expected behavior\n\nThis callback should be called once with these parameters\n\n### Version of Taipy\n\n- release/4.0\n- develop\n\n### Acceptance Criteria\n\n- [ ] A unit test reproducing the bug is added.\n- [ ] Any new code is covered by a unit tested.\n- [ ] Check code coverage is at least 90%.\n- [ ] The bug reporter validated the fix.\n- [ ] Related issue(s) in taipy-doc are created for documentation and Release Notes are updated.\n\n\n### Code of Conduct\n\n- [X] I have checked the [existing issues](https://github.com/Avaiga/taipy/issues?q=is%3Aissue+).\n- [ ] I am willing to work on this issue (optional)\n[\ud83d\udc1b BUG] On_submission_change - submission is completed twice\n### What went wrong? \ud83e\udd14\n\nThe callback is called twice sometimes with the same parameters. It leads to notifying twice the user that the scenario is completed.\n\n## How to replicate\n\n```python\nfrom taipy import Config\nimport taipy as tp\nfrom taipy.gui import Gui, notify\n\n\n# Normal function used by Taipy\ndef double(nb):\n    return nb * 2\n\n\n# Configuration of Data Nodes\ninput_cfg = Config.configure_data_node(\"input_dn\", default_data=21)\noutput_cfg = Config.configure_data_node(\"output_dn\")\n\n\n# Configuration of tasks\nfirst_task_cfg = Config.configure_task(\"double\",\n                                       double,\n                                       input_cfg,\n                                       output_cfg)\n\n\n# Configuration of scenario\nscenario_cfg = Config.configure_scenario(id=\"my_scenario\",\n                                         task_configs=[first_task_cfg],\n                                         name=\"my_scenario\")\n\n\n\ndef notify_from_submissions(state, submittable, details):\n    submission_status = details.get('submission_status')\n\n    if submission_status == 'COMPLETED':\n        print(\"COMPLETED\")\n        print(submittable)\n        print(details)\n        notify(state, 'success', 'Completed!')\n        # Add additional actions here, like updating the GUI or logging the completion.\n\n    elif submission_status == 'FAILED':\n        print(\"FAILED\")\n        notify(state, 'error', 'FAILED!')\n        # Handle failure, like sending notifications or logging the error.\n\n\nif __name__==\"__main__\":\n    tp.Orchestrator().run()\n    scenario_1 = tp.create_scenario(scenario_cfg)\n\n    scenario_md = \"\"\"\n<|{scenario_1}|scenario|on_submission_change=notify_from_submissions|>\n\"\"\"\n    Gui(scenario_md).run()\n```\n\nThis is what I receive sometimes. The callback is called twice:\n\n```console\n[2024-10-25 11:50:04.385][Taipy][INFO] job JOB_double_bd8e666f-5ce5-40ad-8694-af7d02a3faec is completed.\nCOMPLETED\nCOMPLETED\n<taipy.core.submission.submission.Submission object at 0x000001BAC6CCCE90>\n<taipy.core.submission.submission.Submission object at 0x000001BAC6CCD310>\n{'submission_status': 'COMPLETED', 'submittable_entity': my_scenario, 'origin_entity_id': 'SCENARIO_my_scenario_6c3d70af-a896-46f8-a0dc-4f17628b29d4', 'origin_entity_type': 'SCENARIO', 'origin_entity_config_id': 'my_scenario', 'creation_date': datetime.datetime(2024, 10, 25, 11, 50, 4, 207191), 'version': '5395d6e1-e5b7-4c2e-a391-7f71d04e8047', 'job_triggered_submission_status_changed': 'JOB_double_bd8e666f-5ce5-40ad-8694-af7d02a3faec'}\n{'submission_status': 'COMPLETED', 'submittable_entity': my_scenario}\n```\n\n## Expected behavior\n\nThis callback should be called once with these parameters\n\n### Version of Taipy\n\n- release/4.0\n- develop\n\n### Acceptance Criteria\n\n- [ ] A unit test reproducing the bug is added.\n- [ ] Any new code is covered by a unit tested.\n- [ ] Check code coverage is at least 90%.\n- [ ] The bug reporter validated the fix.\n- [ ] Related issue(s) in taipy-doc are created for documentation and Release Notes are updated.\n\n\n### Code of Conduct\n\n- [X] I have checked the [existing issues](https://github.com/Avaiga/taipy/issues?q=is%3Aissue+).\n- [ ] I am willing to work on this issue (optional)\n", "hints_text": "Hmmm I'm running it on the develop branch and it doesn't seem to have this issue\r\n![image](https://github.com/user-attachments/assets/a0f69c6c-d456-437a-be4a-f5db99d87e9d)\r\n\nBut the problem does happen on 4.0!\r\n![image](https://github.com/user-attachments/assets/541d8390-8418-42d4-85b3-46ab64aac632)\r\n\nI can see it is closed. \r\nIt should be backported to release/4.0. Did I miss the PR for the backport, or is it planned for the future?\r\n@toan-quach @FredLL-Avaiga \nI guess @FabienLelaquais has backported this ?\nAll right. Thx!\nHmmm I'm running it on the develop branch and it doesn't seem to have this issue\r\n![image](https://github.com/user-attachments/assets/a0f69c6c-d456-437a-be4a-f5db99d87e9d)\r\n\nBut the problem does happen on 4.0!\r\n![image](https://github.com/user-attachments/assets/541d8390-8418-42d4-85b3-46ab64aac632)\r\n\nI can see it is closed. \r\nIt should be backported to release/4.0. Did I miss the PR for the backport, or is it planned for the future?\r\n@toan-quach @FredLL-Avaiga \nI guess @FabienLelaquais has backported this ?\nAll right. Thx!", "created_at": "2024-12-17T08:36:47Z"}
{"repo": "Avaiga/taipy", "pull_number": 2328, "instance_id": "Avaiga__taipy-2328", "issue_numbers": ["2298"], "base_commit": "cacd40011ebb22c0462bb5610fe63c8692a92b67", "patch": "diff --git a/taipy/core/config/checkers/_data_node_config_checker.py b/taipy/core/config/checkers/_data_node_config_checker.py\nindex 823da79069..e7f35ab66b 100644\n--- a/taipy/core/config/checkers/_data_node_config_checker.py\n+++ b/taipy/core/config/checkers/_data_node_config_checker.py\n@@ -10,7 +10,7 @@\n # specific language governing permissions and limitations under the License.\n \n from datetime import timedelta\n-from typing import Any, Callable, Dict, List, Tuple, cast\n+from typing import Callable, Dict, List, cast\n \n from taipy.common.config._config import _Config\n from taipy.common.config.checker._checkers._config_checker import _ConfigChecker\n@@ -23,27 +23,6 @@\n \n \n class _DataNodeConfigChecker(_ConfigChecker):\n-    _PROPERTIES_TYPES: Dict[str, List[Tuple[Any, List[str]]]] = {\n-        DataNodeConfig._STORAGE_TYPE_VALUE_GENERIC: [\n-            (\n-                Callable,\n-                [\n-                    DataNodeConfig._OPTIONAL_READ_FUNCTION_GENERIC_PROPERTY,\n-                    DataNodeConfig._OPTIONAL_WRITE_FUNCTION_GENERIC_PROPERTY,\n-                ],\n-            )\n-        ],\n-        DataNodeConfig._STORAGE_TYPE_VALUE_SQL: [\n-            (\n-                Callable,\n-                [\n-                    DataNodeConfig._REQUIRED_WRITE_QUERY_BUILDER_SQL_PROPERTY,\n-                    DataNodeConfig._OPTIONAL_APPEND_QUERY_BUILDER_SQL_PROPERTY,\n-                ],\n-            ),\n-        ],\n-    }\n-\n     def __init__(self, config: _Config, collector: IssueCollector):\n         super().__init__(config, collector)\n \n@@ -67,7 +46,7 @@ def _check(self) -> IssueCollector:\n             self._check_scope(data_node_config_id, data_node_config)\n             self._check_validity_period(data_node_config_id, data_node_config)\n             self._check_required_properties(data_node_config_id, data_node_config)\n-            self._check_class_type(data_node_config_id, data_node_config)\n+            self._check_property_types(data_node_config_id, data_node_config)\n             self._check_generic_read_write_fct_and_args(data_node_config_id, data_node_config)\n             self._check_exposed_type(data_node_config_id, data_node_config)\n         return self._collector\n@@ -217,25 +196,26 @@ def _check_generic_read_write_fct_and_args(self, data_node_config_id: str, data_\n                     f\"DataNodeConfig `{data_node_config_id}` must be populated with a Callable function.\",\n                 )\n \n-    def _check_class_type(self, data_node_config_id: str, data_node_config: DataNodeConfig):\n-        if data_node_config.storage_type in self._PROPERTIES_TYPES.keys():\n-            for class_type, prop_keys in self._PROPERTIES_TYPES[data_node_config.storage_type]:\n-                for prop_key in prop_keys:\n-                    prop_value = data_node_config.properties.get(prop_key) if data_node_config.properties else None\n-                    if prop_value and not isinstance(prop_value, class_type):\n-                        self._error(\n-                            prop_key,\n-                            prop_value,\n-                            f\"`{prop_key}` of DataNodeConfig `{data_node_config_id}` must be\"\n-                            f\" populated with a {'Callable' if class_type == Callable else class_type.__name__}.\",\n-                        )\n-                    if class_type == Callable and callable(prop_value) and prop_value.__name__ == \"<lambda>\":\n-                        self._error(\n-                            prop_key,\n-                            prop_value,\n-                            f\"`{prop_key}` of DataNodeConfig `{data_node_config_id}` must be\"\n-                            f\" populated with a serializable Callable function but not a lambda.\",\n-                        )\n+    def _check_property_types(self, data_node_config_id: str, data_node_config: DataNodeConfig):\n+        if property_types := data_node_config._PROPERTIES_TYPES.get(data_node_config.storage_type):\n+            for prop_key, prop_type in property_types.items():\n+                prop_value = data_node_config.properties.get(prop_key) if data_node_config.properties else None\n+\n+                if prop_value and not isinstance(prop_value, prop_type):\n+                    self._error(\n+                        prop_key,\n+                        prop_value,\n+                        f\"`{prop_key}` of DataNodeConfig `{data_node_config_id}` must be\"\n+                        f\" populated with a {prop_type}.\",\n+                    )\n+\n+                if prop_type == Callable and callable(prop_value) and prop_value.__name__ == \"<lambda>\":\n+                    self._error(\n+                        prop_key,\n+                        prop_value,\n+                        f\"`{prop_key}` of DataNodeConfig `{data_node_config_id}` must be\"\n+                        f\" populated with a serializable typing.Callable function but not a lambda.\",\n+                    )\n \n     def _check_exposed_type(self, data_node_config_id: str, data_node_config: DataNodeConfig):\n         if not isinstance(data_node_config.exposed_type, str):\ndiff --git a/taipy/core/config/data_node_config.py b/taipy/core/config/data_node_config.py\nindex 8edc6ce171..abf6293da7 100644\n--- a/taipy/core/config/data_node_config.py\n+++ b/taipy/core/config/data_node_config.py\n@@ -38,7 +38,7 @@ class DataNodeConfig(Section):\n     \"\"\"\n \n     name = \"DATA_NODE\"\n-\n+    _ALL_TYPES = (str, int, float, bool, list, dict, tuple, set, type(None), callable)\n     _STORAGE_TYPE_KEY = \"storage_type\"\n     _STORAGE_TYPE_VALUE_PICKLE = \"pickle\"\n     _STORAGE_TYPE_VALUE_SQL_TABLE = \"sql_table\"\n@@ -150,6 +150,99 @@ class DataNodeConfig(Section):\n     _OPTIONAL_AWS_S3_GET_OBJECT_PARAMETERS_PROPERTY = \"aws_s3_get_object_parameters\"\n     _OPTIONAL_AWS_S3_PUT_OBJECT_PARAMETERS_PROPERTY = \"aws_s3_put_object_parameters\"\n \n+    _PROPERTIES_TYPES: Dict[str, Dict[str, Any]] = {\n+        _STORAGE_TYPE_VALUE_GENERIC: {\n+            _OPTIONAL_READ_FUNCTION_GENERIC_PROPERTY: Callable,\n+            _OPTIONAL_WRITE_FUNCTION_GENERIC_PROPERTY: Callable,\n+            _OPTIONAL_READ_FUNCTION_ARGS_GENERIC_PROPERTY: list,\n+            _OPTIONAL_WRITE_FUNCTION_ARGS_GENERIC_PROPERTY: list,\n+        },\n+        _STORAGE_TYPE_VALUE_SQL: {\n+            _REQUIRED_DB_NAME_SQL_PROPERTY: str,\n+            _REQUIRED_DB_ENGINE_SQL_PROPERTY: str,\n+            _REQUIRED_READ_QUERY_SQL_PROPERTY: str,\n+            _REQUIRED_WRITE_QUERY_BUILDER_SQL_PROPERTY: Callable,\n+            _OPTIONAL_APPEND_QUERY_BUILDER_SQL_PROPERTY: Callable,\n+            _OPTIONAL_DB_USERNAME_SQL_PROPERTY: str,\n+            _OPTIONAL_DB_PASSWORD_SQL_PROPERTY: str,\n+            _OPTIONAL_HOST_SQL_PROPERTY: str,\n+            _OPTIONAL_PORT_SQL_PROPERTY: int,\n+            _OPTIONAL_DRIVER_SQL_PROPERTY: str,\n+            _OPTIONAL_FOLDER_PATH_SQLITE_PROPERTY: str,\n+            _OPTIONAL_FILE_EXTENSION_SQLITE_PROPERTY: str,\n+            _OPTIONAL_DB_EXTRA_ARGS_SQL_PROPERTY: dict,\n+            _OPTIONAL_EXPOSED_TYPE_SQL_PROPERTY: (str, Callable),\n+        },\n+        _STORAGE_TYPE_VALUE_SQL_TABLE: {\n+            _REQUIRED_DB_NAME_SQL_PROPERTY: str,\n+            _REQUIRED_DB_ENGINE_SQL_PROPERTY: str,\n+            _REQUIRED_TABLE_NAME_SQL_TABLE_PROPERTY: str,\n+            _OPTIONAL_DB_USERNAME_SQL_PROPERTY: str,\n+            _OPTIONAL_DB_PASSWORD_SQL_PROPERTY: str,\n+            _OPTIONAL_HOST_SQL_PROPERTY: str,\n+            _OPTIONAL_PORT_SQL_PROPERTY: int,\n+            _OPTIONAL_DRIVER_SQL_PROPERTY: str,\n+            _OPTIONAL_FOLDER_PATH_SQLITE_PROPERTY: str,\n+            _OPTIONAL_FILE_EXTENSION_SQLITE_PROPERTY: str,\n+            _OPTIONAL_DB_EXTRA_ARGS_SQL_PROPERTY: dict,\n+            _OPTIONAL_EXPOSED_TYPE_SQL_PROPERTY: (str, Callable),\n+        },\n+        _STORAGE_TYPE_VALUE_CSV: {\n+            _OPTIONAL_DEFAULT_PATH_CSV_PROPERTY: str,\n+            _OPTIONAL_ENCODING_PROPERTY: str,\n+            _OPTIONAL_HAS_HEADER_CSV_PROPERTY: bool,\n+            _OPTIONAL_EXPOSED_TYPE_CSV_PROPERTY: (str, Callable),\n+        },\n+        _STORAGE_TYPE_VALUE_EXCEL: {\n+            _OPTIONAL_DEFAULT_PATH_EXCEL_PROPERTY: str,\n+            _OPTIONAL_HAS_HEADER_EXCEL_PROPERTY: bool,\n+            _OPTIONAL_SHEET_NAME_EXCEL_PROPERTY: (str, list),\n+            _OPTIONAL_EXPOSED_TYPE_EXCEL_PROPERTY: (str, Callable),\n+        },\n+        _STORAGE_TYPE_VALUE_IN_MEMORY: {\n+            _OPTIONAL_DEFAULT_DATA_IN_MEMORY_PROPERTY: _ALL_TYPES,\n+        },\n+        _STORAGE_TYPE_VALUE_PICKLE: {\n+            _OPTIONAL_DEFAULT_PATH_PICKLE_PROPERTY: str,\n+            _OPTIONAL_DEFAULT_DATA_PICKLE_PROPERTY: _ALL_TYPES,\n+        },\n+        _STORAGE_TYPE_VALUE_JSON: {\n+            _OPTIONAL_DEFAULT_PATH_JSON_PROPERTY: str,\n+            _OPTIONAL_ENCODING_PROPERTY: str,\n+            _OPTIONAL_ENCODER_JSON_PROPERTY: json.JSONEncoder,\n+            _OPTIONAL_DECODER_JSON_PROPERTY: json.JSONDecoder,\n+        },\n+        _STORAGE_TYPE_VALUE_PARQUET: {\n+            _OPTIONAL_DEFAULT_PATH_PARQUET_PROPERTY: str,\n+            _OPTIONAL_ENGINE_PARQUET_PROPERTY: str,\n+            _OPTIONAL_COMPRESSION_PARQUET_PROPERTY: str,\n+            _OPTIONAL_READ_KWARGS_PARQUET_PROPERTY: dict,\n+            _OPTIONAL_WRITE_KWARGS_PARQUET_PROPERTY: dict,\n+            _OPTIONAL_EXPOSED_TYPE_PARQUET_PROPERTY: (str, Callable),\n+        },\n+        _STORAGE_TYPE_VALUE_MONGO_COLLECTION: {\n+            _REQUIRED_DB_NAME_MONGO_PROPERTY: str,\n+            _REQUIRED_COLLECTION_NAME_MONGO_PROPERTY: str,\n+            _OPTIONAL_CUSTOM_DOCUMENT_MONGO_PROPERTY: str,\n+            _OPTIONAL_USERNAME_MONGO_PROPERTY: str,\n+            _OPTIONAL_PASSWORD_MONGO_PROPERTY: str,\n+            _OPTIONAL_HOST_MONGO_PROPERTY: str,\n+            _OPTIONAL_PORT_MONGO_PROPERTY: int,\n+            _OPTIONAL_DRIVER_MONGO_PROPERTY: str,\n+            _OPTIONAL_DB_EXTRA_ARGS_MONGO_PROPERTY: dict,\n+        },\n+        _STORAGE_TYPE_VALUE_S3_OBJECT: {\n+            _REQUIRED_AWS_ACCESS_KEY_ID_PROPERTY: str,\n+            _REQUIRED_AWS_SECRET_ACCESS_KEY_PROPERTY: str,\n+            _REQUIRED_AWS_STORAGE_BUCKET_NAME_PROPERTY: str,\n+            _REQUIRED_AWS_S3_OBJECT_KEY_PROPERTY: str,\n+            _OPTIONAL_AWS_REGION_PROPERTY: str,\n+            _OPTIONAL_AWS_S3_CLIENT_PARAMETERS_PROPERTY: dict,\n+            _OPTIONAL_AWS_S3_GET_OBJECT_PARAMETERS_PROPERTY: dict,\n+            _OPTIONAL_AWS_S3_PUT_OBJECT_PARAMETERS_PROPERTY: dict,\n+        },\n+    }\n+\n     _REQUIRED_PROPERTIES: Dict[str, List] = {\n         _STORAGE_TYPE_VALUE_PICKLE: [],\n         _STORAGE_TYPE_VALUE_SQL_TABLE: [\n", "test_patch": "diff --git a/tests/core/config/checkers/test_data_node_config_checker.py b/tests/core/config/checkers/test_data_node_config_checker.py\nindex 7c9c3f93b5..8a687a4d0b 100644\n--- a/tests/core/config/checkers/test_data_node_config_checker.py\n+++ b/tests/core/config/checkers/test_data_node_config_checker.py\n@@ -513,12 +513,12 @@ def test_check_callable_properties(self, caplog):\n             Config.check()\n         assert len(Config._collector.errors) == 2\n         expected_error_message_1 = (\n-            \"`write_query_builder` of DataNodeConfig `new` must be populated with a Callable.\"\n+            \"`write_query_builder` of DataNodeConfig `new` must be populated with a typing.Callable.\"\n             \" Current value of property `write_query_builder` is 1.\"\n         )\n         assert expected_error_message_1 in caplog.text\n         expected_error_message_2 = (\n-            \"`append_query_builder` of DataNodeConfig `new` must be populated with a Callable.\"\n+            \"`append_query_builder` of DataNodeConfig `new` must be populated with a typing.Callable.\"\n             \" Current value of property `append_query_builder` is 2.\"\n         )\n         assert expected_error_message_2 in caplog.text\n@@ -530,7 +530,7 @@ def test_check_callable_properties(self, caplog):\n             Config.check()\n         assert len(Config._collector.errors) == 1\n         expected_error_messages = [\n-            \"`write_fct` of DataNodeConfig `new` must be populated with a Callable. Current value\"\n+            \"`write_fct` of DataNodeConfig `new` must be populated with a typing.Callable. Current value\"\n             \" of property `write_fct` is 12.\",\n         ]\n         assert all(message in caplog.text for message in expected_error_messages)\n@@ -542,7 +542,7 @@ def test_check_callable_properties(self, caplog):\n             Config.check()\n         assert len(Config._collector.errors) == 1\n         expected_error_messages = [\n-            \"`read_fct` of DataNodeConfig `new` must be populated with a Callable. Current value\"\n+            \"`read_fct` of DataNodeConfig `new` must be populated with a typing.Callable. Current value\"\n             \" of property `read_fct` is 5.\",\n         ]\n         assert all(message in caplog.text for message in expected_error_messages)\n@@ -554,9 +554,9 @@ def test_check_callable_properties(self, caplog):\n             Config.check()\n         assert len(Config._collector.errors) == 2\n         expected_error_messages = [\n-            \"`write_fct` of DataNodeConfig `new` must be populated with a Callable. Current value\"\n+            \"`write_fct` of DataNodeConfig `new` must be populated with a typing.Callable. Current value\"\n             \" of property `write_fct` is 9.\",\n-            \"`read_fct` of DataNodeConfig `new` must be populated with a Callable. Current value\"\n+            \"`read_fct` of DataNodeConfig `new` must be populated with a typing.Callable. Current value\"\n             \" of property `read_fct` is 5.\",\n         ]\n         assert all(message in caplog.text for message in expected_error_messages)\n@@ -588,10 +588,10 @@ def test_check_callable_properties(self, caplog):\n             Config.check()\n         assert len(Config._collector.errors) == 2\n         expected_error_messages = [\n-            \"`write_fct` of DataNodeConfig `new` must be populated with a serializable Callable function but\"\n+            \"`write_fct` of DataNodeConfig `new` must be populated with a serializable typing.Callable function but\"\n             \" not a lambda. Current value of property `write_fct` is <function TestDataNodeConfigChecker.\"\n             \"test_check_callable_properties.<locals>.<lambda>\",\n-            \"`read_fct` of DataNodeConfig `new` must be populated with a serializable Callable function but\"\n+            \"`read_fct` of DataNodeConfig `new` must be populated with a serializable typing.Callable function but\"\n             \" not a lambda. Current value of property `read_fct` is <function TestDataNodeConfigChecker.\"\n             \"test_check_callable_properties.<locals>.<lambda>\",\n         ]\n@@ -616,12 +616,15 @@ def test_check_read_write_fct_args(self, caplog):\n         with pytest.raises(SystemExit):\n             Config._collector = IssueCollector()\n             Config.check()\n-        assert len(Config._collector.errors) == 1\n-        expected_error_message = (\n+        assert len(Config._collector.errors) == 2\n+\n+        expected_error_messages = (\n+            \"`write_fct_args` of DataNodeConfig `default` must be populated with a <class 'list'>.\"\n+            ' Current value of property `write_fct_args` is \"foo\".',\n             \"`write_fct_args` field of DataNodeConfig `default` must be populated with a List value.\"\n-            ' Current value of property `write_fct_args` is \"foo\".'\n+            ' Current value of property `write_fct_args` is \"foo\".',\n         )\n-        assert expected_error_message in caplog.text\n+        assert all(message in caplog.text for message in expected_error_messages)\n         config._sections[DataNodeConfig.name][\"default\"].storage_type = \"generic\"\n         config._sections[DataNodeConfig.name][\"default\"].properties = {\n             \"write_fct\": print,\n@@ -641,12 +644,15 @@ def test_check_read_write_fct_args(self, caplog):\n         with pytest.raises(SystemExit):\n             Config._collector = IssueCollector()\n             Config.check()\n-        assert len(Config._collector.errors) == 1\n-        expected_error_message = (\n+        assert len(Config._collector.errors) == 2\n+\n+        expected_error_messages = (\n+            \"`read_fct_args` of DataNodeConfig `default` must be populated with a <class 'list'>.\"\n+            \" Current value of property `read_fct_args` is 1.\",\n             \"`read_fct_args` field of DataNodeConfig `default` must be populated with a List value.\"\n-            \" Current value of property `read_fct_args` is 1.\"\n+            \" Current value of property `read_fct_args` is 1.\",\n         )\n-        assert expected_error_message in caplog.text\n+        assert all(message in caplog.text for message in expected_error_messages)\n \n         config._sections[DataNodeConfig.name][\"default\"].storage_type = \"generic\"\n         config._sections[DataNodeConfig.name][\"default\"].properties = {\n", "problem_statement": "Add checker to check value type of configuration properties\n1. We should also add all the properties to check. not only the callable.\n\n2. The dictionary should be moved close to the definition of the properties, in the DataNodeCOnfig class.\n\n3. The format should be updated to `Dict[str, Dict[str, Any]]` from `Dict[str, List[Tuple[Any, List[str]]]]`\n\nExample:\n```\n{\n    DataNodeConfig._STORAGE_TYPE_VALUE_GENERIC: \n        {\n            DataNodeConfig._OPTIONAL_READ_FUNCTION_GENERIC_PROPERTY: Callable,\n            DataNodeConfig._OPTIONAL_WRITE_FUNCTION_GENERIC_PROPERTY: Callable\n        },\n    DataNodeConfig._STORAGE_TYPE_VALUE_SQL:\n        {\n            DataNodeConfig._REQUIRED_WRITE_QUERY_BUILDER_SQL_PROPERTY: Callable,\n            DataNodeConfig._OPTIONAL_APPEND_QUERY_BUILDER_SQL_PROPERTY: Callable\n        }\n}\n```\n\n4. Add the changes to documentation\n- An entry in the release notes as an improvement of the checkers for checking the property types.\n- A new item in the list: https://docs.taipy.io/en/develop/userman/advanced_features/configuration/config-checker/\n", "hints_text": "Hi @joaoandre-avaiga, @jrobinAV \n\nI want to ask you guys if we can expand this idea a bit further. I want to add 2 points that will make this ticket more complicated \ud83d\ude05 \n1. Can we also include parameters that can be None?\n2. Can we somehow declare that in case the value is None, we want to throw a warning except for an error (the message might have to be declared elsewhere)\n\nI'm thinking about this as I found a missing implementation in the current databricks ticket: https://github.com/Avaiga/taipy-enterprise/pull/557/files#diff-6dd483af9d43a6ce79f513e4d9cd499ddceef45cddcbb1a30b589aace7255b30R81", "created_at": "2024-12-13T01:48:12Z"}
{"repo": "Avaiga/taipy", "pull_number": 2325, "instance_id": "Avaiga__taipy-2325", "issue_numbers": ["2152", "2152"], "base_commit": "2e8c6ba22676f234411f800313723f9d1a5e1252", "patch": "diff --git a/taipy/gui_core/_context.py b/taipy/gui_core/_context.py\nindex 8928d589af..82f8b7bdad 100644\n--- a/taipy/gui_core/_context.py\n+++ b/taipy/gui_core/_context.py\n@@ -639,11 +639,10 @@ def submit_entity(self, state: State, id: str, payload: t.Dict[str, str]):\n                     client_id=self.gui._get_client_id(),\n                     module_context=self.gui._get_locals_context(),\n                 )\n-                client_status = _ClientStatus(self.gui._get_client_id(), submission_entity.submission_status)\n+                client_status = _ClientStatus(self.gui._get_client_id(), None)\n                 with self.submissions_lock:\n                     self.client_submission[submission_entity.id] = client_status\n                 if Config.core.mode == \"development\":\n-                    client_status.submission_status = SubmissionStatus.SUBMITTED\n                     self.submission_status_callback(submission_entity.id)\n                 _GuiCoreContext.__assign_var(state, error_var, \"\")\n         except Exception as e:\n@@ -715,7 +714,6 @@ def _get_sort_params(params: t.Optional[t.List[t.Any]] = None, parent: t.Optiona\n                     args.append(None)\n         return args\n \n-\n     def get_sorted_datanode_list(\n         self,\n         entities: t.Union[\ndiff --git a/taipy/gui_core/_utils.py b/taipy/gui_core/_utils.py\nindex bdb7656b7b..27fe9f09f1 100644\n--- a/taipy/gui_core/_utils.py\n+++ b/taipy/gui_core/_utils.py\n@@ -17,4 +17,4 @@\n @dataclass\n class _ClientStatus:\n     client_id: t.Optional[str]\n-    submission_status: SubmissionStatus\n+    submission_status: t.Optional[SubmissionStatus]\n", "test_patch": "diff --git a/tests/gui_core/test_context_is_readable.py b/tests/gui_core/test_context_is_readable.py\nindex e495a238ca..d321f31fb6 100644\n--- a/tests/gui_core/test_context_is_readable.py\n+++ b/tests/gui_core/test_context_is_readable.py\n@@ -25,7 +25,7 @@\n from taipy.core.job._job_manager_factory import _JobManagerFactory\n from taipy.core.scenario._scenario_manager_factory import _ScenarioManagerFactory\n from taipy.core.submission._submission_manager_factory import _SubmissionManagerFactory\n-from taipy.core.submission.submission import Submission, SubmissionStatus\n+from taipy.core.submission.submission import Submission\n from taipy.core.task._task_manager_factory import _TaskManagerFactory\n from taipy.gui import Gui, State\n from taipy.gui_core._context import _GuiCoreContext\n@@ -204,7 +204,7 @@ def test_submission_status_callback(self):\n             mockGui._get_authorization = lambda s: contextlib.nullcontext()\n             gui_core_context = _GuiCoreContext(mockGui)\n \n-            gui_core_context.client_submission[a_submission.id] = _ClientStatus(\"client_id\", SubmissionStatus.UNDEFINED)\n+            gui_core_context.client_submission[a_submission.id] = _ClientStatus(\"client_id\", None)\n             gui_core_context.submission_status_callback(a_submission.id)\n             mockget.assert_called()\n             found = False\n", "problem_statement": "[\ud83d\udc1b BUG] On_submission_change - submission is completed twice\n### What went wrong? \ud83e\udd14\n\nThe callback is called twice sometimes with the same parameters. It leads to notifying twice the user that the scenario is completed.\n\n## How to replicate\n\n```python\nfrom taipy import Config\nimport taipy as tp\nfrom taipy.gui import Gui, notify\n\n\n# Normal function used by Taipy\ndef double(nb):\n    return nb * 2\n\n\n# Configuration of Data Nodes\ninput_cfg = Config.configure_data_node(\"input_dn\", default_data=21)\noutput_cfg = Config.configure_data_node(\"output_dn\")\n\n\n# Configuration of tasks\nfirst_task_cfg = Config.configure_task(\"double\",\n                                       double,\n                                       input_cfg,\n                                       output_cfg)\n\n\n# Configuration of scenario\nscenario_cfg = Config.configure_scenario(id=\"my_scenario\",\n                                         task_configs=[first_task_cfg],\n                                         name=\"my_scenario\")\n\n\n\ndef notify_from_submissions(state, submittable, details):\n    submission_status = details.get('submission_status')\n\n    if submission_status == 'COMPLETED':\n        print(\"COMPLETED\")\n        print(submittable)\n        print(details)\n        notify(state, 'success', 'Completed!')\n        # Add additional actions here, like updating the GUI or logging the completion.\n\n    elif submission_status == 'FAILED':\n        print(\"FAILED\")\n        notify(state, 'error', 'FAILED!')\n        # Handle failure, like sending notifications or logging the error.\n\n\nif __name__==\"__main__\":\n    tp.Orchestrator().run()\n    scenario_1 = tp.create_scenario(scenario_cfg)\n\n    scenario_md = \"\"\"\n<|{scenario_1}|scenario|on_submission_change=notify_from_submissions|>\n\"\"\"\n    Gui(scenario_md).run()\n```\n\nThis is what I receive sometimes. The callback is called twice:\n\n```console\n[2024-10-25 11:50:04.385][Taipy][INFO] job JOB_double_bd8e666f-5ce5-40ad-8694-af7d02a3faec is completed.\nCOMPLETED\nCOMPLETED\n<taipy.core.submission.submission.Submission object at 0x000001BAC6CCCE90>\n<taipy.core.submission.submission.Submission object at 0x000001BAC6CCD310>\n{'submission_status': 'COMPLETED', 'submittable_entity': my_scenario, 'origin_entity_id': 'SCENARIO_my_scenario_6c3d70af-a896-46f8-a0dc-4f17628b29d4', 'origin_entity_type': 'SCENARIO', 'origin_entity_config_id': 'my_scenario', 'creation_date': datetime.datetime(2024, 10, 25, 11, 50, 4, 207191), 'version': '5395d6e1-e5b7-4c2e-a391-7f71d04e8047', 'job_triggered_submission_status_changed': 'JOB_double_bd8e666f-5ce5-40ad-8694-af7d02a3faec'}\n{'submission_status': 'COMPLETED', 'submittable_entity': my_scenario}\n```\n\n## Expected behavior\n\nThis callback should be called once with these parameters\n\n### Version of Taipy\n\n- release/4.0\n- develop\n\n### Acceptance Criteria\n\n- [ ] A unit test reproducing the bug is added.\n- [ ] Any new code is covered by a unit tested.\n- [ ] Check code coverage is at least 90%.\n- [ ] The bug reporter validated the fix.\n- [ ] Related issue(s) in taipy-doc are created for documentation and Release Notes are updated.\n\n\n### Code of Conduct\n\n- [X] I have checked the [existing issues](https://github.com/Avaiga/taipy/issues?q=is%3Aissue+).\n- [ ] I am willing to work on this issue (optional)\n[\ud83d\udc1b BUG] On_submission_change - submission is completed twice\n### What went wrong? \ud83e\udd14\n\nThe callback is called twice sometimes with the same parameters. It leads to notifying twice the user that the scenario is completed.\n\n## How to replicate\n\n```python\nfrom taipy import Config\nimport taipy as tp\nfrom taipy.gui import Gui, notify\n\n\n# Normal function used by Taipy\ndef double(nb):\n    return nb * 2\n\n\n# Configuration of Data Nodes\ninput_cfg = Config.configure_data_node(\"input_dn\", default_data=21)\noutput_cfg = Config.configure_data_node(\"output_dn\")\n\n\n# Configuration of tasks\nfirst_task_cfg = Config.configure_task(\"double\",\n                                       double,\n                                       input_cfg,\n                                       output_cfg)\n\n\n# Configuration of scenario\nscenario_cfg = Config.configure_scenario(id=\"my_scenario\",\n                                         task_configs=[first_task_cfg],\n                                         name=\"my_scenario\")\n\n\n\ndef notify_from_submissions(state, submittable, details):\n    submission_status = details.get('submission_status')\n\n    if submission_status == 'COMPLETED':\n        print(\"COMPLETED\")\n        print(submittable)\n        print(details)\n        notify(state, 'success', 'Completed!')\n        # Add additional actions here, like updating the GUI or logging the completion.\n\n    elif submission_status == 'FAILED':\n        print(\"FAILED\")\n        notify(state, 'error', 'FAILED!')\n        # Handle failure, like sending notifications or logging the error.\n\n\nif __name__==\"__main__\":\n    tp.Orchestrator().run()\n    scenario_1 = tp.create_scenario(scenario_cfg)\n\n    scenario_md = \"\"\"\n<|{scenario_1}|scenario|on_submission_change=notify_from_submissions|>\n\"\"\"\n    Gui(scenario_md).run()\n```\n\nThis is what I receive sometimes. The callback is called twice:\n\n```console\n[2024-10-25 11:50:04.385][Taipy][INFO] job JOB_double_bd8e666f-5ce5-40ad-8694-af7d02a3faec is completed.\nCOMPLETED\nCOMPLETED\n<taipy.core.submission.submission.Submission object at 0x000001BAC6CCCE90>\n<taipy.core.submission.submission.Submission object at 0x000001BAC6CCD310>\n{'submission_status': 'COMPLETED', 'submittable_entity': my_scenario, 'origin_entity_id': 'SCENARIO_my_scenario_6c3d70af-a896-46f8-a0dc-4f17628b29d4', 'origin_entity_type': 'SCENARIO', 'origin_entity_config_id': 'my_scenario', 'creation_date': datetime.datetime(2024, 10, 25, 11, 50, 4, 207191), 'version': '5395d6e1-e5b7-4c2e-a391-7f71d04e8047', 'job_triggered_submission_status_changed': 'JOB_double_bd8e666f-5ce5-40ad-8694-af7d02a3faec'}\n{'submission_status': 'COMPLETED', 'submittable_entity': my_scenario}\n```\n\n## Expected behavior\n\nThis callback should be called once with these parameters\n\n### Version of Taipy\n\n- release/4.0\n- develop\n\n### Acceptance Criteria\n\n- [ ] A unit test reproducing the bug is added.\n- [ ] Any new code is covered by a unit tested.\n- [ ] Check code coverage is at least 90%.\n- [ ] The bug reporter validated the fix.\n- [ ] Related issue(s) in taipy-doc are created for documentation and Release Notes are updated.\n\n\n### Code of Conduct\n\n- [X] I have checked the [existing issues](https://github.com/Avaiga/taipy/issues?q=is%3Aissue+).\n- [ ] I am willing to work on this issue (optional)\n", "hints_text": "Hmmm I'm running it on the develop branch and it doesn't seem to have this issue\r\n![image](https://github.com/user-attachments/assets/a0f69c6c-d456-437a-be4a-f5db99d87e9d)\r\n\nBut the problem does happen on 4.0!\r\n![image](https://github.com/user-attachments/assets/541d8390-8418-42d4-85b3-46ab64aac632)\r\n\nHmmm I'm running it on the develop branch and it doesn't seem to have this issue\r\n![image](https://github.com/user-attachments/assets/a0f69c6c-d456-437a-be4a-f5db99d87e9d)\r\n\nBut the problem does happen on 4.0!\r\n![image](https://github.com/user-attachments/assets/541d8390-8418-42d4-85b3-46ab64aac632)\r\n", "created_at": "2024-12-12T10:11:48Z"}
{"repo": "Avaiga/taipy", "pull_number": 2321, "instance_id": "Avaiga__taipy-2321", "issue_numbers": ["2319"], "base_commit": "44c366312b73a366ab9238dff03d938c85d1758e", "patch": "diff --git a/taipy/core/_orchestrator/_dispatcher/_job_dispatcher.py b/taipy/core/_orchestrator/_dispatcher/_job_dispatcher.py\nindex 7a43f43923..b1ea92cc76 100644\n--- a/taipy/core/_orchestrator/_dispatcher/_job_dispatcher.py\n+++ b/taipy/core/_orchestrator/_dispatcher/_job_dispatcher.py\n@@ -159,4 +159,7 @@ def _update_job_status(job: Job, exceptions):\n                 _TaipyLogger._get_logger().error(st)\n             _JobManagerFactory._build_manager()._set(job)\n         else:\n+            for output in job.task.output.values():\n+                output.track_edit(job_id=job.id)\n+                output.unlock_edit()\n             job.completed()\ndiff --git a/taipy/core/_orchestrator/_dispatcher/_task_function_wrapper.py b/taipy/core/_orchestrator/_dispatcher/_task_function_wrapper.py\nindex f410ca9191..3a83ccf2f2 100644\n--- a/taipy/core/_orchestrator/_dispatcher/_task_function_wrapper.py\n+++ b/taipy/core/_orchestrator/_dispatcher/_task_function_wrapper.py\n@@ -65,7 +65,7 @@ def _write_data(self, outputs: List[DataNode], results, job_id: JobId):\n                 for res, dn in zip(_results, outputs):\n                     try:\n                         data_node = data_manager._get(dn.id)\n-                        data_node.write(res, job_id=job_id)\n+                        data_node._write(res)\n                     except Exception as e:\n                         logger.error(\"Error during write\", exc_info=1)\n                         exceptions.append(DataNodeWritingError(f\"Error writing in datanode id {dn.id}: {e}\"))\n", "test_patch": "diff --git a/tests/core/job/test_job.py b/tests/core/job/test_job.py\nindex 9bf16a1990..b6d9b239d2 100644\n--- a/tests/core/job/test_job.py\n+++ b/tests/core/job/test_job.py\n@@ -72,10 +72,10 @@ def job(task, job_id):\n \n @pytest.fixture\n def replace_in_memory_write_fct():\n-    default_write = InMemoryDataNode.write\n-    InMemoryDataNode.write = _error\n+    default_write = InMemoryDataNode._write\n+    InMemoryDataNode._write = _error\n     yield\n-    InMemoryDataNode.write = default_write\n+    InMemoryDataNode._write = default_write\n \n \n def _foo():\n", "problem_statement": "[\ud83d\udc1b BUG] Never receiving Data Node notifications/update with Core event\n### What went wrong? \ud83e\udd14\r\n\r\nTaipy doesn't always publish the event of a data node update. Therefore, when a data node is changed, creating simple code to update my UI through Core events is impossible.\r\n\r\n### Expected Behavior\r\n\r\nI should receive all the appropriate events.\r\n\r\n### Steps to Reproduce Issue\r\n\r\nRun this code and the scenario:\r\n\r\n```python\r\nfrom taipy.core.notification import (\r\n    CoreEventConsumerBase,\r\n    Event,\r\n    EventEntityType,\r\n    EventOperation,\r\n    Notifier,\r\n)\r\nimport taipy as tp\r\nimport taipy.gui.builder as tgb\r\nfrom taipy.gui import Gui, State, notify\r\nfrom taipy.core import Scenario, DataNode\r\nfrom taipy import Config\r\n\r\nimport time\r\nimport random\r\nimport pandas as pd\r\n\r\n\r\ndef some_task_1(input_data):\r\n    time.sleep(2)\r\n    print(\"Hello world\")\r\n    return \"hello world\"\r\n\r\n\r\ndef some_task_2(intermediate_data):\r\n    time.sleep(2)\r\n    print(f\"{intermediate_data} from Taipy!\")\r\n    random_value = random.randint(0, 100)\r\n    return f\"{intermediate_data} from Taipy! {random_value}\"\r\n\r\n\r\nConfig.configure_job_executions(mode=\"standalone\", max_nb_of_workers=2)\r\n\r\ninput_data_cfg = Config.configure_csv_data_node(id=\"input_data\", default_data={\"x\": [1, 2, 3], \"y\": [4, 5, 6]})\r\nintermediate_data_cfg = Config.configure_data_node(id=\"intermediate_data\")\r\noutput_data_cfg = Config.configure_data_node(id=\"output_data\")\r\n\r\ntask_1_cfg = Config.configure_task(\r\n    id=\"task_1\",\r\n    function=some_task_1,\r\n    input=input_data_cfg,\r\n    output=intermediate_data_cfg,\r\n    skippable=True,\r\n)\r\n\r\ntask_2_cfg = Config.configure_task(\r\n    id=\"task_2\",\r\n    function=some_task_2,\r\n    input=intermediate_data_cfg,\r\n    output=output_data_cfg,\r\n    skippable=True,\r\n)\r\n\r\nscenario_cfg = Config.configure_scenario(\r\n    id=\"scenario\",\r\n    task_configs=[task_1_cfg, task_2_cfg],\r\n)\r\n\r\n\r\ndef notify_user(state, data_node, scenarios):\r\n    if state.scenario.id in scenarios:\r\n        if data_node.config_id == \"input_data\":\r\n            state.input_data = data_node.read()\r\n        if data_node.config_id == \"intermediate_data\":\r\n            notify(state, \"success\", \"Task 1 is finished!\")\r\n        if data_node.config_id == \"output_data\":\r\n            state.output_data = data_node.read()\r\n            notify(state, \"success\", \"Submission is finished!\")\r\n\r\n\r\nclass SpecificCoreConsumer(CoreEventConsumerBase):\r\n    def __init__(self, gui: Gui):\r\n        self.gui = gui\r\n\r\n        reg_id, queue = Notifier.register(\r\n            # attribute_name=\"last_edit_date\",\r\n        )  # Adapt the registration to the events you want to listen to\r\n        super().__init__(reg_id, queue)\r\n\r\n    def process_event(self, event: Event):\r\n        if (event.entity_type == EventEntityType.DATA_NODE\r\n                and event.operation == EventOperation.UPDATE\r\n                and event.attribute_name == \"last_edit_date\"):\r\n            print(\r\n                f\"Received event: {event.operation} - {event.entity_type} - {event.entity_id}\\n\"\r\n                f\"                {event.attribute_name} - {event.attribute_value}\\n\"\r\n            )\r\n            data_node: DataNode = tp.get(event.entity_id)\r\n            scenarios = [s.id for s in data_node.get_parents().get(\"scenario\")]\r\n            self.gui.broadcast_callback(\r\n                notify_user,\r\n                [data_node, scenarios],\r\n            )\r\n\r\ndef change_scenario(state: State):\r\n    state.input_data = state.scenario.input_data.read()\r\n    state.output_data = state.scenario.output_data.read()\r\n\r\ndef run_scenario(state: State):\r\n    print(\"Running scenario...\")\r\n    state.scenario.submit()\r\n    print(\"Done!\")\r\n\r\nif __name__ == \"__main__\":\r\n    tp.Orchestrator().run()\r\n    scenario: Scenario = tp.create_scenario(scenario_cfg)\r\n    input_data: pd.DataFrame = scenario.input_data.read()\r\n    output_data: int = scenario.output_data.read()\r\n\r\n    with tgb.Page() as page:\r\n        tgb.scenario_selector(scenario, on_change=change_scenario)\r\n        tgb.button(\"Run Scenario\", on_action=run_scenario)\r\n        tgb.chart(\"{input_data}\")\r\n        tgb.input(\"{output_data}\")\r\n\r\n    gui = Gui(page)\r\n    SpecificCoreConsumer(gui).start()\r\n    gui.run(debug=True)\r\n```\r\n\r\n\r\n\r\n### Versions of Taipy\r\n\r\n- develop\r\n- 4.0.1\r\n\r\n### Acceptance Criteria\r\n\r\n- [ ] A unit test reproducing the bug is added.\r\n- [ ] Any new code is covered by a unit tested.\r\n- [ ] Check code coverage is at least 90%.\r\n- [ ] The bug reporter validated the fix.\r\n- [ ] Related issue(s) in taipy-doc are created for documentation and Release Notes are updated.\r\n\r\n\r\n### Code of Conduct\r\n\r\n- [X] I have checked the [existing issues](https://github.com/Avaiga/taipy/issues?q=is%3Aissue+).\r\n- [ ] I am willing to work on this issue (optional)\n", "hints_text": "", "created_at": "2024-12-11T12:31:26Z"}
{"repo": "Avaiga/taipy", "pull_number": 2316, "instance_id": "Avaiga__taipy-2316", "issue_numbers": ["2319"], "base_commit": "9cc59f2fbd5ed3d261905923a9cb85dcd623e3f3", "patch": "diff --git a/.github/PULL_REQUEST_TEMPLATE.md b/.github/PULL_REQUEST_TEMPLATE.md\nindex 51f88beae8..07527d7c09 100644\n--- a/.github/PULL_REQUEST_TEMPLATE.md\n+++ b/.github/PULL_REQUEST_TEMPLATE.md\n@@ -32,9 +32,9 @@ _Describe which projects this change will impact and that needs to be backported\n ## Checklist\n _We encourage you to keep the code coverage percentage at 80% and above._\n \n-- [ ] Does this solution meet the acceptance criteria of the related issue?\n-- [ ] Is the related issue checklist completed?\n-- [ ] Does this PR adds unit tests for the developed code? If not, why?\n-- [ ] End-to-End tests have been added or updated?\n-- [ ] Was the documentation updated, or a dedicated issue for documentation created? (If applicable)\n-- [ ] Is the release notes updated? (If applicable)\n+- [ ] This solution meets the acceptance criteria of the related issue.\n+- [ ] The related issue checklist is completed.\n+- [ ] This PR adds unit tests for the developed code. If not, why?\n+- [ ] End-to-End tests have been added or updated. If not, why?\n+- [ ] The documentation has been updated, or a dedicated issue created. (If applicable)\n+- [ ] The release notes have been updated? (If applicable)\ndiff --git a/taipy/core/_orchestrator/_dispatcher/_job_dispatcher.py b/taipy/core/_orchestrator/_dispatcher/_job_dispatcher.py\nindex aa325ec23c..f6d46fb310 100644\n--- a/taipy/core/_orchestrator/_dispatcher/_job_dispatcher.py\n+++ b/taipy/core/_orchestrator/_dispatcher/_job_dispatcher.py\n@@ -159,4 +159,7 @@ def _update_job_status(job: Job, exceptions):\n                 _TaipyLogger._get_logger().error(st)\n             _JobManagerFactory._build_manager()._set(job)\n         else:\n+            for output in job.task.output.values():\n+                output.track_edit(job_id=job.id)\n+                output.unlock_edit()\n             job.completed()\ndiff --git a/taipy/core/_orchestrator/_dispatcher/_task_function_wrapper.py b/taipy/core/_orchestrator/_dispatcher/_task_function_wrapper.py\nindex f410ca9191..3a83ccf2f2 100644\n--- a/taipy/core/_orchestrator/_dispatcher/_task_function_wrapper.py\n+++ b/taipy/core/_orchestrator/_dispatcher/_task_function_wrapper.py\n@@ -65,7 +65,7 @@ def _write_data(self, outputs: List[DataNode], results, job_id: JobId):\n                 for res, dn in zip(_results, outputs):\n                     try:\n                         data_node = data_manager._get(dn.id)\n-                        data_node.write(res, job_id=job_id)\n+                        data_node._write(res)\n                     except Exception as e:\n                         logger.error(\"Error during write\", exc_info=1)\n                         exceptions.append(DataNodeWritingError(f\"Error writing in datanode id {dn.id}: {e}\"))\ndiff --git a/taipy/core/data/data_node.py b/taipy/core/data/data_node.py\nindex 2b9d3bba05..67dcfc0f98 100644\n--- a/taipy/core/data/data_node.py\n+++ b/taipy/core/data/data_node.py\n@@ -461,8 +461,6 @@ def write(self,\n             **kwargs (Any): Extra information to attach to the edit document\n                 corresponding to this write.\n         \"\"\"\n-        from ._data_manager_factory import _DataManagerFactory\n-\n         if (editor_id\n             and self.edit_in_progress\n             and self.editor_id != editor_id\n@@ -471,6 +469,8 @@ def write(self,\n         self._write(data)\n         self.track_edit(job_id=job_id, editor_id=editor_id, comment=comment, **kwargs)\n         self.unlock_edit()\n+        from ._data_manager_factory import _DataManagerFactory\n+\n         _DataManagerFactory._build_manager()._set(self)\n \n     def track_edit(self,\n", "test_patch": "diff --git a/tests/core/_orchestrator/_dispatcher/test_dispatcher__update_job_status.py b/tests/core/_orchestrator/_dispatcher/test_dispatcher__update_job_status.py\nindex baecbd185b..674900a435 100644\n--- a/tests/core/_orchestrator/_dispatcher/test_dispatcher__update_job_status.py\n+++ b/tests/core/_orchestrator/_dispatcher/test_dispatcher__update_job_status.py\n@@ -10,19 +10,25 @@\n # specific language governing permissions and limitations under the License.\n import traceback\n \n-from taipy import Job, JobId, Status, Task\n+from taipy import Job, JobId, Scope, Status, Task\n from taipy.core._orchestrator._dispatcher import _JobDispatcher\n from taipy.core._orchestrator._orchestrator_factory import _OrchestratorFactory\n+from taipy.core.data import InMemoryDataNode\n+from taipy.core.data.data_node_id import EDIT_JOB_ID_KEY, EDIT_TIMESTAMP_KEY\n from taipy.core.job._job_manager_factory import _JobManagerFactory\n from taipy.core.task._task_manager_factory import _TaskManagerFactory\n \n \n def nothing(*args):\n-    pass\n+    return 42\n \n \n+def _error():\n+    raise RuntimeError(\"Something bad has happened\")\n+\n def test_update_job_status_no_exception():\n-    task = Task(\"config_id\", {}, nothing)\n+    output = InMemoryDataNode(\"data_node\", scope=Scope.SCENARIO)\n+    task = Task(\"config_id\",  {}, nothing, output=[output])\n     _TaskManagerFactory._build_manager()._set(task)\n     job = Job(JobId(\"id\"), task, \"s_id\", task.id)\n     _JobManagerFactory._build_manager()._set(job)\n@@ -31,6 +37,14 @@ def test_update_job_status_no_exception():\n \n     assert job.status == Status.COMPLETED\n     assert job.stacktrace == []\n+    assert len(output.edits) == 1\n+    assert len(output.edits[0]) == 2\n+    assert output.edits[0][EDIT_JOB_ID_KEY] == job.id\n+    assert output.edits[0][EDIT_TIMESTAMP_KEY] is not None\n+    assert output.last_edit_date is not None\n+    assert output.editor_id is None\n+    assert output.editor_expiration_date is None\n+    assert not output.edit_in_progress\n \n \n def test_update_job_status_with_one_exception():\ndiff --git a/tests/core/job/test_job.py b/tests/core/job/test_job.py\nindex 9bf16a1990..30bc56bcd7 100644\n--- a/tests/core/job/test_job.py\n+++ b/tests/core/job/test_job.py\n@@ -73,9 +73,12 @@ def job(task, job_id):\n @pytest.fixture\n def replace_in_memory_write_fct():\n     default_write = InMemoryDataNode.write\n+    default__write = InMemoryDataNode._write\n     InMemoryDataNode.write = _error\n+    InMemoryDataNode._write = _error\n     yield\n     InMemoryDataNode.write = default_write\n+    InMemoryDataNode._write = default__write\n \n \n def _foo():\ndiff --git a/tests/core/notification/test_events_published.py b/tests/core/notification/test_events_published.py\nindex b791d2ed42..abb580c706 100644\n--- a/tests/core/notification/test_events_published.py\n+++ b/tests/core/notification/test_events_published.py\n@@ -12,6 +12,9 @@\n from queue import SimpleQueue\n from typing import Any, Dict, List\n \n+import pytest\n+\n+from taipy import Orchestrator\n from taipy.common.config import Config, Frequency\n from taipy.core import taipy as tp\n from taipy.core.job.status import Status\n@@ -154,8 +157,10 @@ def test_events_published_for_writing_dn():\n     assert snapshot.operation_collected.get(EventOperation.UPDATE, 0) == 5\n     all_evts.stop()\n \n-\n-def test_events_published_for_scenario_submission():\n+@pytest.mark.parametrize(\"standalone\", [False, True])\n+def test_events_published_for_scenario_submission(standalone):\n+    if standalone:\n+        Config.configure_job_executions(mode=\"standalone\", max_nb_of_workers=2)\n     input_config = Config.configure_data_node(\"the_input\")\n     output_config = Config.configure_data_node(\"the_output\")\n     task_config = Config.configure_task(\"the_task\", identity, input=input_config, output=output_config)\n@@ -176,7 +181,11 @@ def test_events_published_for_scenario_submission():\n     # 1 submission update event for jobs\n     # 3 submission update events (for status: PENDING, RUNNING and COMPLETED)\n     # 1 submission update event for is_completed\n-    scenario.submit()\n+    if standalone:\n+        Orchestrator().run()\n+        scenario.submit(wait=True)\n+    else:\n+        scenario.submit()\n     snapshot = all_evts.capture()\n     assert len(snapshot.collected_events) == 18\n     assert snapshot.entity_type_collected.get(EventEntityType.CYCLE, 0) == 0\n", "problem_statement": "[\ud83d\udc1b BUG] Never receiving Data Node notifications/update with Core event\n### What went wrong? \ud83e\udd14\r\n\r\nTaipy doesn't always publish the event of a data node update. Therefore, when a data node is changed, creating simple code to update my UI through Core events is impossible.\r\n\r\n### Expected Behavior\r\n\r\nI should receive all the appropriate events.\r\n\r\n### Steps to Reproduce Issue\r\n\r\nRun this code and the scenario:\r\n\r\n```python\r\nfrom taipy.core.notification import (\r\n    CoreEventConsumerBase,\r\n    Event,\r\n    EventEntityType,\r\n    EventOperation,\r\n    Notifier,\r\n)\r\nimport taipy as tp\r\nimport taipy.gui.builder as tgb\r\nfrom taipy.gui import Gui, State, notify\r\nfrom taipy.core import Scenario, DataNode\r\nfrom taipy import Config\r\n\r\nimport time\r\nimport random\r\nimport pandas as pd\r\n\r\n\r\ndef some_task_1(input_data):\r\n    time.sleep(2)\r\n    print(\"Hello world\")\r\n    return \"hello world\"\r\n\r\n\r\ndef some_task_2(intermediate_data):\r\n    time.sleep(2)\r\n    print(f\"{intermediate_data} from Taipy!\")\r\n    random_value = random.randint(0, 100)\r\n    return f\"{intermediate_data} from Taipy! {random_value}\"\r\n\r\n\r\nConfig.configure_job_executions(mode=\"standalone\", max_nb_of_workers=2)\r\n\r\ninput_data_cfg = Config.configure_csv_data_node(id=\"input_data\", default_data={\"x\": [1, 2, 3], \"y\": [4, 5, 6]})\r\nintermediate_data_cfg = Config.configure_data_node(id=\"intermediate_data\")\r\noutput_data_cfg = Config.configure_data_node(id=\"output_data\")\r\n\r\ntask_1_cfg = Config.configure_task(\r\n    id=\"task_1\",\r\n    function=some_task_1,\r\n    input=input_data_cfg,\r\n    output=intermediate_data_cfg,\r\n    skippable=True,\r\n)\r\n\r\ntask_2_cfg = Config.configure_task(\r\n    id=\"task_2\",\r\n    function=some_task_2,\r\n    input=intermediate_data_cfg,\r\n    output=output_data_cfg,\r\n    skippable=True,\r\n)\r\n\r\nscenario_cfg = Config.configure_scenario(\r\n    id=\"scenario\",\r\n    task_configs=[task_1_cfg, task_2_cfg],\r\n)\r\n\r\n\r\ndef notify_user(state, data_node, scenarios):\r\n    if state.scenario.id in scenarios:\r\n        if data_node.config_id == \"input_data\":\r\n            state.input_data = data_node.read()\r\n        if data_node.config_id == \"intermediate_data\":\r\n            notify(state, \"success\", \"Task 1 is finished!\")\r\n        if data_node.config_id == \"output_data\":\r\n            state.output_data = data_node.read()\r\n            notify(state, \"success\", \"Submission is finished!\")\r\n\r\n\r\nclass SpecificCoreConsumer(CoreEventConsumerBase):\r\n    def __init__(self, gui: Gui):\r\n        self.gui = gui\r\n\r\n        reg_id, queue = Notifier.register(\r\n            # attribute_name=\"last_edit_date\",\r\n        )  # Adapt the registration to the events you want to listen to\r\n        super().__init__(reg_id, queue)\r\n\r\n    def process_event(self, event: Event):\r\n        if (event.entity_type == EventEntityType.DATA_NODE\r\n                and event.operation == EventOperation.UPDATE\r\n                and event.attribute_name == \"last_edit_date\"):\r\n            print(\r\n                f\"Received event: {event.operation} - {event.entity_type} - {event.entity_id}\\n\"\r\n                f\"                {event.attribute_name} - {event.attribute_value}\\n\"\r\n            )\r\n            data_node: DataNode = tp.get(event.entity_id)\r\n            scenarios = [s.id for s in data_node.get_parents().get(\"scenario\")]\r\n            self.gui.broadcast_callback(\r\n                notify_user,\r\n                [data_node, scenarios],\r\n            )\r\n\r\ndef change_scenario(state: State):\r\n    state.input_data = state.scenario.input_data.read()\r\n    state.output_data = state.scenario.output_data.read()\r\n\r\ndef run_scenario(state: State):\r\n    print(\"Running scenario...\")\r\n    state.scenario.submit()\r\n    print(\"Done!\")\r\n\r\nif __name__ == \"__main__\":\r\n    tp.Orchestrator().run()\r\n    scenario: Scenario = tp.create_scenario(scenario_cfg)\r\n    input_data: pd.DataFrame = scenario.input_data.read()\r\n    output_data: int = scenario.output_data.read()\r\n\r\n    with tgb.Page() as page:\r\n        tgb.scenario_selector(scenario, on_change=change_scenario)\r\n        tgb.button(\"Run Scenario\", on_action=run_scenario)\r\n        tgb.chart(\"{input_data}\")\r\n        tgb.input(\"{output_data}\")\r\n\r\n    gui = Gui(page)\r\n    SpecificCoreConsumer(gui).start()\r\n    gui.run(debug=True)\r\n```\r\n\r\n\r\n\r\n### Versions of Taipy\r\n\r\n- develop\r\n- 4.0.1\r\n\r\n### Acceptance Criteria\r\n\r\n- [ ] A unit test reproducing the bug is added.\r\n- [ ] Any new code is covered by a unit tested.\r\n- [ ] Check code coverage is at least 90%.\r\n- [ ] The bug reporter validated the fix.\r\n- [ ] Related issue(s) in taipy-doc are created for documentation and Release Notes are updated.\r\n\r\n\r\n### Code of Conduct\r\n\r\n- [X] I have checked the [existing issues](https://github.com/Avaiga/taipy/issues?q=is%3Aissue+).\r\n- [ ] I am willing to work on this issue (optional)\n", "hints_text": "", "created_at": "2024-12-10T17:59:23Z"}
